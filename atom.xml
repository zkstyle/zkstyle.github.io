<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elvis&#39;s Blogs</title>
  
  <subtitle>研一狗的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.vazh.cn/"/>
  <updated>2019-11-17T05:23:51.911Z</updated>
  <id>https://www.vazh.cn/</id>
  
  <author>
    <name>zkstyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode04-寻找两个有序数组的中位数</title>
    <link href="https://www.vazh.cn/2019/11/07/Leetcode04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://www.vazh.cn/2019/11/07/Leetcode04-寻找两个有序数组的中位数/</id>
    <published>2019-11-07T06:27:43.000Z</published>
    <updated>2019-11-17T05:23:51.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0<br>示例 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>为了解决这个问题，我们需要理解 “中位数的作用是什么”。在统计中，中位数被用来：</p><blockquote><p>将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</p></blockquote><p>如果理解了中位数的划分作用，我们就很接近答案了。</p><p>首先，让我们在任一位置 iii 将 A\text{A}A 划分成两个部分：</p><pre><code>      left_A             |        right_AA[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</code></pre><p>由于 A\text{A}A 中有 mmm 个元素， 所以我们有 m+1m+1m+1 种划分的方法（i\=0∼mi = 0 \sim mi\=0∼m）。</p><p>我们知道：</p><blockquote><p>len(left_A)\=i,len(right_A)\=m−i\text{len}(\text{left\_A}) = i, \text{len}(\text{right\_A}) = m - ilen(left_A)\=i,len(right_A)\=m−i.</p><p>注意：当 i\=0i = 0i\=0 时，left_A\text{left\_A}left_A 为空集， 而当 i\=mi = mi\=m 时, right_A\text{right\_A}right_A 为空集。</p></blockquote><p>采用同样的方式，我们在任一位置 jjj 将 B\text{B}B 划分成两个部分：</p><pre><code>      left_B             |        right_BB[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</code></pre><p>将 left_A\text{left\_A}left_A 和 left_B\text{left\_B}left_B 放入一个集合，并将 right_A\text{right\_A}right_A 和 right_B\text{right\_B}right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part\text{left\_part}left_part 和 right_part\text{right\_part}right_part：</p><pre><code>      left_part          |        right_partA[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</code></pre><p>如果我们可以确认：</p><blockquote><ol><li>len(left_part)\=len(right_part)\text{len}(\text{left\_part}) = \text{len}(\text{right\_part})len(left_part)\=len(right_part)</li><li>max⁡(left_part)≤min⁡(right_part)\max(\text{left\_part}) \leq \min(\text{right\_part})max(left_part)≤min(right_part)</li></ol></blockquote><p>那么，我们已经将 {A,B}\{\text{A}, \text{B}\}{A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：</p><p>median\=max(left_part)+min(right_part)2\text{median} = \frac{\text{max}(\text{left}\_\text{part}) + \text{min}(\text{right}\_\text{part})}{2} median\=2max(left_part)+min(right_part)</p><p>要确保这两个条件，我们只需要保证：</p><blockquote><ol><li><p>i+j\=m−i+n−ji + j = m - i + n - ji+j\=m−i+n−j（或：m−i+n−j+1m - i + n - j + 1m−i+n−j+1）<br>如果 n≥mn \geq mn≥m，只需要使 i\=0∼m,j\=m+n+12−i\ i = 0 \sim m,\ j = \frac{m + n + 1}{2} - i \\i\=0∼m,j\=2m+n+1−i</p></li><li><p>B[j−1]≤A[i]\text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 以及 A[i−1]≤B[j]\text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j]</p></li></ol></blockquote><p>ps.1 为了简化分析，我假设 A[i−1],B[j−1],A[i],B[j]\text{A}[i-1], \text{B}[j-1], \text{A}[i], \text{B}[j]A[i−1],B[j−1],A[i],B[j] 总是存在，哪怕出现 i\=0i=0i\=0，i\=mi=mi\=m，j\=0j=0j\=0，或是 j\=nj=nj\=n 这样的临界条件。<br>我将在最后讨论如何处理这些临界值。</p><p>ps.2 为什么 n≥mn \geq mn≥m？由于0≤i≤m0 \leq i \leq m0≤i≤m 且 j\=m+n+12−ij = \frac{m + n + 1}{2} - ij\=2m+n+1−i，我必须确保 jjj 不是负数。如果 n&lt;mn &lt; mn&lt;m，那么 jjj 将可能是负数，而这会造成错误的答案。</p><p>所以，我们需要做的是：</p><blockquote><p>在 [0，m][0，m][0，m] 中搜索并找到目标对象 iii，以使：</p><p>B[j−1]≤A[i]\qquad \text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 且 A[i−1]≤B[j],\text{A}[i-1] \leq \text{B}[j],A[i−1]≤B[j], 其中 j\=m+n+12−ij = \frac{m + n + 1}{2} - ij\=2m+n+1−i</p></blockquote><p>接着，我们可以按照以下步骤来进行二叉树搜索：</p><ol><li><p>设 imin\=0\text{imin} = 0imin\=0，imax\=m\text{imax} = mimax\=m, 然后开始在 [imin,imax][\text{imin}, \text{imax}][imin,imax] 中进行搜索。</p></li><li><p>令 i\=imin+imax2i = \frac{\text{imin} + \text{imax}}{2}i\=2imin+imax， j\=m+n+12−ij = \frac{m + n + 1}{2} - ij\=2m+n+1−i</p></li><li><p>现在我们有 len(left_part)\=len(right_part)\text{len}(\text{left}\_\text{part})=\text{len}(\text{right}\_\text{part})len(left_part)\=len(right_part)。 而且我们只会遇到三种情况：</p><ul><li><p>B[j−1]≤A[i]\text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 且 A[i−1]≤B[j]\text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j]：<br>这意味着我们找到了目标对象 iii，所以可以停止搜索。</p></li><li><p>B[j−1]>A[i]\text{B}[j-1] &gt; \text{A}[i]B[j−1]>A[i]：<br>这意味着 A[i]\text{A}[i]A[i] 太小，我们必须调整 iii 以使 B[j−1]≤A[i]\text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i]。<br>我们可以增大 iii 吗？  </p><pre><code>是的，因为当 iii 被增大的时候，jjj 就会被减小。  因此 B\[j−1\]\\text{B}\[j-1\]B\[j−1\] 会减小，而 A\[i\]\\text{A}\[i\]A\[i\] 会增大，那么 B\[j−1\]≤A\[i\]\\text{B}\[j-1\] \\leq \\text{A}\[i\]B\[j−1\]≤A\[i\] 就可能被满足。  </code></pre><p>我们可以减小 iii 吗？  </p><pre><code>不行，因为当 iii 被减小的时候，jjj 就会被增大。  因此 B\[j−1\]\\text{B}\[j-1\]B\[j−1\] 会增大，而 A\[i\]\\text{A}\[i\]A\[i\] 会减小，那么 B\[j−1\]≤A\[i\]\\text{B}\[j-1\] \\leq \\text{A}\[i\]B\[j−1\]≤A\[i\] 就可能不满足。  </code></pre><p>所以我们必须增大 iii。也就是说，我们必须将搜索范围调整为 [i+1,imax][i+1, \text{imax}][i+1,imax]。<br>因此，设 imin\=i+1\text{imin} = i+1imin\=i+1，并转到步骤 2。</p></li><li><p>A[i−1]>B[j]\text{A}[i-1] &gt; \text{B}[j]A[i−1]>B[j]：<br>这意味着 A[i−1]\text{A}[i-1]A[i−1] 太大，我们必须减小 iii 以使 A[i−1]≤B[j]\text{A}[i-1]\leq \text{B}[j]A[i−1]≤B[j]。<br>也就是说，我们必须将搜索范围调整为 [imin,i−1][\text{imin}, i-1][imin,i−1]。<br>因此，设 imax\=i−1\text{imax} = i-1imax\=i−1，并转到步骤 2。</p></li></ul></li></ol><p>当找到目标对象 iii 时，中位数为：</p><blockquote><p>max⁡(A[i−1],B[j−1]),\max(\text{A}[i-1], \text{B}[j-1]),max(A[i−1],B[j−1]), 当 m+nm + nm+n 为奇数时</p></blockquote><blockquote><p>max⁡(A[i−1],B[j−1])+min⁡(A[i],B[j])2,\frac{\max(\text{A}[i-1], \text{B}[j-1]) + \min(\text{A}[i], \text{B}[j])}{2},2max(A[i−1],B[j−1])+min(A[i],B[j]), 当 m+nm + nm+n 为偶数时</p></blockquote><p>现在，让我们来考虑这些临界值 i\=0,i\=m,j\=0,j\=ni=0,i=m,j=0,j=ni\=0,i\=m,j\=0,j\=n，此时 A[i−1],B[j−1],A[i],B[j]\text{A}[i-1],\text{B}[j-1],\text{A}[i],\text{B}[j]A[i−1],B[j−1],A[i],B[j] 可能不存在。<br>其实这种情况比你想象的要容易得多。</p><p>我们需要做的是确保 max(left_part)≤min(right_part)\text{max}(\text{left}\_\text{part}) \leq \text{min}(\text{right}\_\text{part})max(left_part)≤min(right_part)。 因此，如果 iii 和 jjj 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j]\text{A}[i-1], \text{B}[j-1],\text{A}[i],\text{B}[j]A[i−1],B[j−1],A[i],B[j] 全部存在）, 那么我们必须同时检查 B[j−1]≤A[i]\text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 以及 A[i−1]≤B[j]\text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j] 是否成立。<br>但是如果 A[i−1],B[j−1],A[i],B[j]\text{A}[i-1],\text{B}[j-1],\text{A}[i],\text{B}[j]A[i−1],B[j−1],A[i],B[j] 中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。<br>举个例子，如果 i\=0i = 0i\=0，那么 A[i−1]\text{A}[i-1]A[i−1] 不存在，我们就不需要检查 A[i−1]≤B[j]\text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j] 是否成立。<br>所以，我们需要做的是：</p><blockquote><p>在 [0，m][0，m][0，m] 中搜索并找到目标对象 iii，以使：</p><p>(j\=0(j = 0(j\=0 or i\=mi = mi\=m or B[j−1]≤A[i])\text{B}[j-1] \leq \text{A}[i])B[j−1]≤A[i]) 或是<br>(i\=0(i = 0(i\=0 or j\=nj = nj\=n or A[i−1]≤B[j]),\text{A}[i-1] \leq \text{B}[j]),A[i−1]≤B[j]), 其中 j\=m+n+12−ij = \frac{m + n + 1}{2} - ij\=2m+n+1−i</p></blockquote><p>在循环搜索中，我们只会遇到三种情况：</p><blockquote><ol><li>(j\=0(j = 0(j\=0 or i\=mi = mi\=m or B[j−1]≤A[i])\text{B}[j-1] \leq \text{A}[i])B[j−1]≤A[i]) 或是 (i\=0(i = 0(i\=0 or j\=nj = nj\=n or A[i−1]≤B[j])\text{A}[i-1] \leq \text{B}[j])A[i−1]≤B[j])，这意味着 iii 是完美的，我们可以停止搜索。</li><li>j>0j &gt; 0j>0 and i&lt;mi &lt; mi<m and="" b\[j−1\]\="">A[i]\text{B}[j - 1] &gt; \text{A}[i]B[j−1]>A[i] 这意味着 iii 太小，我们必须增大它。</m></li><li>i>0i &gt; 0i>0 and j&lt;nj &lt; nj<n and="" a\[i−1\]\="">B[j]\text{A}[i - 1] &gt; \text{B}[j]A[i−1]>B[j] 这意味着 iii 太大，我们必须减小它。</n></li></ol></blockquote><p>感谢 @Quentin.chen 指出：i&lt;m⟹j>0i &lt; m \implies j &gt; 0i&lt;m⟹j>0 以及 i>0⟹j<ni> 0 \implies j &lt; ni>0⟹j&lt;n 始终成立，这是因为：</ni></p><blockquote><p>m≤n,i&lt;m⟹j\=m+n+12−i>m+n+12−m≥2m+12−m≥0m \leq n,\ i &lt; m \implies j = \frac{m+n+1}{2} - i &gt; \frac{m+n+1}{2} - m \geq \frac{2m+1}{2} - m \geq 0 m≤n,i&lt;m⟹j\=2m+n+1−i>2m+n+1−m≥22m+1−m≥0</p><p>m≤n,i>0⟹j\=m+n+12−i&lt;m+n+12≤2n+12≤nm \leq n,\ i &gt; 0 \implies j = \frac{m+n+1}{2} - i &lt; \frac{m+n+1}{2} \leq \frac{2n+1}{2} \leq n m≤n,i>0⟹j\=2m+n+1−i&lt;2m+n+1≤22n+1≤n</p></blockquote><p>所以，在情况 2 和 3中，我们不需要检查 j>0j &gt; 0j>0 或是 j&lt;nj &lt; nj&lt;n 是否成立。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(log⁡(min(m,n)))O\big(\log\big(\text{min}(m,n)\big)\big)O(log(min(m,n)))，<br>首先，查找的区间是 [0,m][0, m][0,m]。<br>而该区间的长度在每次循环之后都会减少为原来的一半。<br>所以，我们只需要执行 log⁡(m)\log(m)log(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log⁡(m))O\big(\log(m)\big)O(log(m))。<br>由于 m≤nm \leq nm≤n，所以时间复杂度是 O(log⁡(min(m,n)))O\big(\log\big(\text{min}(m,n)\big)\big)O(log(min(m,n)))。</p></li><li><p>空间复杂度：O(1)O(1)O(1)，<br>我们只需要恒定的内存来存储 999 个局部变量， 所以空间复杂度为 O(1)O(1)O(1)。</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays_P</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>复杂度分析</p><p>时间复杂度：O\big(\log\big(\text{min}(m,n)\big)\big)O(log(min(m,n)))，<br>首先，查找的区间是 [0, m][0,m]。<br>而该区间的长度在每次循环之后都会减少为原来的一半。<br>所以，我们只需要执行 \log(m)log(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O\big(\log(m)\big)O(log(m))。<br>由于 m \leq nm≤n，所以时间复杂度是 O\big(\log\big(\text{min}(m,n)\big)\big)O(log(min(m,n)))。</p><p>空间复杂度：O(1)O(1)，<br>我们只需要恒定的内存来存储 99 个局部变量， 所以空间复杂度为 O(1)O(1)。</p><h2 id="leetcode-99-Solution"><a href="#leetcode-99-Solution" class="headerlink" title="leetcode 99% Solution"></a>leetcode 99% Solution</h2><p>执行用时 :3 ms, 在所有 java 提交中击败了99.23%的用户</p><p>内存消耗 :47 MB, 在所有 java 提交中击败了94.74%的用户</p><p><img src="/picture/lc04.png" alt="pic02.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://www.vazh.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数组" scheme="https://www.vazh.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode257-二叉树的所有路径</title>
    <link href="https://www.vazh.cn/2019/09/04/Leetcode275-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.vazh.cn/2019/09/04/Leetcode275-二叉树的所有路径/</id>
    <published>2019-09-04T01:48:42.000Z</published>
    <updated>2019-09-04T04:42:56.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>输入:</p><p>   1<br> /   \<br>2     3<br> \<br>  5</p><p>输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p><p>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li><strong>如果二叉树为空,返回空的list</strong></li><li>深度遍历二叉树,如果左右孩子节点为空　则为叶子节点　字符串拼接</li><li>s += root.val + “-&gt;”;　拼接每一次的值</li><li>如果左子树不为空　深度搜索</li><li>如果右子树不为空　深度搜索</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        dfs(root, list, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;String&gt; list, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(s + root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += root.val + <span class="string">"-&gt;"</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            dfs(root.left, list, s);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            dfs(root.right, list, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ol><li><strong>Time complexity : O(n).</strong></li><li><strong>Space complexity : O(1).</strong></li></ol><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.</p><p><strong>Memory Usage</strong>: 36.4 MB, less than 100.00% of Java online submissions for Binary Tree Paths.</p><p><img src="/picture/lc257.png" alt="lc275"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="DFS" scheme="https://www.vazh.cn/tags/DFS/"/>
    
      <category term="BST" scheme="https://www.vazh.cn/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器与内存分配策略-深入理解JVM</title>
    <link href="https://www.vazh.cn/2019/08/29/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    <id>https://www.vazh.cn/2019/08/29/垃圾收集器与内存分配策略-深入理解JVM/</id>
    <published>2019-08-29T11:56:03.000Z</published>
    <updated>2019-09-04T02:48:56.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​        最近在看周志明老师的《深入理解Java虚拟机》，准备留下一些学习笔记，供以后复习用。以下内容主要来自于《深入理解Java虚拟机》第三章–垃圾收集器与内存分配策略。</p></blockquote><h2 id="一-学习目标"><a href="#一-学习目标" class="headerlink" title="一 学习目标"></a>一 学习目标</h2><ol><li><p>对象存活判断算法</p></li><li><p>GC（garbage collection）算法学习</p></li><li><p>垃圾回收器</p></li><li><p>内存分配与回收策略</p></li></ol><p><strong>对于GC学习,我们主要考虑三个问题：哪些内存需要回收 -&gt; 什么时候回收 -&gt; 如何回收</strong></p><h2 id="二-那些内存需要回收"><a href="#二-那些内存需要回收" class="headerlink" title="二 那些内存需要回收"></a>二 那些内存需要回收</h2><p>  内存运行时，程序计数器、本地方法栈和虚拟机栈是随着线程的产生而产生，随着线程的消亡而消亡的，这几部分的内存分配和回收是确定好了的，随方法结束或线程结束时，内存就紧跟着回收了。而Java堆和方法区不一样。一个接口中多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在运行期间才知道会创建哪些对象，故内存回收与分配重点关注的是<strong>堆内存</strong>和<strong>方法区内存。</strong></p><h2 id="三-什么时候回收（判断对象的存活）"><a href="#三-什么时候回收（判断对象的存活）" class="headerlink" title="三.什么时候回收（判断对象的存活）"></a>三.什么时候回收（判断对象的存活）</h2><p><strong>对于方法区</strong>，永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p><strong>对于堆</strong>，其中存放的是对象实例，对于对象实例的回收，我们首先要判断哪些对象是“存活的”，对于那部分“死亡的”对象，就是我们要回收的。判断对象的存活有两种方法：</p><ul><li>引用计数算法</li><li>可达性分析算法</li></ul><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器, 每当有一个地方引用它时, 计数器值+1, 引用失效, -1, 为0的对象不能被使用。</p><ul><li>优势：实现简单，效率高。</li><li>缺点：无法解决对象相互引用的问题——会导致对象的引用虽然存在，但是已经不可能再被使用，却无法被回收。</li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链(Reference Chain), 当一个对象到GC Roots不可达(也就是不存在引用链)的时候, 证明对象是不可用的。如下图: <em>Object5、6、7</em> 虽然互有关联, 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。（注意：不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记）</p><p><img src="/picture/GC/gc01.webp" alt="img"></p><p>在Java, 可作为GC Roots的对象包括：</p><ul><li>方法区: 类静态属性引用的对象;</li><li>方法区: 常量引用的对象;</li><li>虚拟机栈(本地变量表)中引用的对象.</li><li>本地方法栈JNI(Native方法)中引用的对象。</li></ul><h2 id="四-如何回收-垃圾收集算法"><a href="#四-如何回收-垃圾收集算法" class="headerlink" title="四 如何回收-垃圾收集算法"></a>四 如何回收-垃圾收集算法</h2><h3 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1.标记清除算法"></a>1.标记清除算法</h3><p>  分为标记和清除两个阶段，先标记出需要回收的对象（可达性分析算法或者引用计数算法），在标记完成后统一回收所有被标记的对象。</p><p>  不足之处：效率问题，标记和清除效率都不高。空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</p><p><img src="/picture/GC/gc02.webp" alt="img"></p><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h3><p>  将可用内存划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还存活的复制到另一块上，然后将这一块一次性清除。商业虚拟机都是采用该方法来回收新生代，新生代98%都是朝生夕死的。将内存分为较大Eden和两个较小的survivor空间。每次使用其中一块Eden和survivor，回收时将存活的对象一次性地复制到另一块survivor中，再清理掉之前的。HotSpot虚拟机Eden与Survivor默认的大小比例为8:1:1。survivor空间不够时，需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。</p><p><img src="/picture/GC/gc03.webp" alt="img"></p><p>3.标记整理算法</p><p>  复制在对象存活率较高时效率很低。根据老年代的特点提出该算法。标记过程同标记清除一样，但不是直接对可回收对象进行清理，而是让存活对象朝着一端移动，然后直接清理掉端边界外的内存。</p><p><img src="/picture/GC/gc04.webp" alt="img"></p><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h3><p>  根据各年代特点分别采用最适当的GC算法。在新生代:中每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。在老年代: 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用<strong>“</strong>标记—清理<strong>”</strong>或<strong>“</strong>标记—整理<strong>”</strong>算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。即：</p><ul><li>新生代：存活率低，使用复制算法</li><li>老年代：存活率高，使用“标记-整理”或“标记-清除”算法</li></ul><h2 id="五-Hotspot算法实现及准确式GC"><a href="#五-Hotspot算法实现及准确式GC" class="headerlink" title="五 Hotspot算法实现及准确式GC"></a>五 Hotspot算法实现及准确式GC</h2><blockquote><p> 上面讲到了Java虚拟机是如何利用可达性算法判断对象是否需要回收的，由于在GC进行时，必须暂停所有的Java执行线程（Sun称之为“Stop The World”），所以，虚拟机必须尽量的优化GC过程的效率，减少暂停的时间。那么对于GC Roots，HotSpot是如何快速确定的呢？</p></blockquote><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>首先，我们需要知道在JVM中，对象是如何被创建的。</p><p>而对象的创建通常是通过new一个对象而已，当虚拟机接收到一个new指令时，它会做如下的操作:</p><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1 判断对象对应的类是否加载、链接、初始化"></a>1 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机接收到一条new指令时，首先会去检查这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被类加载器加载、链接和初始化过。如果没有则先执行相应的类加载过程。关于类加载器我们在前一篇文章中已经提到过，这里不再赘述。</p><h4 id="2为对象分配内存"><a href="#2为对象分配内存" class="headerlink" title="2为对象分配内存"></a>2为对象分配内存</h4><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p><p>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</p><p>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</p><h4 id="3处理并发安全问题"><a href="#3处理并发安全问题" class="headerlink" title="3处理并发安全问题"></a>3处理并发安全问题</h4><p>创建对象是一个非常频繁的操作，所以需要解决并发的问题，有两种方式：</p><p>对分配内存空间的动作进行同步处理，比如在虚拟机采用CAS算法并配上失败重试的方式保证更新操作的原子性。</p><p>每个线程在Java堆中预先分配一小块内存，这块内存称为本地线程分配缓冲（Thread Local Allocation Buffer）简写为TLAB，线程需要分配内存时，就在对应线程的TLAB上分配内存，当线程中的TLAB用完并且被分配到了新的TLAB时，这时候才需要同步锁定。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</p><h4 id="4初始化分配到的内存空间"><a href="#4初始化分配到的内存空间" class="headerlink" title="4初始化分配到的内存空间"></a>4初始化分配到的内存空间</h4><p>将分配到的内存，除了对象头都初始化为零值。</p><h4 id="5设置对象的对象头"><a href="#5设置对象的对象头" class="headerlink" title="5设置对象的对象头"></a>5设置对象的对象头</h4><p>将对象的所属类、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中。</p><h4 id="6执行init方法进行初始化"><a href="#6执行init方法进行初始化" class="headerlink" title="6执行init方法进行初始化"></a>6执行init方法进行初始化</h4><p>执行init方法，初始化对象的成员变量、调用类的构造方法，这样一个对象就被创建了出来。</p><p>对象的堆内存布局<br>在HotSpot虚拟机中，对象在堆内存的布局分为三个区域，分别是对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p><p>对象头：对象头包括两部分信息分别是Mark World和元数据指针，Mark World用于存储对象运行时的数据，比如HashCode、锁状态标志、GC分代年龄等。而元数据指针用于指向方法区的中目标类的类型信息，通过元数据指针可以确定对象的具体类型。</p><p>实例数据：用于存储对象中的各种类型的字段信息（包括从父类继承来的）。</p><p>对齐填充：对齐填充不一定存在，起到了占位符的作用，没有特别的含义。</p><p>对象分配如下图所示：</p><p><img src="/picture/GC/gc10.png" alt=""></p><h3 id="HotSpot的对象模型"><a href="#HotSpot的对象模型" class="headerlink" title="HotSpot的对象模型"></a>HotSpot的对象模型</h3><p>HotSpot中采用了OOP-Klass模型，它是用来描述Java对象实例的一种模型，OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p><p>HotSpot中，用instanceOopDesc 和 arrayOopDesc 来描述对象头，其中arrayOopDesc对象用于描述数组类型。</p><p>通过OOP-Klass模型，我们就知道了Java虚拟机是如何通过栈帧中的对象引用找到对应的对象实例，如下图所示：</p><p><img src="/picture/GC/gc11.png" alt=""></p><p>从图中可以看出，通过栈帧中的对象引用找到Java堆中的instanceOopDesc对象，再通过instanceOopDesc中的元数据指针来找到方法区中的instanceKlass，从而确定该对象的具体类型。</p><h3 id="HotSpot的准确式GC"><a href="#HotSpot的准确式GC" class="headerlink" title="HotSpot的准确式GC"></a>HotSpot的准确式GC</h3><p>HotSpot采用了准确式GC以提升GC roots的枚举速度。所谓准确式GC，就是让JVM知道内存中某位置数据的类型什么。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。</p><p>HotSpot是利用OopMap来实现准确式GC的。当类加载完成后，HotSpot 就将对象内存布局之中什么偏移量上数值是一个什么样的类型的数据这些信息存放到 OopMap 中；在 HotSpot 的 JIT 编译过程中，同样会插入相关指令来标明哪些位置存放的是对象引用等，这样在 GC 发生时，HotSpot 就可以直接扫描 OopMap 来获取对象引用的存储位置，从而进行 GC Roots 枚举。</p><h3 id="HotSpot安全点"><a href="#HotSpot安全点" class="headerlink" title="HotSpot安全点"></a>HotSpot安全点</h3><p>通过OopMap，HotSpot可以很快完成GC Roots的查找，但是，如果在每一行代码都有可能发生GC，那么也就意味着得为每一行代码的指令都生成OopMap，这样将占用大量的空间。实际上，HotSpot也不会这么做。</p><p>HotSpot只在特定的位置记录了OopMap，这些位置就叫做安全点（Safepoint），也就是说，程序并不能在任意地方都可以停下来进行GC，只有到达安全点时才能暂停进行GC。</p><p>在安全点中，HotSpot也会开始记录虚拟机的相关信息，如OopMap信息的录入。安全点的选择不能太少，否则GC等待时间太长；也不能太多，否则会增大运行负荷，其选择的原则为“是否具有让程序长时间执行的特征”，如方法调用，循环等等。具体安全点有下面几个：</p><p>(1) 循环的末尾 (防止大循环的时候一直不进入Safepoint，而其他线程在等待它进入Safepoint)<br>(2) 方法返回前<br>(3) 调用方法的call之后<br>(4) 抛出异常的位置</p><p>而安全点暂停线程运行的手段有两种：抢先式中断和主动式中断。</p><h3 id="抢先式中断"><a href="#抢先式中断" class="headerlink" title="抢先式中断"></a>抢先式中断</h3><p>不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上再暂停。不过现在的虚拟机几乎没有采用此算法的。</p><h3 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h3><p>GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时去主动轮询查询此标志，发现中断标志为真时就中断自己挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><h3 id="HotSpot安全区域"><a href="#HotSpot安全区域" class="headerlink" title="HotSpot安全区域"></a>HotSpot安全区域</h3><p>产生原因<br>安全点机制保证了程序执行时进入GC的问题。但是对于非执行态下，如线程Sleep或者Block下，由于此时程序（线程）无法响应JVM的中断请求，JVM也不太可能一直等待线程重新获取时间片，此时就需要安全区域(Safe Region)了。安全区域是指在一段代码片段内，引用关系不会发生变化，在这段区域内，任意地方开始GC都是安全的。</p><p>运行机理<br>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了；当线程要离开Safe Region时，如果整个GC完成，那线程可继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止。</p><h2 id="六-七种垃圾收集器"><a href="#六-七种垃圾收集器" class="headerlink" title="六 七种垃圾收集器"></a>六 七种垃圾收集器</h2><p>重点笔记：</p><ul><li>并行（Parallel）：多条垃圾收集线程</li><li>并发（Concurrent）：用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户线程在继续运行，而垃圾收集程序运行于另外一个CPU上。</li><li>新生代：Serial收集器　　ParNew收集器　　Parallel Scavenge收集器</li><li>老年代：Serial Old收集器　　Parallel Old收集器　　CMS收集器</li></ul><p><img src="/picture/GC/gc05.webp" alt=""></p><h3 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h3><h4 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h4><p>  最悠久，最基本的收集器；<strong>单线程</strong>收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，且在收集时，必须暂停其他所有的工作线程，直到收集结束。<strong>新生代采取复制算法</strong>。老年代采取标记整理算法。在进行垃圾收集时必须暂停其他所有的工作线程，即“Stop The World”。依然是虚拟机运行在Client模式下的默认新生代收集器。Serial一般在单核的机器上使用，是Java 5非服务端JVM的默认收集器。</p><blockquote><ol><li>新生代：单线程复制收集算法；</li><li>老年代：单线程标记整理算法。</li><li>参数-XX:UseSerialGC设置使用</li></ol><p>优势：对于单CPU环境来说，Serial收集器没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集。Serial收集器对于在Client模式下的虚拟机是一个很好的选择。 </p></blockquote><p><img src="/picture/GC/gc06.webp" alt=""></p><h4 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h4><p>  Serial收集器的多线程版。<strong>多条线程</strong>进行垃圾收集，采用<strong>复制算法</strong>。其余和Serial收集器一样。目前唯一能与CMS收集器配合工作。ParNew收集器在单CPU环境中不比Serial效果好，甚至可能更差，两个CPU也不一定跑的过，但随着CPU数量的增加，性能会逐步增加。默认开启的收集线程数与CPU数量相同。在CPU数量很多的情况下，可以使用-XX:ParallelGCThreads参数来限制线程数。</p><blockquote><ol><li>新生代并行，老年代串行</li><li>新生代复制算法、老年代标记-整理</li><li>参数控制：<br>-XX:+UseConcMarkSweepGC”：指定使用CMS后，会默认使用ParNew作为新生代收集器；<br>-XX:+UseParNewGC”：强制指定使用ParNew；<br>-XX:ParallelGCThreads”：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</li></ol><p>优势：ParNew收集器是许多运行在server模式下的虚拟机中首选的新生代收集器，一个重要的原因是，只有ParNew和Serial收集器能和CMS收集器共同工作。无法与JDK1.4中存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew和Serial。</p></blockquote><p><img src="/picture/GC/gc07.webp" alt=""></p><h4 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h4><p>  新生代收集器，<strong>多线程并行</strong>、使用<strong>复制算法</strong>。</p><p>  CMS的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而PS收集器的目的则是达到一个可控制的吞吐量。吞吐量即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间））。</p><blockquote><p>使用-XX:MaxGCPauseMillus参数控制垃圾停顿时间</p><p>使用-XX:GCTimeRatio参数控制吞吐量。</p><p>Parallel Scavenge收集器设置-XX:UseAdaptiveSizePolicy参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量（GC自使用的调节策略）。<br>自适应调节策略也是Parallel Scavenge收集器和ParNew收集器一个重要的区别。</p></blockquote><p><img src="/picture/GC/gc08.webp" alt=""></p><h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><h4 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h4><p>  Serial Old同样是<strong>单线程</strong>收集器,使用“<strong>标记-整理</strong>”算法。可以与JDK1.5及之前的Parallel Scavenge搭配使用；也可以作为CMS收集器的后备预案，在并发收集发生Concureent Mode Failure时使用。</p><h4 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h4><p>  Parallel Old收集器是<strong>多线程</strong>，使用“<strong>标记-整理</strong>”算法。</p><p>  JDK1.6前，Parallel Scavenge只能与老年代收集器Serial Old（PS MarkSweep）组合，由于Serial Old无法充分利用服务器多CPU的处理能力，会拖累整体性能。</p><p>  JDK1.6后，Parallel Scavenge可与Parallel Old组合，达到名副其实的“吞吐量优先”，在注重吞吐量以及CPU资源敏感的场合可以优先考虑这个组合。</p><h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h4><p>  基于“<strong>标记—清除</strong>”算法，低停顿，<strong>并发收集</strong>。以获取最短回收停顿时间、低延迟为目标，适用于重视服务响应速度的应用。</p><p>主要过程为一下四步：</p><ul><li>初始标记；Stop the World，仅标记GCRoots能关联的对象，速度很快。</li><li>并发标记；进行GCRootsTracing的过程。</li><li>重新标记；修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比1长但远比2短。</li><li>并发清除；并发清除与并发标记耗时最长。收集器线程都可以与用户线程一起工作。并发清理以后重置线程。</li></ul><p><strong>CMS收集器的内存回收过程是与用户线程一起并发执行的</strong></p><p><strong>主要缺点：</strong></p><ul><li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是因为占用了一部分CPU资源而导致应用程序变慢，总吞吐量就会降低。CMS默认启动的回收线程数为(CPU数量+3)/4。当CPU的个数少于2个的时候，CMS对用户程序的影响可能会变得很大。</li><li>CMS收集器<strong>无法处理浮动垃圾（floating garbage）</strong>，可能会出现concurrent mode failure导致另一次full gc的产生。在CMS的并发清理阶段，由于程序还在运行，垃圾还会不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留到下一次GC再处理。这种垃圾称为浮动垃圾。同样由于CMS GC阶段用户线程还需要运行，即还需要预留足够的内存空间供用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被灌满了再进行收集而需要预留一部分空间提供并发收集时的程序运作使用。<strong>默认设置下 CMS收集器在老年代使用了68%的空间后就会被激活</strong>。这个值可以用-XX:CMSInitiatingOccupancyFraction来设置。要是CMS运行期间预留的内存无法满足程序需要，就会出现concurrent mode failure，这时候就会启用Serial Old收集器作为备用进行老年代的垃圾收集。</li><li>空间碎片过多（标记-清除算法的弊端），CMS是基于标记-清除算法来实现的回收器，提供-XX:+UseCMSCompactAtFullCollection参数，应用于在FULL GC后再进行一个碎片整理过程。-XX:CMSFullGCsBeforeCompaction,多少次不压缩的full gc后来一次带压缩的。</li></ul><p><img src="/picture/GC/gc09.webp" alt=""></p><h3 id="整堆收集器"><a href="#整堆收集器" class="headerlink" title="整堆收集器"></a>整堆收集器</h3><h4 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h4><p> G1收集器（Garbage-First）：是当今收集器技术发展的最前沿的成果之一，G1是一款面向服务器端应用的垃圾收集器。 使用G1收集器时，java堆的内存布局就与其他收集器有很大差别，它将真个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代与老年代的概念，但新生代与老年代不再试物理隔离的了，他们都是一部分Region（不需要连续）的集合。G1具备如下特点：</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能够独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记–整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这个特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前出发下一次GC。</li><li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时java（RTSJ）的垃圾收集器的特性了。</li><li>初始标记（Initial Marking）：标记GC Roots能够直接关联到的对象，并且修改TAMS的值，能在正确可用的Region中创建对象，这阶段需要停顿线程，而且耗时很短。<br>并发标记（Concurrent Marking）：从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这个时间耗时比较长，但可与用户程序并行执行。</li><li>最终标记（Final Marking）：为了修正和正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分没有标记记录，虚拟机将这一段对象变法记录在线程Rememberred Set logs里面，最终标记阶段需要把Remembered Set logs 的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并发执行。</li><li>筛选回收（Live Data Counting and Evacuation）：对各个Region的回收截止和成本进行排序，根据用户期望的GC停顿时间来制定回收计划，这阶段可以做到和用户程序一起并发执行，但是因为值回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高手机效率。</li></ul><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>重点笔记：</p><ul><li>新生代GC（Minor GC）：发生在新生代的垃圾收集动作，非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作，一般会伴随Minor GC 速度一般比Minor GC慢上10倍以上。</li></ul><ol><li><p>优先在Eden区分配（如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）如果Eden区满，则触发一次Minor GC</p></li><li><p>大对象直接进入老年代；大对象，即大量连续内存空间的Java对象，最典型的是那种很长的字符串及数组。</p></li><li><p>长期存活的对象将进入老年代；设置对象年龄计数器。对象在Eden出生并经过第一次MinorGC后仍存活，年龄+1，移入Survivor区。以后每经过一次MinorGC年龄加一，当达到15时（默认的）就进入老年代</p></li><li><p>动态对象年龄判定，并不是对象年龄必须达到最大阈值才会进入老年代。如果survivor空间中相同年龄所有对象大小总和大于其空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到阈值时才进入。</p></li><li><p>空间分配担保；发生minorGC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立，MinorGC可以确保是安全的。不成立，则检查HandlePromotionFailure设置值是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。大于将尝试MinorGC，小于或者不允许冒险，也要进行一次FullGC。老年代分配担保，将survivor无法容纳的对象直接进入老年代。依然担保失败，则只好在失败后重新发起一次Full GC。</p></li></ol><p>参考链接：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://blog.csdn.net/u013667756/article/details/82948012</span></span><br><span class="line"><span class="attribute">https://www.jianshu.com/p/9d09f93001e4</span></span><br><span class="line"><span class="attribute">https://blog.csdn.net/u012998254/article/details/81635902</span></span><br><span class="line"><span class="attribute">https://blog.csdn.net/u012998254/article/details/81635902</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;​        最近在看周志明老师的《深入理解Java虚拟机》，准备留下一些学习笔记，供以后复习用。以下内容主要来自于《深入理解Java虚拟机》第三章–垃圾收集器与内存分配策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-学习目标&quot;
      
    
    </summary>
    
      <category term="深入理解JVM" scheme="https://www.vazh.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
      <category term="JVM" scheme="https://www.vazh.cn/tags/JVM/"/>
    
      <category term="GC" scheme="https://www.vazh.cn/tags/GC/"/>
    
      <category term="内存分配策略" scheme="https://www.vazh.cn/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件权限与目录配置</title>
    <link href="https://www.vazh.cn/2019/08/29/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.vazh.cn/2019/08/29/Linux的文件权限与目录配置/</id>
    <published>2019-08-29T01:14:41.000Z</published>
    <updated>2019-09-04T04:33:34.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Linux-文件属性"><a href="#一、Linux-文件属性" class="headerlink" title="一、Linux 文件属性"></a>一、Linux 文件属性</h2><h3 id="1-1、用户和组"><a href="#1-1、用户和组" class="headerlink" title="1.1、用户和组"></a>1.1、用户和组</h3><p>Linux 系统中的目录和文件的访问身份分为 user，group， others 分别简写为 u， g ， o 。</p><ul><li>user：文件的所有者</li><li>group：文件所有者所在组</li><li>others ：不在所有者的所在组的其他用户</li><li>all：代表所有用户， 简写为 a</li></ul><p>每个身份对文件的权限又分为 : <strong>read ， write ， execute</strong>， 分别简写为 : <strong>r，w ，x</strong>， 数字表示分别为 : <strong>4， 2， 1</strong>。</p><p><img src="/picture/linux/linux01.webp" alt=""></p><h3 id="1-2、文件详细信息"><a href="#1-2、文件详细信息" class="headerlink" title="1.2、文件详细信息"></a>1.2、文件详细信息</h3><p>Linux 文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。</p><p>ls -al 查看文件详细信息：</p><blockquote><p>drwxr-xr-x  5 root root 4096 Apr 23 14:49 .<br> drwxr-xr-x 18 root root 4096 Apr 28 16:36 ..<br> drwxr-xr-x  4 root root 4096 Apr 23 14:49 master<br> drwxr-xr-x  3 root root 4096 Apr 23 14:49 spark1<br> drwxr-xr-x  3 root root 4096 Apr 23 14:49 spark2</p></blockquote><h4 id="1-2-1、第一栏：类型与权限"><a href="#1-2-1、第一栏：类型与权限" class="headerlink" title="1.2.1、第一栏：类型与权限"></a>1.2.1、第一栏：类型与权限</h4><p><img src="/picture/linux/linux02.webp" alt=""></p><p>第一个字符代表这个文件的类型(如目录、文件或链接文件等等)：</p><ul><li>当为[ d ]则是目录</li><li>当为[ - ]则是文件</li><li>若是[ l ]则表示为链接文件(link file)</li><li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)</li><li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合：</p><ul><li>[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute) ，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</li><li>第一组为『文件拥有者的权限，第二组为『同群组的权限』，第三组为『其他非本群组的权限』。</li></ul><h4 id="1-2-2、第二栏：多少档名连结到此节点-i-node"><a href="#1-2-2、第二栏：多少档名连结到此节点-i-node" class="headerlink" title="1.2.2、第二栏：多少档名连结到此节点(i-node)"></a>1.2.2、第二栏：多少档名连结到此节点(i-node)</h4><p>每个文件都会将他的权限与属性记录到文件系统的 i-node 中，不过，我们使用的目录树却是使用文件名来记录， 因此每个文件名就会链接到一个 i-node。这个属性记录的，就是有多少不同的文件名链接到相同的一个 i-node 号码。</p><h4 id="1-2-3、第三栏：文件-或目录-的拥有者"><a href="#1-2-3、第三栏：文件-或目录-的拥有者" class="headerlink" title="1.2.3、第三栏：文件(或目录)的拥有者"></a>1.2.3、第三栏：文件(或目录)的拥有者</h4><h4 id="1-2-4、第四栏：文件的所属群组"><a href="#1-2-4、第四栏：文件的所属群组" class="headerlink" title="1.2.4、第四栏：文件的所属群组"></a>1.2.4、第四栏：文件的所属群组</h4><h4 id="1-2-5、第五栏：文件的容量大小-默认单位为-bytes"><a href="#1-2-5、第五栏：文件的容量大小-默认单位为-bytes" class="headerlink" title="1.2.5、第五栏：文件的容量大小(默认单位为 bytes )"></a>1.2.5、第五栏：文件的容量大小(默认单位为 bytes )</h4><h4 id="1-2-6、第六栏：文件的建档日期或者是最近的修改日期"><a href="#1-2-6、第六栏：文件的建档日期或者是最近的修改日期" class="headerlink" title="1.2.6、第六栏：文件的建档日期或者是最近的修改日期"></a>1.2.6、第六栏：文件的建档日期或者是最近的修改日期</h4><h4 id="1-2-7、第七栏：文件的全路径及其文件名"><a href="#1-2-7、第七栏：文件的全路径及其文件名" class="headerlink" title="1.2.7、第七栏：文件的全路径及其文件名"></a>1.2.7、第七栏：文件的全路径及其文件名</h4><p>这个字段就是档名。 比较特殊的是：如果档名之前多一个“.” ，则代表这个文件为隐藏档。</p><h2 id="二、修改文件属性和权限"><a href="#二、修改文件属性和权限" class="headerlink" title="二、修改文件属性和权限"></a>二、修改文件属性和权限</h2><h3 id="2-1、chgrp-：改变文件所属群组"><a href="#2-1、chgrp-：改变文件所属群组" class="headerlink" title="2.1、chgrp ：改变文件所属群组"></a>2.1、chgrp ：改变文件所属群组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] dirname/filename ...</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录</span><br><span class="line">都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。</span><br><span class="line"></span><br><span class="line">范例：</span><br><span class="line">chgrp users initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><h3 id="2-2、chown-：改变文件拥有者"><a href="#2-2、chown-：改变文件拥有者" class="headerlink" title="2.2、chown ：改变文件拥有者"></a>2.2、chown ：改变文件拥有者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 帐号名称 文件或目录</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都变更</span><br><span class="line"></span><br><span class="line">范例：将 initial-setup-ks.cfg 的拥有者改为bin这个帐号：</span><br><span class="line">chown bin initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><h3 id="2-3、chmod-：改变文件的权限"><a href="#2-3、chmod-：改变文件的权限" class="headerlink" title="2.3、chmod ：改变文件的权限"></a>2.3、chmod ：改变文件的权限</h3><p>权限的设置方法有两种， 分别可以使用数字或者是符号来进行权限的变更。</p><h4 id="2-3-1、数字类型改变文件权限"><a href="#2-3-1、数字类型改变文件权限" class="headerlink" title="2.3.1、数字类型改变文件权限"></a>2.3.1、数字类型改变文件权限</h4><p>Linux文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己的<br> read/write/execute 权限。</p><p>各权限的分数对照表如下：</p><blockquote><p>r:4 &gt; w:2 &gt; x:1</p></blockquote><p>每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><blockquote><p>owner = rwx = 4+2+1 = 7 &gt; group = rwx = 4+2+1 = 7 &gt; others= — = 0+0+0 = 0</p></blockquote><p>变更权限的指令 chmo的语法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都会变更</span><br></pre></td></tr></table></figure><h4 id="2-3-2、符号类型改变文件权限"><a href="#2-3-2、符号类型改变文件权限" class="headerlink" title="2.3.2、符号类型改变文件权限"></a>2.3.2、符号类型改变文件权限</h4><p>基本上就九个权限分别是（1）user （2）group （3）others 三种身份。那么就可以借由 u， g， o 来代表三种身份的权限！此外， a 则代表 all 亦即全部的身份！</p><p>可以使用下面的方式来看：</p><blockquote><p>| chmod | u g o a | +（加入） -（除去） =（设置） | r w x | 文件或目录 |</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,go=rx .bashrc</span><br><span class="line"></span><br><span class="line">那个 u=rwx,go=rx 是连在一起的，中间并没有任何空白字符！</span><br></pre></td></tr></table></figure><p>如果是要将权限去掉而不更动其他已存在的权限，例如要拿掉全部人的可执行权<br> 限，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a-x .bashrc</span><br></pre></td></tr></table></figure><h4 id="2-3-3-目录与文件的权限意义"><a href="#2-3-3-目录与文件的权限意义" class="headerlink" title="2.3.3 目录与文件的权限意义"></a>2.3.3 目录与文件的权限意义</h4><blockquote><p>能不能进入某一个目录，只与该目录的x权限有关。如果在某目录的下不具有x权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何命令，即使你具有该目录下的r权限。但是不能随便给w权限。</p></blockquote><h2 id="三、Linux-文件种类与扩展名"><a href="#三、Linux-文件种类与扩展名" class="headerlink" title="三、Linux 文件种类与扩展名"></a>三、Linux 文件种类与扩展名</h2><h3 id="3-1、文件种类"><a href="#3-1、文件种类" class="headerlink" title="3.1、文件种类"></a>3.1、文件种类</h3><h4 id="3-1-1、正规文件（regular-file-）"><a href="#3-1-1、正规文件（regular-file-）" class="headerlink" title="3.1.1、正规文件（regular file ）"></a>3.1.1、正规文件（regular file ）</h4><p>ls -al 所显示出来的属性方面，第一个字符为 [ - ]。</p><p>可以分为：</p><ul><li>纯文本文件（ASCII）：这是 Linux 系统中最多的一种文件类型， 称为纯文本文件，内容为我们人类可以直接读到的数据，例如数字、字母等等。</li><li>二进制档（binary）：Linux当中的可执行文件。</li><li>数据格式文件（data）：有些程序在运行的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 （data file）。举例来说，Linux 在使用者登陆时，都会将登录的数据记录在 /var/log/wtmp 那个文件内，该文件是一个 data file，他能够通过 last 这个指令读出来！ 但是使用cat时，会读出乱码。</li></ul><h4 id="3-1-2、目录（directory）"><a href="#3-1-2、目录（directory）" class="headerlink" title="3.1.2、目录（directory）"></a>3.1.2、目录（directory）</h4><p>目录，第一个属性为 [ d ]。</p><h4 id="3-1-3、链接文件（link）"><a href="#3-1-3、链接文件（link）" class="headerlink" title="3.1.3、链接文件（link）"></a>3.1.3、链接文件（link）</h4><p>第一个属性为 [ l ]。</p><p>就是类似 Windows 系统下面的快捷方式！</p><h4 id="3-1-4、设备与设备文件（device）"><a href="#3-1-4、设备与设备文件（device）" class="headerlink" title="3.1.4、设备与设备文件（device）"></a>3.1.4、设备与设备文件（device）</h4><p>与系统周边及储存等相关的一些文件， 通常都集中在 /dev 这个目录之下！通常又分为两种：</p><ul><li>区块（block）设备文件 ：就是一些储存数据， 以提供系统随机存取的周边设备，举例来说，硬盘与软盘等就是。第一个属性为[ b ]。</li><li>字符（character）设备文件：亦即是一些序列埠的周边设备， 例如键盘、鼠标等等！这些设备的特色就是“一次性读取”的，不能够截断输出。 第一个属性为 [ c ]。</li></ul><h4 id="3-1-5、数据接口文件（sockets）"><a href="#3-1-5、数据接口文件（sockets）" class="headerlink" title="3.1.5、数据接口文件（sockets）"></a>3.1.5、数据接口文件（sockets）</h4><p>第一个属性为 [ s ]。</p><p>这种类型的文件通常被用在网络上的数据承接。可以启动一个程序来监听用户端的要求， 而用户端就可以通过这个 socket 来进行数据的沟通了。 最常在 /run 或 /tmp 这些个目录中看到这种文件类型了。</p><h4 id="3-1-6、数据输送档（FIFO-pipe）"><a href="#3-1-6、数据输送档（FIFO-pipe）" class="headerlink" title="3.1.6、数据输送档（FIFO, pipe）"></a>3.1.6、数据输送档（FIFO, pipe）</h4><p>第一个属性为[p]</p><p>FIFO也是一种特殊的文件类型，主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO 是 first-in-first-out 的缩写。</p><h2 id="四、Linux-目录配置"><a href="#四、Linux-目录配置" class="headerlink" title="四、Linux 目录配置"></a>四、Linux 目录配置</h2><p>根据 FHS（Filesystem Hierarchy Standard ）的标准文件指出每个特定的目录下应该要放置什么样子的数据。</p><p>FHS 依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态：</p><ul><li>可分享的：可以分享给其他系统挂载使用的目录，所以包括可执行文件与使用者的邮件等数据， 是能够分享给网络上其他主机挂载用的目录。</li><li>不可分享的：自己机器上面运行的设备文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</li><li>不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函数库、文件说明文档、系统管理员所管理的主机服务配置文件等等。</li><li>可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻群组等。</li></ul><p>事实上，FHS 针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义：</p><ul><li>/ （root, 根目录）：与开机系统有关</li><li>/usr （unix software resource）：与软件安装/执行有关</li><li>/var （variable）：与系统运行过程有关</li></ul><h3 id="4-1、根目录-（-）-的意义与内容"><a href="#4-1、根目录-（-）-的意义与内容" class="headerlink" title="4.1、根目录 （/） 的意义与内容"></a>4.1、根目录 （/） 的意义与内容</h3><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函数库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区内， 因为越大的分区你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。</p><p>FHS 标准建议：根目录（/）所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但性能较佳，根目录所在的文件系统也较不容易发生问题。</p><p>鉴于上述的说明，因此 FHS 定义出根目录(/)底下应该要有底下这些次目录的存在才好：</p><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>/bin</td><td>系统有很多放置执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</td></tr><tr><td>/boot</td><td>这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机选单与开机所需配置文件等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub这个开机管理程序， 则还会存在/boot/grub/这个目录喔！</td></tr><tr><td>/dev</td><td>在Linux系统上，任何装置与接口设备都是以文件的型态存在于这个目录当中的。 你只要透过存取这个目录底下的某个文件，就等于存取某个装置啰～ 比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/lp<em>, /dev/hd</em>, /dev/sd*等等</td></tr><tr><td>/etc</td><td>系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中喔。比较重要的文件有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等。另外，其下重要的目录有： /etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话：『 /etc/init.d/iptables start』、『/etc/init.d/iptables stop』 /etc/xinetd.d/：这就是所谓的super daemon管理的各项服务的配置文件目录。 /etc/X11/：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。</td></tr><tr><td>/home</td><td>这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时， 默认的用户家目录都会规范到这里来。比较重要的是，家目录有两种代号喔： ~：代表目前这个用户的家目录，而  ~dmtsai ：则代表 dmtsai 的家目录！</td></tr><tr><td>/lib</td><td>系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库， 以及在/bin或/sbin底下的指令会呼叫的函式库而已。 什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。 尤其重要的是/lib/modules/这个目录， 因为该目录会放置核心相关的模块(驱动程序)喔！</td></tr><tr><td>/media</td><td>media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软盘、光盘、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。</td></tr><tr><td>/mnt</td><td>如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</td></tr><tr><td>/opt</td><td>这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软件(非原本的distribution提供的)，那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！</td></tr><tr><td>/root</td><td>系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。</td></tr><tr><td>/sbin</td><td>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</td></tr><tr><td>/srv</td><td>srv可以视为『service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。</td></tr><tr><td>/tmp</td><td>这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</td></tr></tbody></table><p>底下是几个在 Linux 当中也是非常重要的目录：</p><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>/lost+found</td><td>这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在， 例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』</td></tr><tr><td>/proc</td><td>这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中， 例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。</td></tr><tr><td>/sys</td><td>这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量喔！</td></tr></tbody></table><p>根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分割槽则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分割槽去！那哪些目录不可与根目录分开呢？有底下这些：</p><ul><li>/etc：配置文件</li><li>/bin：重要执行档</li><li>/dev：所需要的装置文件</li><li>/lib：执行档所需的函式库与核心所需的模块</li><li>/sbin：重要的系统执行文件</li></ul><p>这五个目录千万不可与根目录分开在不同的分割槽！</p><h3 id="4-2、-usr-的意义与内容"><a href="#4-2、-usr-的意义与内容" class="headerlink" title="4.2、/usr 的意义与内容"></a>4.2、/usr 的意义与内容</h3><p>/usr 里面放置的数据属于可分享的与不可变动的(shareable, static)，/usr 可以分享给区域网络内的其他主机来使用。</p><p>usr 是 Unix Software Resource 的缩写， 也就是『Unix操作系统软件资源』。</p><p>FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p><p>因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似 Windows 系统的『C:\Windows\ + C:\Program files\』这两个目录的综合体。</p><p>/usr的次目录建议有底下这些：</p><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>/usr/X11R6/</td><td>为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。</td></tr><tr><td>/usr/bin/</td><td>绝大部分的用户可使用指令都放在这里！请注意到他与/bin的不同之处。(是否与开机过程有关)</td></tr><tr><td>/usr/include/</td><td>c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档喔！</td></tr><tr><td>/usr/lib/</td><td>包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生喔！</td></tr><tr><td>/usr/local/</td><td>系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！</td></tr><tr><td>/usr/sbin/</td><td>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)啰！</td></tr><tr><td>/usr/share/</td><td>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛！在此目录下常见的还有这些次目录： /usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件</td></tr><tr><td>/usr/src/</td><td>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</td></tr></tbody></table><h3 id="4-3、-var-的意义与内容"><a href="#4-3、-var-的意义与内容" class="headerlink" title="4.3、/var 的意义与内容"></a>4.3、/var 的意义与内容</h3><p>/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：</p><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>/var/cache/</td><td>应用程序本身运作过程中会产生的一些暂存档；</td></tr><tr><td>/var/lib/</td><td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！</td></tr><tr><td>/var/lock/</td><td>某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。</td></tr><tr><td>/var/log/</td><td>重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。</td></tr><tr><td>/var/mail/</td><td>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！</td></tr><tr><td>/var/run/</td><td>某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！ 至于PID的意义我们会在后续章节提到的。</td></tr><tr><td>/var/spool/</td><td>这个目录通常放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中！</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Linux-文件属性&quot;&gt;&lt;a href=&quot;#一、Linux-文件属性&quot; class=&quot;headerlink&quot; title=&quot;一、Linux 文件属性&quot;&gt;&lt;/a&gt;一、Linux 文件属性&lt;/h2&gt;&lt;h3 id=&quot;1-1、用户和组&quot;&gt;&lt;a href=&quot;#1-1、用
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.vazh.cn/categories/Linux/"/>
    
    
      <category term="linux文件权限" scheme="https://www.vazh.cn/tags/linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之ReentrantLock</title>
    <link href="https://www.vazh.cn/2019/07/16/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BReentrantLock/"/>
    <id>https://www.vazh.cn/2019/07/16/JDK源码阅读之ReentrantLock/</id>
    <published>2019-07-16T07:31:45.000Z</published>
    <updated>2019-09-04T02:50:48.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p><strong>ReentrantLock</strong>是一个<strong>可重入的互斥锁</strong>，也被称为<strong>“独占锁”</strong>。在上一篇讲解AQS的时候已经提到，“独占锁”在同一个时间点只能被一个线程持有；而可重入的意思是，ReentrantLock可以被单个线程多次获取。<br> ReentrantLock又分为<strong>“公平锁(fair lock)”和“非公平锁(non-fair lock)”</strong>。它们的区别体现在获取锁的机制上：在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”机制下，如果锁是可获取状态，不管自己是不是在队列的head节点都会去尝试获取锁。reentrantLock默认是非公平锁</p></blockquote><h2 id="数据结构与核心参数"><a href="#数据结构与核心参数" class="headerlink" title="数据结构与核心参数"></a>数据结构与核心参数</h2><p><img src="/picture/Reen01.png" alt="01"></p><blockquote><p>​                                        ReetrantLock继承关系</p></blockquote><p>可以看到ReetrantLock继承自AQS，并实现了Lock接口。<code>Lock</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁，如果锁不可用则线程一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取锁，响应中断，如果锁不可用则线程一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//获取锁，获取失败直接返回</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取锁，等待给定时间后如果获取失败直接返回</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//创建一个新的等待条件</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Lock</code>提供的获取锁方法中，有<code>lock()</code>、<code>lockInterruptibly()</code>、<code>tryLock()</code>和<code>tryLock(long time, TimeUnit unit)</code>四种方式，他们的区别如下：</p><ul><li><code>lock()</code> 获取失败后，线程进入等待队列自旋或休眠，直到锁可用，并且忽略中断的影响</li><li><code>lockInterruptibly()</code>  线程进入等待队列park后，如果线程被中断，则直接响应中断（抛出<code>InterruptedException</code>）</li><li><code>tryLock()</code> 获取锁失败后直接返回，不进入等待队列</li><li><code>tryLock(long time, TimeUnit unit)</code> 获取锁失败等待给定的时间后返回获取结果</li></ul><p>ReetrantLock通过AQS实现了自己的同步器<code>Sync</code>，分为公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>。在构造时，通过所传参数<code>boolean fair</code>来确定使用那种类型的锁。</p><p>本篇会以对比的方式分析两种锁的源码实现方式。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p><code>lock()</code>方法用于获取锁，两种类型的锁源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁，一直等待锁可用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁获取</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平锁获取</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>公平锁的<code>lock</code>方法调用了AQS的<code>acquire(1)</code>；而非公平锁则直接通过CAS修改<code>state</code>值来获取锁，当获取失败时才会调用<code>acquire(1)</code>来获取锁。<br> 关于<code>acquire()</code>方法，在上篇介绍AQS的时候已经讲过，印象不深的同学可以翻回去看一下，这里主要来看一下<code>tryAcquire</code>在ReetrantLock中的实现。</p><p><strong>公平锁tryAcquire：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取锁状态state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//判断当前线程是否还有前节点</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//CAS修改state</span></span><br><span class="line">            <span class="comment">//获取锁成功，设置锁的持有线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//当前线程已经持有锁</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//重入</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);<span class="comment">//更新state状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>公平锁模式下的<code>tryAcquire</code>，执行流程如下：</p><ol><li><p>如果当前锁状态<code>state</code>为0，说明锁处于闲置状态可以被获取，首先调用<code>hasQueuedPredecessors</code>方法判断当前线程是否还有前节点(prev node)在等待获取锁。如果有，则直接返回false；如果没有，通过调用<code>compareAndSetState</code>（CAS）修改state值来标记自己已经拿到锁，CAS执行成功后调用<code>setExclusiveOwnerThread</code>设置锁的持有者为当前线程。程序执行到现在说明锁获取成功，返回true；</p></li><li><p>如果当前锁状态<code>state</code>不为0，但当前线程已经持有锁（<code>current == getExclusiveOwnerThread()</code>），由于锁是可重入（多次获取）的，则更新重入后的锁状态<code>state += acquires</code> 。锁获取成功返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>hasQueuedPredecessors源码如上，如果在该队列中还有Node结点（即还有等待的线程），那么就返回true，否则返回false。</p></blockquote></li></ol><p><strong>非公平锁tryAcquire</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//CAS修改state</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//计算重入后的state</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>通过对比公平锁和非公平锁<code>tryAcquire</code>的代码可以看到，非公平锁的获取略去了<code>!hasQueuedPredecessors()</code>这一操作，也就是说它不会判断当前线程是否还有前节点(prev node)在等待获取锁，而是直接去进行锁获取操作。</p><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>关于<code>release()</code>方法，在上篇介绍AQS的时候已经讲过，印象不深的同学可以翻回去看一下，这里主要来看一下<code>tryRelease</code>在ReetrantLock中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;<span class="comment">//计算释放后的state值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;<span class="comment">//锁全部释放，可以唤醒下一个等待线程</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//设置锁持有线程为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><code>tryRelease</code>用于释放给定量的资源。在ReetrantLock中每次释放量为1，也就是说，<strong>在可重入锁中，获取锁的次数必须要等于释放锁的次数，这样才算是真正释放了锁。</strong>在锁全部释放后（<code>state==0</code>）才可以唤醒下一个等待线程。</p><h3 id="等待条件Condition"><a href="#等待条件Condition" class="headerlink" title="等待条件Condition"></a>等待条件Condition</h3><blockquote><p>在上篇介绍AQS中提到过，在AQS中不光有等待队列，还有一个条件队列，这个条件队列就是我们接下来要讲的Condition。<br> Condition的作用是对锁进行更精确的控制。Condition中的<code>await()、signal()、signalAll()</code>方法相当于Object的<code>wait()、notify()、notifyAll()</code>方法。不同的是，Object中的<code>wait()、notify()、notifyAll()</code>方法是和”同步锁”(<code>synchronized</code>关键字)捆绑使用的；而Condition是需要与<code>Lock</code>捆绑使用的。</p></blockquote><p><strong>Condition函数列表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使当前线程在被唤醒或被中断之前一直处于等待状态。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程在被唤醒、被中断或到达指定等待时间之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程在被唤醒、被中断或到达指定等待时间之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程在被唤醒之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程在被唤醒、被中断或到达指定最后期限之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//唤醒一个等待线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//唤醒所有等待线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>下面我们来看一下Condition在AQS中的实现</strong></p><h4 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使当前线程在被唤醒或被中断之前一直处于等待状态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();<span class="comment">//添加并返回一个新的条件节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);<span class="comment">//释放全部资源</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//当前线程不在等待队列，park阻塞</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//线程被中断，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();<span class="comment">//解除条件队列中已经取消的等待节点的链接</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);<span class="comment">//等待结束后处理中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> <code>await()</code>方法相当于Object的<code>wait()</code>。把当前线程添加到条件队列中调用<code>LockSupport.park()</code>阻塞，直到被唤醒或中断。函数流程如下：</p><ol><li>首先判断线程是否被中断，如果是，直接抛出<code>InterruptedException</code>，否则进入下一步；</li><li>添加当前线程到条件队列中，然后释放全部资源/锁;</li><li>如果当前节点不在等待队列中，调用<code>LockSupport.park()</code>阻塞当前线程，直到被<code>unpark</code>或被中断。这里先简单说一下<code>signal</code>方法，在线程接收到signal信号后，unpark当前线程，并把当前线程转移到等待队列中（sync queue）。所以，在当前方法中，如果线程被解除阻塞（unpark），也就是说当前线程被转移到等待队列中，就会跳出<code>while</code>循环，进入下一步；</li><li>线程进入等待队列后，调用<code>acquireQueued</code>方法获取锁；</li><li>调用<code>unlinkCancelledWaiters</code>方法检查条件队列中已经取消的节点，并解除它们的链接（这些取消的节点在随后的垃圾收集中被回收掉）；</li><li>逻辑处理结束，最后处理中断（抛出<code>InterruptedException</code>或把忽略的中断补上）。</li></ol><h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);<span class="comment">//唤醒条件队列的首节点线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从条件队列中移除给定节点，并把它转移到等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>; <span class="comment">//解除首节点链接</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; <span class="comment">//接收到signal信号后，把节点转入等待队列</span></span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到signal信号后，把节点转入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">//CAS修改状态失败，说明节点被取消，直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node p = enq(node);<span class="comment">//添加节点到等待队列，并返回节点的前继节点(prev)</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">//如果前节点被取消，说明当前为最后一个等待线程，unpark唤醒当前线程</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><code>signal</code>方法用于发送唤醒信号。在不考虑线程争用的情况下，执行流程如下：</p><ol><li>获取条件队列的首节点，解除首节点的链接（<code>first.nextWaiter = null;</code>）；</li><li>调用<code>transferForSignal</code>把条件队列的首节点转移到等待队列的尾部。在<code>transferForSignal</code>中，转移节点后，转移的节点没有前继节点，说明当前最后一个等待线程，直接调用<code>unpark()</code>唤醒当前线程。</li></ol><p>Condition的其他例如<code>awaitNanos(long nanosTimeout)、signalAll()</code>等方法这里这里就不多赘述了，执行流程都差不多，同学们可以参考上述分析阅读。</p><h3 id="synchronized和ReentrantLock的选择"><a href="#synchronized和ReentrantLock的选择" class="headerlink" title="synchronized和ReentrantLock的选择"></a>synchronized和ReentrantLock的选择</h3><blockquote><p>ReentrantLock在加锁和内存上提供的语义与内置锁synchronized相同，此外它还提供了一些其他功能，包括<strong>定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁</strong>。<strong>从性能方面来说，在JDK5的早期版本中，ReentrantLock的性能远远好于synchronized，但是从JDK6开始，JDK在synchronized上做了大量优化，使得两者的性能差距不大。</strong>synchronized的优点就是简洁。 所以说，两者之间的选择还是要看具体的需求，ReentrantLock可以作为一种高级工具，当需要一些高级功能时可以使用它。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ReentrantLock&lt;/strong&gt;是一个&lt;strong&gt;可重入的互斥锁&lt;/strong&gt;
      
    
    </summary>
    
      <category term="源码阅读" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="JDK" scheme="https://www.vazh.cn/tags/JDK/"/>
    
      <category term="ReentrantLock" scheme="https://www.vazh.cn/tags/ReentrantLock/"/>
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="可重入锁" scheme="https://www.vazh.cn/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析之AQS</title>
    <link href="https://www.vazh.cn/2019/07/06/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BAQS/"/>
    <id>https://www.vazh.cn/2019/07/06/JUC源码分析之AQS/</id>
    <published>2019-07-06T07:41:47.000Z</published>
    <updated>2019-09-04T02:51:52.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h2><blockquote><p>AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（<strong>Doug Lea</strong>）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。</p><p>AQS解决了子实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。</p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p></blockquote><p>AQS支持<strong>独占锁（Exclusive）和共享锁（Share）</strong>两种模式：</p><ul><li>独占锁：只能被一个线程获取到(<code>ReentrantLock</code>)；</li><li>共享锁：可以被多个线程同时获取(<code>CountDownLatch</code>、<code>ReadWriteLock</code>的读锁)。</li></ul><p>不管是独占锁还是共享锁，本质上都是对AQS内部的一个变量state的获取，state是一个原子性的int变量，可用来表示锁状态、资源数等，如下图。</p><p><img src="/picture/aqs_gs.webp" alt="aqs"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。变量使用volatile修饰，表示每一次更新都会及时的刷到主存中。</p><h2 id="数据结构与结构参数"><a href="#数据结构与结构参数" class="headerlink" title="数据结构与结构参数"></a>数据结构与结构参数</h2><p><strong>AQS的内部实现了两个队列，一个同步队列和一个条件队列</strong></p><ul><li><strong>条件队列</strong>是为Lock实现的一个基础同步器，并且一个线程可能会有多个条件队列，只有在使用了Condition才会存在条件队列。</li><li><strong>同步队列</strong>的作用是，在线程获取资源失败后，进入同步队列队尾保持自旋等待状态， 在同步队列中的线程在自旋时会判断其前节点是否为head节点，如果为head节点则不断尝试获取资源/锁，获取成功则退出同步队列。当线程执行完逻辑后，会释放资源/锁，释放后唤醒其后继节点。<h3 id="同步队列与条件队列的关系"><a href="#同步队列与条件队列的关系" class="headerlink" title="同步队列与条件队列的关系"></a>同步队列与条件队列的关系</h3></li></ul><p>首先展示同步队列与条件队列的结构图，如下：</p><p><img src="/picture/aqs00.png" alt="aqs"></p><p><strong><em>同步队列节点来源：</em></strong></p><ol><li><p>同步队列依赖一个双向链表来完成同步状态的管理，当前线程获取同步状态失败 后，同步器会将线程构建成一个节点，并将其加入同步队列中。</p></li><li><p>通过<code>signal</code>或<code>signalAll</code>将条件队列中的节点转移到同步队列。（由条件队列转化为同步队列）</p></li></ol><p><strong><em>条件队列节点来源：</em></strong></p><ol><li>调用<code>await</code>方法阻塞线程； </li><li>当前线程存在于同步队列的头结点，调用<code>await</code>方法进行阻塞（从同步队列转化到条件队列）</li></ol><p><strong>可总结为：</strong> </p><ol><li>同步队列与条件队列节点可相互转化 </li><li>一个线程只能存在于两个队列中的一个</li></ol><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><ol><li><p>假设初始状态如下，节点A、节点B在同步队列中。</p><p><img src="/picture/aqs01.jpg" alt="aqs"></p></li><li><p>节点A的线程获取锁权限，此时调用<code>await</code>方法。节点A从同步队列移除， 并加入条件队列中。</p><p><img src="/picture/aqs02.jpg" alt="aqs"></p></li><li><p>调用 <code>signal</code>方法，从条件队列中取出第一个节点，并加入同步队列中，等待获取资源</p></li></ol><p><img src="/picture/aqs03.jpg" alt="aqs"></p><p>以上三个说明实例用图片形式解释了同步队列与条件队列节点可相互转化 。需要注意的是同步队列中，头结点<code>head</code>与尾节点<code>tail</code>被放在一个同步器中，也就是Node节点。不管是同步队列还是条件队列，<strong>其内部都是由节点Node组成</strong>，首先介绍下AQS的内部类Node，主要源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Marker to indicate a node is waiting in shared mode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Marker to indicate a node is waiting in exclusive mode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待触发</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//状态需要向后传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 等待状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">/** 前驱节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">/** 后继节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">   <span class="comment">/** 获取同步状态的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：Node的实现很简单，就是一个普通双向链表的实现，这里主要说明一下内部的几个等待状态：</p><ul><li><code>CANCELLED</code>：值为1，当前节点由于超时或中断被取消。</li><li><code>SIGNAL</code>：值为-1，表示当前节点的前节点被阻塞，当前节点在release或cancel时需要执行unpark来唤醒后继节点。</li><li><code>CONDITION</code>：值为-2，当前节点正在等待Condition，这个状态在同步队列里不会被用到。</li><li><code>PROPAGATE</code>：值为-3，(针对共享锁) <code>releaseShared()</code>操作需要被传递到其他节点，这个状态在<code>doReleaseShared</code>中被设置，用来保证后续节点可以获取共享资源。</li><li><strong>0</strong>：初始状态，当前节点在sync queue中，等待获取锁。</li></ul><h3 id="AQS主要提供了如下一些方法："><a href="#AQS主要提供了如下一些方法：" class="headerlink" title="AQS主要提供了如下一些方法："></a>AQS主要提供了如下一些方法：</h3><ul><li><code>getState()</code>：返回同步状态的当前值；</li><li><code>setState(int newState)</code>：设置当前同步状态；</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li><li><code>tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</li><li><code>tryRelease(int arg)</code>：独占式释放同步状态；</li><li><code>tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败；</li><li><code>tryReleaseShared(int arg)</code>：共享式释放同步状态；</li><li><code>isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</li><li><code>acquire(int arg)</code>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</li><li><code>acquireInterruptibly(int arg)</code>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</li><li><code>tryAcquireNanos(int arg,long nanos)</code>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</li><li><code>acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li><li><code>acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断；</li><li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制；</li><li><code>release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</li><li><code>releaseShared(int arg)</code>：共享式释放同步状态；</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a>acquire(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占模式获取资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>独占模式下获取资源/锁，忽略中断的影响。内部主要调用了三个方法，其中tryAcquire需要自定义实现。后面会对各个方法进行详细分析。<code>acquire</code>方法流程如下：</p><ol><li><p><code>tryAcquire()</code> 尝试直接获取资源，如果成功则直接返回，失败进入第二步；</p></li><li><p><code>addWaiter()</code> 获取资源失败后，将当前线程加入等待队列的尾部，并标记为独占模式；</p></li><li><p><code>acquireQueued()</code> 使线程在等待队列中自旋等待获取资源，一直获取到资源后才返回。如果在等待过程中被中断过，则返回true，否则返回false。</p></li><li><p>如果线程在等待过程中被中断(interrupt)是不响应的，在获取资源成功之后根据返回的中断状态调用<code>selfInterrupt()</code>方法再把中断状态补上。</p><h4 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>尝试获取资源，成功返回true。<strong>具体资源获取/释放方式交由自定义同步器实现</strong>。<code>ReentrantLock</code>中公平锁和非公平锁的实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-addWaiter-Node"><a href="#3-1-2-addWaiter-Node" class="headerlink" title="3.1.2 addWaiter(Node)"></a>3.1.2 addWaiter(Node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加等待节点到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">//尝试快速入队</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入给定节点到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>获取独占锁失败后，将当前线程加入等待队列的尾部，并标记为独占模式。返回插入的等待节点。</p><h3 id="3-1-3-acquireQueued-Node-int"><a href="#3-1-3-acquireQueued-Node-int" class="headerlink" title="3.1.3 acquireQueued(Node,int)"></a>3.1.3 acquireQueued(Node,int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自旋等待获取资源</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前继节点</span></span><br><span class="line">            <span class="comment">//前继节点为head，说明可以尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//获取成功，更新head节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">//检查是否可以park</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取资源失败后，检查并更新等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果前节点取消了，那就一直往前找到一个等待状态的节点，并排在它的后边</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//此时前节点状态为0或PROPAGATE，表示我们需要一个唤醒信号，但是不立即park,在park前调用者需要重试来确认它不能获取资源。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//阻塞当前线程，返回中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>线程进入等待队列后，在等待队列中自旋等待获取资源。如果在整个等待过程中被中断过，则返回true，否则返回false。具体流程如下：</p><ol><li>获取当前等待节点的前继节点，如果前继节点为head，说明可以尝试获取锁；</li><li>调用<code>tryAcquire</code>获取锁，成功后更新<code>head</code>为当前节点；</li><li>获取资源失败，调用<code>shouldParkAfterFailedAcquire</code>方法检查并更新等待状态。如果前继节点状态为<code>SIGNAL</code>，说明当前节点可以进入waiting状态等待唤醒；被唤醒后，继续自旋重复上述步骤。</li><li>获取资源成功后返回中断状态。</li></ol><p>当前线程通过<code>parkAndCheckInterrupt()</code>阻塞之后进入waiting状态，此状态下可以通过下面两种途径唤醒线程：</p><ol><li>前继节点释放资源后，通过<code>unparkSuccessor()</code>方法unpark当前线程；</li><li>当前线程被中断。</li></ol><h3 id="3-2-release-int"><a href="#3-2-release-int" class="headerlink" title="3.2 release(int)"></a>3.2 release(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**独占模式释放资源*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        Node h = head;<span class="comment">//头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒head的下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>独占模式下释放指定量的资源，成功释放后调用<code>unparkSuccessor</code>唤醒head的下一个节点。</p><h3 id="3-2-1-tryRelease-int"><a href="#3-2-1-tryRelease-int" class="headerlink" title="3.2.1 tryRelease(int)"></a>3.2.1 tryRelease(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>和<code>tryAcquire()</code>一样，这个方法也需要自定义同步器去实现。一般来说，释放资源直接拿<code>state</code>减去给定的参数<code>arg</code>，释放后state==0说明释放成功。在<code>ReentrantLock</code>中实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//设置独占锁持有线程为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-unparkSuccessor-Node"><a href="#3-2-2-unparkSuccessor-Node" class="headerlink" title="3.2.2 unparkSuccessor(Node)"></a>3.2.2 unparkSuccessor(Node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//当前节点没有被取消,更新waitStatus为0。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//next节点为空，从tail节点开始向前查找有效节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>成功获取到资源后，调用此方法唤醒head的下一个节点。因为当前节点已经释放掉资源，下一个等待的线程可以被唤醒继续获取资源。</p><h2 id="3-3-acquireShared-int"><a href="#3-3-acquireShared-int" class="headerlink" title="3.3  acquireShared(int)"></a>3.3  acquireShared(int)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>共享模式下获取资源/锁，忽略中断的影响。内部主要调用了两个个方法，其中<code>tryAcquireShared</code>需要自定义同步器实现。后面会对各个方法进行详细分析。<code>acquireShared</code>方法流程如下：</p><ol><li><code>tryAcquireShared(arg)</code> 尝试获取共享资源。<strong>成功获取并且还有可用资源返回正数；成功获取但是没有可用资源时返回0；获取资源失败返回一个负数。</strong> </li><li>获取资源失败后调用<code>doAcquireShared</code>方法进入等待队列，获取资源后返回。</li></ol><h3 id="3-3-1-tryAcquireShared-int-arg"><a href="#3-3-1-tryAcquireShared-int-arg" class="headerlink" title="3.3.1 tryAcquireShared(int arg)"></a>3.3.1 tryAcquireShared(int arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**共享模式下获取资源*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>尝试获取共享资源，需同步器自定义实现。有三个类型的返回值：</p><ul><li>正数：成功获取资源，并且还有剩余可用资源，可以唤醒下一个等待线程；</li><li>负数：获取资源失败，准备进入等待队列；</li><li>0：获取资源成功，但没有剩余可用资源。</li></ul><h3 id="3-3-2-doAcquireShared-int"><a href="#3-3-2-doAcquireShared-int" class="headerlink" title="3.3.2 doAcquireShared(int)"></a>3.3.2 doAcquireShared(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取共享锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//添加一个共享模式Node到队列尾</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//前节点为head，尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取资源成功，设置head为自己，如果有剩余资源可以在唤醒之后的线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">//检查获取失败后是否可以阻塞</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>在<code>tryAcquireShared</code>中获取资源失败后，将当前线程加入等待队列尾部等待唤醒，成功获取资源后返回。在阻塞结束后成功获取到资源时，如果还有剩余资源，就调用<code>setHeadAndPropagate</code>方法继续唤醒之后的线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置head，如果有剩余资源可以再唤醒之后的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果满足下列条件可以尝试唤醒下一个节点：</span></span><br><span class="line"><span class="comment">     *  调用者指定参数(propagate&gt;0)，并且后继节点正在等待或后继节点为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-releaseShared-int"><a href="#3-4-releaseShared-int" class="headerlink" title="3.4  releaseShared(int)"></a>3.4  releaseShared(int)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**共享模式释放资源*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();<span class="comment">//释放锁，并唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>共享模式下释放给定量的资源，如果成功释放，唤醒等待队列的后继节点。<code>tryReleaseShared</code>需要自定义同步器去实现。方法执行流程：<code>tryReleaseShared(int)</code>尝试释放给定量的资源，成功释放后调用<code>doReleaseShared()</code>唤醒后继线程。</p><h3 id="3-4-1-tryReleaseShared-int"><a href="#3-4-1-tryReleaseShared-int" class="headerlink" title="3.4.1 tryReleaseShared(int)"></a>3.4.1 tryReleaseShared(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**共享模式释放资源*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>释放给定量的资源，需自定义同步器实现。释放后如果允许后继等待线程获取资源返回true。</p><h3 id="3-4-2-doReleaseShared-int"><a href="#3-4-2-doReleaseShared-int" class="headerlink" title="3.4.2 doReleaseShared(int)"></a>3.4.2 doReleaseShared(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放共享资源-唤醒后继线程并保证后继节点的资源传播</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自旋，确保释放后唤醒后继节点</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))  <span class="comment">//waitStatus为0，CAS修改为PROPAGATE</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>在<code>tryReleaseShared</code>成功释放资源后，调用此方法唤醒后继线程并保证后继节点的release传播（通过设置head节点的<code>waitStatus</code>为<code>PROPAGATE</code>）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>自此，AQS的主要方法就讲完了，有几个没有讲到的方法如<code>tryAcquireNanos</code>、<code>tryAcquireSharedNanos</code>，都是带等待时间的资源获取方法，还有<code>acquireInterruptibly</code> <code>acquireSharedInterruptibly</code>,响应中断式资源获取方法。都比较简单，同学们可以参考本篇源码阅读。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AQS概述&quot;&gt;&lt;a href=&quot;#AQS概述&quot; class=&quot;headerlink&quot; title=&quot;AQS概述&quot;&gt;&lt;/a&gt;AQS概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="AQS" scheme="https://www.vazh.cn/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析之CAS和Unsafe</title>
    <link href="https://www.vazh.cn/2019/07/06/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BCAS%E5%92%8CUnsafe/"/>
    <id>https://www.vazh.cn/2019/07/06/JUC源码分析之CAS和Unsafe/</id>
    <published>2019-07-06T07:39:18.000Z</published>
    <updated>2019-07-08T08:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识CAS"><a href="#初识CAS" class="headerlink" title="初识CAS"></a>初识CAS</h2><blockquote><p>在对J.U.C包的源码分析之前，首先介绍下一个比较重要的概念-CAS（Compare-and-Swap）。在J.U.C包中大量使用了CAS，涉及并发或资源争用的地方都使用了sun.misc.Unsafe类的方法进行CAS操作。在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</p><p>锁机制存在以下问题：</p><p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p><p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p><p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p><p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p><p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p></blockquote><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS ?"></a>什么是CAS ?</h3><p><strong>CAS,即compare and swap比较并替换。 CAS有三个参数：需要读写的内存位值（V）、进行比较的预期原值（A）和拟写入的新值(B)。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。</strong>以多线程并发为例，简单来说，CAS的含义是：“两个进程都在操作V, 我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少, 显然在这个过程中, V的值可能会被其他线程修改，所以若是V值与预期原值A不相等, 则V值被修改”。CAS是一项乐观的技术，它希望能成功地执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么CAS能检测到这个错误。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败。但是，<strong>失败的线程并不会被挂起（这就是与获取锁的机制不同之处）</strong>，而是被告知在这次竞争中失败，并可以多次尝试。这种灵活性就大大减少了与锁相关的活跃性风险。</p><p>以AtomicInteger为例，内部的CAS实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">//value的偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                    (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsInt(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>： 可以看到<code>AtomicInteger</code>内部都是使用了<code>Unsafe</code>类来进行CAS操作，<code>valueOffset</code>表示的是value值的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的原值的, 偏移量可以简单理解为指针指向该变量的内存地址。 <code>value</code>使用volatile修饰，直接从共享内存中操作变量，保证多线程之间看到的value值是同一份。<br> 以方法<code>getAndUpdate()</code>为例，执行步骤如下：</p><ol><li>从内存中读取修改前的值<code>prev</code>，并执行给定函数式计算修改后的值<code>next</code>；</li><li>调用<code>compareAndSet</code>修改<code>value</code>值（内部是调用了unsafe的<code>compareAndSwapInt</code>方法）。如果此时有其他线程也在修改这个<code>value</code>值，那么CAS操作就会失败，继续进入do循环重新获取新值. 由while循环判断知<strong>compareAndSet(prev, next)</strong>返回false，即没有更新成功时，就会一直循环下去，直到更新成功.</li></ol><p>下面通熟易懂的上一个Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">10</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">10</span>,<span class="number">666</span>));</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">10</span>,<span class="number">888</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger有一个compareAndSet方法，有两个操作数，第一个是期望值，第二个是希望修改成的值。首先初始值是10，也是内存中的值，第一次调用compareAndSet方法的时候，会将10拷贝回自己的工作空间，然后改成666，写回到主内存中的时候，它期望主内存中的值是10，而这时确实也是10，所以可以修改成功，主内存中的值也变成了666，输出true。第二次调用compareAndSet的时候，在自己的工作内存将值修改成888，写回去的时候，希望主内存中的值是10，但是此时是666，所以set失败，输出false。这就是比较并交换，也即CAS。当然实际过程中是不会这样顺序执行，而是并发执行，多个线程都在修改值，而当其中一个线程修改成功时，这意味着在这一轮中，其他线程都更新失败，进行下一次更新。</p><h2 id="CAS的工作原理"><a href="#CAS的工作原理" class="headerlink" title="CAS的工作原理"></a>CAS的工作原理</h2><p>简而言之，CAS工作原理就是<strong>UnSafe类</strong>和<strong>自旋锁</strong>。<br> <strong>1、UnSafe类：</strong><br> UnSafe类在jdk的rt.jar下面的一个类，全包名是sun.misc.UnSafe。这个类大多数方法都是native方法。由于Java不能操作计算机系统，所以设计之初就留了一个UnSafe类。通过UnSafe类，Java就可以操作指定内存地址的数据。调用UnSafe类的CAS，JVM会帮我们实现出汇编指令，从而实现原子操作。现在就来分析一下AtomicInteger的getAndIncrement方法是怎么工作的。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法调用的是unsafe类的getAndAddInt方法，有三个参数。第一个表示当前对象，也就是你new 的那个AtomicInteger对象；第二个表示内存地址；第三个表示自增步伐。然后再点进去看看这个getAndAddInt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的val1就是当前对象，val2是内存地址，val4是1，也就是自增步伐。首先把当前对象主内存中的值赋给val5，然后进入while循环。判断当前对象此刻主内存中的值是否等于val5，如果是，就自增，否则继续循环，重新获取val5的值。<strong>这里的compareAndSwapInt方法就是一个native方法，这个方法汇编之后是CPU原语指令，原语指令是连续执行不会被打断的，所以可以保证原子性。</strong></p><p><strong>2、自旋锁：</strong><br> 所谓的自旋，其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时，就重新获取主内存中的值，这就是自旋。</p><h2 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h2><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p><ol><li><p><strong>循环时间长，开销大。</strong><br>synchronized是加锁，同一时间只能一个线程访问，并发性不好。而CAS并发性提高了，但是由于CAS存在自旋操作，即do while循环，如果CAS失败，会一直进行尝试。如果CAS长时间不成功，会给CPU带来很大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子性。</strong><br>上面也看到了，getAndAddInt方法的val1是代表当前对象，所以它也就是能保证这一个共享变量的原子性。如果要保证多个，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量z=1, k = a，合并一下zk = 1a，然后用CAS来操作zk。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p></li><li><p><strong>引来的ABA问题。</strong></p><ul><li><strong>什么是ABA问题？</strong></li></ul><p>假设现在主内存中的值是A，现有t1和t2两个线程去对其进行操作。t1和t2先将A拷贝回自己的工作内存。这个时候t2线程将A改成B，刷回到主内存。此刻主内存和t2的工作内存中的值都是B。接下来还是t2线程抢到执行权，t2又把B改回A，并刷回到主内存。这时t1终于抢到执行权了，自己工作内存中的值的A，主内存也是A，因此它认为没人修改过，就在工作内存中把A改成了X，然后刷回主内存。也就是说，在t1线程执行前，t2将主内存中的值由A改成B再改回A。这便是ABA问题。看下面的代码演示(代码涉及到原子引用，请参考下面的原子引用的介绍)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> AtomicReference&lt;String&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">"A"</span>);</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              atomicReference.compareAndSet(<span class="string">"A"</span>,<span class="string">"B"</span>);</span><br><span class="line">              atomicReference.compareAndSet(<span class="string">"B"</span>,<span class="string">"A"</span>);</span><br><span class="line">              &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123; </span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace(); </span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(atomicReference.compareAndSet(<span class="string">"A"</span>,<span class="string">"C"</span>) </span><br><span class="line">                                           + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">              &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码执行结果是”true C”，这就证明了ABA问题的存在。<strong>如果一个业务只管开头和结果，不管这个A中间是否变过，那么出现了ABA问题也没事。如果需要A还是最开始的那个A，中间不许别人动手脚，那么就要规避ABA问题</strong>。要解决ABA问题，先看下面的原子引用的介绍。</p><ul><li><strong>原子引用：</strong></li></ul><p>JUC包下给我们提供了原子包装类，像AtomicInteger。如果我不仅仅想要原子包装类，我自己定义的User类也想具有原子操作，怎么办呢？<strong>JUC为我们提供了AtomicReference<v>，即原子引用。</v></strong>看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">20</span>,<span class="string">"张三"</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        atomicReference.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样，就把User类变成了原子User类了。</p><ul><li><strong>解决ABA问题思路：</strong></li></ul><p>我们可以这个共享变量带上一个版本号。比如现在主内存中的是A，版本号是1，然后t1和t2线程拷贝一份到自己工作内存。t2将A改为B，刷回主内存。此时主内存中的是B，版本号为2。然后再t2再改回A，此时主内存中的是A，版本号为3。这个时候t1线程终于来了，自己工作内存是A，版本号是1，主内存中是A，但是版本号为3，它就知道已经有人动过手脚了。那么这个版本号从何而来，这就要说说AtomicStampedReference这个类了。</p><ul><li><strong>带时间戳的原子引用(AtomicStampedReference)：</strong><br>这个时间戳就理解为版本号就行了。看如下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; atomicReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);<span class="comment">// 睡一秒，让t1线程拿到最初的版本号</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                atomicReference.compareAndSet(<span class="string">"A"</span>, <span class="string">"B"</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">                atomicReference.compareAndSet(<span class="string">"B"</span>, <span class="string">"A"</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> stamp = atomicReference.getStamp();<span class="comment">//拿到最开始的版本号</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">// 睡3秒，让t2线程的ABA操作执行完</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(atomicReference.compareAndSet(<span class="string">"A"</span>, <span class="string">"C"</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">            &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始版本号为1，t2线程每执行一次版本号加。等t1线程执行的时候，发现当前版本号不是自己一开始拿到的1了，所以set失败，输出false。这就解决了ABA问题。</p><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><blockquote><p>Unsafe是实现CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。Unsafe类提供了硬件级别的原子操作。</p></blockquote><h3 id="Unsafe函数列表"><a href="#Unsafe函数列表" class="headerlink" title="Unsafe函数列表"></a>Unsafe函数列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///--------------------- peek and poke 指令--------------</span></span><br><span class="line"><span class="comment">//获取对象o中给定偏移地址(offset)的值。以下相关get方法作用相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//在对象o的给定偏移地址存储数值x。以下set方法作用相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="comment">/**篇幅原因，省略其他类型方法 */</span></span><br><span class="line"><span class="comment">//从给定内存地址获取一个byte。下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span>    <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//在给定内存地址放置一个x。下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> x)</span></span>;</span><br><span class="line"><span class="comment">/**篇幅原因，省略其他类型方法*/</span></span><br><span class="line"><span class="comment">//获取给定内存地址的一个本地指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">getAddress</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//在给定的内存地址处存放一个本地指针x</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putAddress</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///------------------内存操作----------------------</span></span><br><span class="line"><span class="comment">//在本地内存分配一块指定大小的新内存，内存的内容未初始化;它们通常被当做垃圾回收。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//重新分配给定内存地址的本地内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//将给定内存块中的所有字节设置为固定值（通常是0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="comment">//复制一块内存，double-register模型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Object destBase, <span class="keyword">long</span> destOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//复制一块内存，single-register模型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(<span class="keyword">long</span> srcAddress, <span class="keyword">long</span> destAddress, <span class="keyword">long</span> bytes)</span> </span>&#123;</span><br><span class="line">    copyMemory(<span class="keyword">null</span>, srcAddress, <span class="keyword">null</span>, destAddress, bytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放给定地址的内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//获取给定对象的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------数组操作---------------------------------</span></span><br><span class="line"><span class="comment">//获取给定数组的第一个元素的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br><span class="line"><span class="comment">//获取给定数组的元素增量地址，也就是说每个元素的占位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//告诉虚拟机去定义一个类。默认情况下，类加载器和保护域都来自这个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                   ClassLoader loader,</span><br><span class="line">                                   ProtectionDomain protectionDomain);</span><br><span class="line"><span class="comment">//定义匿名内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, <span class="keyword">byte</span>[] data, Object[] cpPatches);</span><br><span class="line"><span class="comment">//定位一个实例，但不运行构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///--------------------锁指令（synchronized）-------------------------------</span></span><br><span class="line"><span class="comment">//对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//对象解锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//解除给定线程的阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"><span class="comment">//阻塞当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Object expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Object x)</span></span>;</span><br><span class="line"><span class="comment">//获取对象o的给定偏移地址的引用值（volatile方式）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="comment">/** 省略其他类型方法  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于lazySet，适用于低延迟代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putOrderedObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="comment">/** 省略其他类型方法  */</span></span><br><span class="line"><span class="comment">//获取并加上给定delta，返回加之前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span></span></span><br><span class="line"><span class="function"><span class="comment">/** 省略其他类型方法  */</span></span></span><br><span class="line"><span class="function"><span class="comment">//为给定偏移地址设置一个新的值，返回设置之前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> newValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">/** 省略其他类型方法  */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">///--------------------1.8新增指令-----------------------</span></span></span><br><span class="line"><span class="function"><span class="comment">// loadFence() 表示该方法之前的所有load操作在内存屏障之前完成</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//表示该方法之前的所有store操作在内存屏障之前完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//表示该方法之前的所有load、store操作在内存屏障之前完成，这个相当于上面两个的合体功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Unsafe的方法比较简单，直接看方法字面意思就大概知道方法的作用。<br> 在Unsafe里有两个方法模型：<br> <strong>double-register模型</strong>：给定对象，给定偏移地址offset。从给定对象的偏移地址取值。如<code>getInt(Object o, long offset)</code>；<br> <strong>single-register模型</strong>：给定内存地址，直接从给定内存地址取值，如<code>getInt(long)</code>。</p><p>这里介绍一下几个比较重要的方法，在之后的源码阅读里会用到。</p><ol><li><code>arrayBaseOffset</code>：操作数组，用于获取数组的第一个元素的偏移地址</li><li><code>arrayIndexScale</code>：操作数组，用于获取数组元素的增量地址，也就是说每个元素的占位数。打个栗子：如果有一个数组{1,2,3,4,5,6}，它第一个元素的偏移地址为16，每个元素的占位是4，如果我们要获取数组中“5”这个数字，那么它的偏移地址就是16+4*4。</li><li><code>putOrderedObject</code>：putOrderedObject 是 lazySet 的实现，适用于低延迟代码。它能够实现非堵塞写入，避免指令重排序，这样它使用快速的存储-存储(store-store) barrier,而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上。这种性能提升是有代价的，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到。类似的方法还有<code>putOrderedInt、putOrderedLong</code>。</li><li><code>loadFence</code>、<code>storeFence</code>、<code>fullFence</code>：这三个方法是1.8新增，主要针对内存屏障定义，也是为了避免重排序：</li></ol><ul><li>loadFence() 表示该方法之前的所有load操作在内存屏障之前完成。</li><li>storeFence()表示该方法之前的所有store操作在内存屏障之前完成。</li><li>fullFence()表示该方法之前的所有load、store操作在内存屏障之前完成。</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.什么是CAS?  —— 比较并交换，主内存值和工作内存值相同，就set为更新值。<br> 2.CAS原理是什么？ —— UnSafe类和自旋锁。理解那个do while循环。<br> 3.CAS缺点是什么？ —— 循环时间长会消耗大量CPU资源；只能保证一个共享变量的原子性操作；造成ABA问题。<br> 4.什么是ABA问题？ —— t2线程先将A改成B，再改回A，此时t1线程以为没人修改过。<br> 5.如何解决ABA问题？—— 使用带时间戳的原子引用。</p></li></ol><p>   参考引用链接：<a href="https://www.jianshu.com/p/8e74009684c7" target="_blank" rel="noopener">https://www.jianshu.com/p/8e74009684c7</a></p><p>   ​            　<a href="https://www.jianshu.com/p/a897c4b8929f" target="_blank" rel="noopener">https://www.jianshu.com/p/a897c4b8929f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初识CAS&quot;&gt;&lt;a href=&quot;#初识CAS&quot; class=&quot;headerlink&quot; title=&quot;初识CAS&quot;&gt;&lt;/a&gt;初识CAS&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在对J.U.C包的源码分析之前，首先介绍下一个比较重要的概念-CAS（Compare-an
      
    
    </summary>
    
      <category term="JDK" scheme="https://www.vazh.cn/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="源码分析" scheme="https://www.vazh.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="CAS" scheme="https://www.vazh.cn/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之ConcurrentHashMap</title>
    <link href="https://www.vazh.cn/2019/06/27/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BConcurrentHashMap/"/>
    <id>https://www.vazh.cn/2019/06/27/JDK源码阅读之ConcurrentHashMap/</id>
    <published>2019-06-27T05:55:18.000Z</published>
    <updated>2019-06-27T05:55:18.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK源码阅读之String类</title>
    <link href="https://www.vazh.cn/2019/05/25/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BString%E7%B1%BB/"/>
    <id>https://www.vazh.cn/2019/05/25/JDK源码阅读之String类/</id>
    <published>2019-05-25T07:10:32.000Z</published>
    <updated>2019-09-04T02:51:15.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String类简介"><a href="#String类简介" class="headerlink" title="String类简介"></a>String类简介</h1><p>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p><h1 id="String类的类图"><a href="#String类的类图" class="headerlink" title="String类的类图"></a>String类的类图</h1><p><img src="/picture/string_01.png" alt="class"></p><ol><li><p>该类实现了序列化接口，说明该类可以被序列化和反序列化（反序列化是构建对象的一种方式）</p></li><li><p>该类实现了比较器的接口，说明该类实现了默认的比较方式，在集合中的排序会根据这个比较的方式来进行排序。</p></li><li><p>该类实现了CharSequence 接口，CharSequence 是 char 值的一个可读序列。此接口对许多不同种类的 char 序列提供统一的只读访问</p></li></ol><h1 id="String类的重要方法源码解读"><a href="#String类的重要方法源码解读" class="headerlink" title="String类的重要方法源码解读"></a>String类的重要方法源码解读</h1><h2 id="String类域"><a href="#String类域" class="headerlink" title="String类域"></a>String类域</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">     * &lt;a href="&#123;<span class="doctag">@docRoot</span>&#125;/../platform/serialization/spec/output.html"&gt;</span></span><br><span class="line"><span class="comment">     * Object Serialization Specification, Section 6.2, "Stream Elements"&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>主要注意value和hash这两个域，<strong>String内部也是使用数组进行存储数据的</strong>，hash是这个字符串对应的哈希码，<strong>因为String是不可变的，当String的内容发生变化之后，虚拟机会生成一个新的字符串，并将String的引用只想这个字符串，这样如果String经常发生变化时，字符串常量表里面会有大量的字符串，会浪费内存</strong>，为了节约内存空间，<strong>一个方法是使用StringBuilder，StringBuilder是可变的，另一个方法就是为每一个不可变的字符串生成一个哈希码</strong>，这样如果字符串常量表中有现成的字符串时，就不需要再生成了，直接引用就行了.为了验证常量字符串的缓存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo1</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(aString == bString);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面程序的最终结果为true.这也证明了a和b指向的是同一个对象，即常量池只有一个”abc”字符串。当然，上面成立的前提是直接将字符串常量赋值给String引用才有效，<strong>如果使用new的话，就会在堆中生成对象</strong>，即使使用一样的字符串初始化，引用也不会相等。</p><p><strong>采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在”abc”这个对象，如果不存在，则在字符串常量池中创建”abc”这个对象，然后将池中”abc”这个对象的引用地址返回给”abc”对象的引用s1，这样s1会指向字符串常量池中”abc”这个字符串对象；如果存在，则不创建任何对象，直接将池中”abc”这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的”abc”对象，所以结果为true。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br><span class="line">System.out.println(s3==s4);</span><br></pre></td></tr></table></figure><p><strong>结果是 false</strong></p><p><strong>采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”xyz”这个字符串对象，如果有，则不在池中再去创建”xyz”这个对象了，直接在堆中创建一个”xyz”字符串对象，然后将堆中的这个”xyz”对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个”xyz”字符串对象；如果没有，则首先在字符串池中创建一个”xyz”字符串对象，然后再在堆中创建一个”xyz”字符串对象，然后将堆中这个”xyz”字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个”xyz”字符串对象。s4则指向了堆中创建的另一个”xyz”字符串对象。s3 、s4是两个指向不同对象的引用，指向的都是堆中的地址，结果当然是false。</strong></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li>不带参数的构造函数，实际上就是空，源码如下。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的属性变量可以知道，我们这个类中主要有char数组和hash值。那么理所当然的，构造方法就是围绕着两个变量在展开的。将全部的构造方法阅读一遍之后，发现除了<strong>参数检验(下标越界)</strong>之外的操作，主要是：</p><p>Arrays.copyOf() 和 Arrays.copyOfRange() 两个方法（如果涉及了编码问题会调用StringCoding.decode() 方法），将要组成String的值放入到char数组中。最后这两个方法都会调用System.arraycopy(), 然后就会发现这个方法调用系统方法(native 方法)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//检验offset 初始偏移量 的值，不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//检验 count 裁剪的数量  不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">        <span class="comment">//检验范围</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">         <span class="comment">//检验参数，如上</span></span><br><span class="line">        checkBounds(bytes, offset, length);</span><br><span class="line">        <span class="keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(length);</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; bytes.length - length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>String 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。大小写映射基于 Character 类指定的 Unicode 标准版。</p><h3 id="字符串判断相关方法"><a href="#字符串判断相关方法" class="headerlink" title="字符串判断相关方法"></a>字符串判断相关方法</h3><ul><li><h4 id="public-boolean-equals-Object-anObject"><a href="#public-boolean-equals-Object-anObject" class="headerlink" title="public boolean equals(Object anObject)"></a>public boolean equals(Object anObject)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个字符串是否想等。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断两个对象是不是同一个对象，如果是那么一定是true,否则则进行第二道判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//首先判断对象是否是String类型对象，在底层就是将两个数组一个一个的对比</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String) anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="public-boolean-equalsIgnoreCase-String-anotherString"><a href="#public-boolean-equalsIgnoreCase-String-anotherString" class="headerlink" title="public boolean equalsIgnoreCase(String anotherString)"></a>public boolean equalsIgnoreCase(String anotherString)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略大小写比较两个字符串是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span></span><br><span class="line">                : (anotherString != <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (anotherString.value.length == value.length)</span><br><span class="line">                &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试两个字符串区域是否相等。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">将此 String 对象的子字符串与参数 other 的子字符串进行比较。</span></span><br><span class="line"><span class="comment">如果这两个子字符串表示相同的字符序列，则结果为 true，</span></span><br><span class="line"><span class="comment">当且仅当 ignoreCase 为 true 时忽略大小写。</span></span><br><span class="line"><span class="comment">要比较的此 String 对象的子字符串从索引 toffset 处开始，长度为 len。</span></span><br><span class="line"><span class="comment">要比较的 other 的子字符串从索引 ooffset 处开始，长度为 len。</span></span><br><span class="line"><span class="comment">当且仅当下列至少一项为 true 时，结果才为 false：</span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">            String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ta[] = value;</span><br><span class="line">        <span class="keyword">int</span> to = toffset;</span><br><span class="line">        <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">        <span class="keyword">int</span> po = ooffset;</span><br><span class="line">        <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">        <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">                || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">                || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">            <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">                <span class="comment">// If characters don't match but case may be ignored,</span></span><br><span class="line">                <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">                <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">                <span class="comment">// continue.</span></span><br><span class="line">                <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">                <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">                <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">                <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">                <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">                <span class="comment">// exiting.</span></span><br><span class="line">                <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>忽略大小写的方法就是在比较的时候，在加上比较将两个字符同时转换成大写，小写的比较。至于为什么转成大写了之后，还要转换成小写的在比较一次，我也不是很清楚。官方的解释是：如果只比较大写的话，有些情况是不能得到我们想要的答案的。</p><ul><li><h4 id="public-boolean-startsWith-String-prefix-int-toffset"><a href="#public-boolean-startsWith-String-prefix-int-toffset" class="headerlink" title="public boolean startsWith(String prefix, int toffset)"></a>public boolean startsWith(String prefix, int toffset)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ta[] = value;</span><br><span class="line">        <span class="keyword">int</span> to = toffset;</span><br><span class="line">        <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">        <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">        <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">        <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>startsWith函数用于检测字符串是否以prefix为前缀开始，是返回true。第一个是指定开始的下标索引，第二个则是从开始位置，endWith则是表示以suffix结尾, 底层还是通过调用startsWith, 计算出开始索引。</p><ul><li><h4 id="public-int-compareTo-String-anotherString"><a href="#public-int-compareTo-String-anotherString" class="headerlink" title="public int compareTo(String anotherString)"></a>public int compareTo(String anotherString)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">        <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">            <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len1 - len2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>String类实现了Comparable接口，所以说String是可比较的</strong>，compareTo的返回值是这样的，从两者的第一个字母比较过去，如果有一个字母不相等，则返回大的字母减去小的字母的int值，如果比较完了，则返回两者String的长度之差。符合compareTo方法的返回值要求，即：如果a小于b返回负数，如果a大于b，返回正数，否则返回0.</p><h3 id="获取字符串的方法"><a href="#获取字符串的方法" class="headerlink" title="获取字符串的方法"></a>获取字符串的方法</h3><ul><li><h4 id="public-char-charAt-int-index"><a href="#public-char-charAt-int-index" class="headerlink" title="public char charAt(int index)"></a>public char charAt(int index)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取某一个索引的字符，因为String是字符数组实现，所以直接返回value[index]即可</p><ul><li><h4 id="public-int-indexOf-String-str"><a href="#public-int-indexOf-String-str" class="headerlink" title="public int indexOf(String str)"></a>public int indexOf(String str)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> indexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">             str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">         <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         fromIndex = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> fromIndex;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> first = target[targetOffset];</span><br><span class="line">     <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">         <span class="comment">/* Look for first character. */</span></span><br><span class="line">         <span class="comment">// 寻找第一个字符相同的地方</span></span><br><span class="line">         <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">             <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">         <span class="comment">// 继续对比接下来的字符</span></span><br><span class="line">         <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">             <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                     == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                 <span class="comment">/* Found whole string. */</span></span><br><span class="line">                 <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>原来判断字符串1是不是字符串2的子串，java的源码是使用暴力循环，并没有使用其他的算法。</p><ul><li><h4 id="public-String-substring-int-beginIndex-int-endIndex"><a href="#public-String-substring-int-beginIndex-int-endIndex" class="headerlink" title="public String substring(int beginIndex, int endIndex)"></a>public String substring(int beginIndex, int endIndex)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">     <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">             : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>返回一个新的String对象, 截取字符串方法，包括beginIndex索引，不包括endIndex索引</p><p>另一个方法substring(int beginIndex)是截取从索引　<strong>beginIndex</strong>　到结尾。</p><h3 id="字符串转换的方法"><a href="#字符串转换的方法" class="headerlink" title="字符串转换的方法"></a>字符串转换的方法</h3><ul><li><h4 id="public-char-toCharArray"><a href="#public-char-toCharArray" class="headerlink" title="public char[] toCharArray()"></a>public char[] toCharArray()</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">       <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">       <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">       System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>第一眼看到这个方法，结合String以字符数组实现，我以为会直接返回对象数组，现在看了代码之后发现不是，后来想一想发现，数组是引用类型，<strong>如果将数组的引用放出去，那么String的值也会相应的改变</strong>。如果发生这个，那么就会产生很大的灾难。</p><ul><li><h4 id="public-String-toLowerCase"><a href="#public-String-toLowerCase" class="headerlink" title="public String toLowerCase()"></a>public String toLowerCase()</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> toLowerCase(Locale.getDefault());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> firstUpper;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Now check if there are any characters that need to be changed. */</span></span><br><span class="line">     scan: &#123;</span><br><span class="line">         <span class="keyword">for</span> (firstUpper = <span class="number">0</span> ; firstUpper &lt; len; ) &#123;</span><br><span class="line">             <span class="keyword">char</span> c = value[firstUpper];</span><br><span class="line">             <span class="keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)</span><br><span class="line">                     &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;</span><br><span class="line">                 <span class="keyword">int</span> supplChar = codePointAt(firstUpper);</span><br><span class="line">                 <span class="keyword">if</span> (supplChar != Character.toLowerCase(supplChar)) &#123;</span><br><span class="line">                     <span class="keyword">break</span> scan;</span><br><span class="line">                 &#125;</span><br><span class="line">                 firstUpper += Character.charCount(supplChar);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (c != Character.toLowerCase(c)) &#123;</span><br><span class="line">                     <span class="keyword">break</span> scan;</span><br><span class="line">                 &#125;</span><br><span class="line">                 firstUpper++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">     <span class="keyword">int</span> resultOffset = <span class="number">0</span>;  <span class="comment">/* result may grow, so i+resultOffset</span></span><br><span class="line"><span class="comment">                             * is the write location in result */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Just copy the first few lowerCase characters. */</span></span><br><span class="line">     System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, firstUpper);</span><br><span class="line"></span><br><span class="line">     String lang = locale.getLanguage();</span><br><span class="line">     <span class="keyword">boolean</span> localeDependent =</span><br><span class="line">             (lang == <span class="string">"tr"</span> || lang == <span class="string">"az"</span> || lang == <span class="string">"lt"</span>);</span><br><span class="line">     <span class="keyword">char</span>[] lowerCharArray;</span><br><span class="line">     <span class="keyword">int</span> lowerChar;</span><br><span class="line">     <span class="keyword">int</span> srcChar;</span><br><span class="line">     <span class="keyword">int</span> srcCount;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = firstUpper; i &lt; len; i += srcCount) &#123;</span><br><span class="line">         srcChar = (<span class="keyword">int</span>)value[i];</span><br><span class="line">         <span class="keyword">if</span> ((<span class="keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE</span><br><span class="line">                 &amp;&amp; (<span class="keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;</span><br><span class="line">             srcChar = codePointAt(i);</span><br><span class="line">             srcCount = Character.charCount(srcChar);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             srcCount = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (localeDependent || srcChar == <span class="string">'\u03A3'</span>) &#123; <span class="comment">// GREEK CAPITAL LETTER SIGMA</span></span><br><span class="line">             lowerChar = ConditionalSpecialCasing.toLowerCaseEx(<span class="keyword">this</span>, i, locale);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcChar == <span class="string">'\u0130'</span>) &#123; <span class="comment">// LATIN CAPITAL LETTER I DOT</span></span><br><span class="line">             lowerChar = Character.ERROR;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             lowerChar = Character.toLowerCase(srcChar);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> ((lowerChar == Character.ERROR)</span><br><span class="line">                 || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (lowerChar == Character.ERROR) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!localeDependent &amp;&amp; srcChar == <span class="string">'\u0130'</span>) &#123;</span><br><span class="line">                     lowerCharArray =</span><br><span class="line">                             ConditionalSpecialCasing.toLowerCaseCharArray(<span class="keyword">this</span>, i, Locale.ENGLISH);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     lowerCharArray =</span><br><span class="line">                             ConditionalSpecialCasing.toLowerCaseCharArray(<span class="keyword">this</span>, i, locale);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcCount == <span class="number">2</span>) &#123;</span><br><span class="line">                 resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 lowerCharArray = Character.toChars(lowerChar);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Grow result if needed */</span></span><br><span class="line">             <span class="keyword">int</span> mapLen = lowerCharArray.length;</span><br><span class="line">             <span class="keyword">if</span> (mapLen &gt; srcCount) &#123;</span><br><span class="line">                 <span class="keyword">char</span>[] result2 = <span class="keyword">new</span> <span class="keyword">char</span>[result.length + mapLen - srcCount];</span><br><span class="line">                 System.arraycopy(result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset);</span><br><span class="line">                 result = result2;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; mapLen; ++x) &#123;</span><br><span class="line">                 result[i + resultOffset + x] = lowerCharArray[x];</span><br><span class="line">             &#125;</span><br><span class="line">             resultOffset += (mapLen - srcCount);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             result[i + resultOffset] = (<span class="keyword">char</span>)lowerChar;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul><li><h4 id="public-String-trim"><a href="#public-String-trim" class="headerlink" title="public String trim()"></a>public String trim()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串的副本，忽略前导空白和尾部空白。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len = value.length;</span><br><span class="line">     <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">  </span><br><span class="line">     <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">         st++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">         len--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>将字符串前导空白和尾部空白忽略。</p><ul><li><h4 id="public-String-split-String-regex-int-limit"><a href="#public-String-split-String-regex-int-limit" class="headerlink" title="public String[] split(String regex, int limit)"></a>public String[] split(String regex, int limit)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="comment">/* fastpath if the regex is a</span></span><br><span class="line"><span class="comment">         (1)one-char String and this character is not one of the</span></span><br><span class="line"><span class="comment">            RegEx's meta characters ".$|()[&#123;^?*+\\", or</span></span><br><span class="line"><span class="comment">         (2)two-char String and the first char is the backslash and</span></span><br><span class="line"><span class="comment">            the second is not the ascii digit or ascii letter.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">             <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">             (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">              regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">              (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">            (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">             ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                    list.add(substring(off, next));</span><br><span class="line">                    off = next + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                    <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                    list.add(substring(off, value.length));</span><br><span class="line">                    off = value.length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If no match was found, return this</span></span><br><span class="line">            <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add remaining segment</span></span><br><span class="line">            <span class="keyword">if</span> (!limited || list.size() &lt; limit)</span><br><span class="line">                list.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Construct result</span></span><br><span class="line">            <span class="keyword">int</span> resultSize = list.size();</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>)</span><br><span class="line">                    resultSize--;</span><br><span class="line">            String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">            <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部使用arrayList集合来收集被分割的子串，子串是通过substring（）方法来得到的，参数是通过indexof方法来获取的。</p><ul><li><h4 id="public-String-concat-String-str"><a href="#public-String-concat-String-str" class="headerlink" title="public String concat(String str)"></a>public String concat(String str)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">        <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p> intern方法是一个本地方法，调用该方法，会判断是否常量池中有一个与该String对象相等的对象（也就是equals返回0），如果有返回常量池中的对象，否则，将该String对象添加到常量池中再返回常量池中的对象。</p></li></ul><h2 id="String类涉及的设计模式"><a href="#String类涉及的设计模式" class="headerlink" title="String类涉及的设计模式"></a>String类涉及的设计模式</h2><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="模式解释"><a href="#模式解释" class="headerlink" title="模式解释"></a>模式解释</h4><p>一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素</p><h3 id="String类的体现"><a href="#String类的体现" class="headerlink" title="String类的体现"></a>String类的体现</h3><p>因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。</p><h2 id="阅读String类的感想"><a href="#阅读String类的感想" class="headerlink" title="阅读String类的感想"></a>阅读String类的感想</h2><p>String类是我们最常使用的一个类，我们也都知道String类是不可改变的，每当改变一个变量的值时候，地址也会随之改变。基于这种不变的特性，出现了享元模式，让系统中的多个相同的String共享一个地址，避免了开销。</p><p>String类的底层是char数组，所以我们看到String的方法（对字符串的操作）底层都是操作数组。其实我们看到方法之后，了解底层是数组，对方法的一些大概操作是可以预知的，在读完源码之后，会更加清晰明了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String类简介&quot;&gt;&lt;a href=&quot;#String类简介&quot; class=&quot;headerlink&quot; title=&quot;String类简介&quot;&gt;&lt;/a&gt;String类简介&lt;/h1&gt;&lt;p&gt;String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都
      
    
    </summary>
    
      <category term="JDK" scheme="https://www.vazh.cn/categories/JDK/"/>
    
    
      <category term="源码阅读" scheme="https://www.vazh.cn/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode17-电话号码的字母组合</title>
    <link href="https://www.vazh.cn/2019/05/25/Leetcode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://www.vazh.cn/2019/05/25/Leetcode17-电话号码的字母组合/</id>
    <published>2019-05-25T02:56:07.000Z</published>
    <updated>2019-09-04T02:54:55.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：&quot;23&quot;</span><br><span class="line">&gt; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>使用字符串数组map存储电话号码的字母映射</li><li>使用深度遍历方法DFS , 依次遍历digits的数字，再字典map中查找，组合可能</li><li>如果拼接的字符串长度等于数字字符长度，则添加该字符串</li><li>返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] map = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (digits != <span class="keyword">null</span> &amp;&amp; digits.length() &gt; <span class="number">0</span>) dfs(ans, <span class="string">""</span>, digits);</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; ans, String cur, String digits)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (cur.length() == digits.length()) &#123;</span><br><span class="line">           ans.add(cur);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> index = digits.charAt(cur.length()) - <span class="string">'0'</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map[index].length(); i++) &#123;</span><br><span class="line">           dfs(ans, cur + map[index].charAt(i), digits);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n * n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 0 ms, faster than 100.00% of Java online submissions for Letter Combinations of a Phone Number.</p><p><strong>Memory Usage</strong>: 35.2 MB, less than 98.30% of Java online submissions for Letter Combinations of a Phone Number.</p><p><img src="/picture/lc17.png" alt="lc017"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="贪心" scheme="https://www.vazh.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="DFS" scheme="https://www.vazh.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode300-最长上升子序列</title>
    <link href="https://www.vazh.cn/2019/05/25/Leetcode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://www.vazh.cn/2019/05/25/Leetcode300-最长上升子序列/</id>
    <published>2019-05-25T02:12:03.000Z</published>
    <updated>2019-09-04T04:32:58.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">&gt; 输出: 4 </span><br><span class="line">&gt; 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(<em>n2</em>) 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p></blockquote><h2 id="Method-One"><a href="#Method-One" class="headerlink" title="Method  One"></a>Method  One</h2><ul><li>如果长度小于等于1,直接返回nunms.length</li><li>max 记录当前遍历i 情况下的最长子串长度, dp[i] 存放最长子串的最后一个元素值（最大值）</li><li>如果当前元素比最大的那个子串的最后一个元素还要大，那就直接长度加一，新子串的最后一个元素为当前元素</li><li>如果当前元素比最大的那个子串的最后一个元素要小，那就要更新dp数组，保证每一个子串都是最优解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最大长度</span></span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//dp[i]表示第i长的子序列，最后的元素</span></span><br><span class="line">            <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">                <span class="comment">//如果当前元素比最大的那个子串的最后一个元素还要大</span></span><br><span class="line">                <span class="comment">//那就直接长度加一，新子串的最后一个元素为当前元素</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; dp[max])&#123;</span><br><span class="line">                    dp[++max] = nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; dp[max])&#123;</span><br><span class="line">                    <span class="comment">//如果当前元素比最大的那个子串的最后一个元素要小</span></span><br><span class="line">                    <span class="comment">//那就要更新dp数组，保证每一个子串都是最优解</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ;j &lt;= max; j++)&#123;</span><br><span class="line">                        <span class="comment">//因为是递增，所以是&lt;=,在将等于的时候直接终止循环</span></span><br><span class="line">                        <span class="keyword">if</span>(nums[i] &lt;= dp[j])&#123;</span><br><span class="line">                            dp[j] = nums[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n * n).</strong> </li><li><strong>Space complexity : O(1).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence.</p><p><strong>Memory Usage</strong>: 36.3 MB, less than 57.53% of Java online submissions for Longest Increasing Subsequence.</p><p><img src="/picture/lc300_01.png" alt="lc300_01"></p><h2 id="Method-Two"><a href="#Method-Two" class="headerlink" title="Method  Two"></a>Method  Two</h2><ul><li>如果长度小于等于1,直接返回nunms.length</li><li>max 记录当前遍历i 情况下的最长子串长度, dp[i] 存放最长子串的最后一个元素值（最大值）</li><li>如果当前元素比最大的那个子串的最后一个元素还要大，那就直接长度加一，新子串的最后一个元素为当前元素</li><li>如果当前元素比最大的那个子串的最后一个元素要小，那就要更新dp数组，保证每一个子串都是最优解，采用二分查找法，因为dp是严格递增的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; dp[maxL])&#123;</span><br><span class="line">                dp[++maxL]= nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">0</span>, right = maxL;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dp[mid] == nums[i])&#123;</span><br><span class="line">                        left = mid;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[mid] &lt; nums[i])&#123;</span><br><span class="line">                        left = left + <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right =  mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[left] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++maxL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis-1"><a href="#Complexity-Analysis-1" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n log n).</strong> </li><li><strong>Space complexity : O(1).</strong></li></ul><h3 id="Accepted-1"><a href="#Accepted-1" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence.</p><p><strong>Memory Usage</strong>: 36.3 MB, less than 57.53% of Java online submissions for Longest Increasing Subsequence.</p><p><img src="/picture/lc300_02.png" alt="lc300_02"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="DP" scheme="https://www.vazh.cn/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode120-三角形最小路径和</title>
    <link href="https://www.vazh.cn/2019/05/07/Leetcode120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://www.vazh.cn/2019/05/07/Leetcode120-三角形最小路径和/</id>
    <published>2019-05-07T03:23:52.000Z</published>
    <updated>2019-09-04T04:31:58.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; [</span><br><span class="line">&gt;      [2],</span><br><span class="line">&gt;     [3,4],</span><br><span class="line">&gt;    [6,5,7],</span><br><span class="line">&gt;   [4,1,8,3]</span><br><span class="line">&gt; ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><p><strong>说明：</strong></p><p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>动态规划题型，已知最佳路径，则最佳路径必定经过上一层的两个值中较小值</li><li>从倒数第二层开始遍历，用长度为n的整形数组a 统计当前层的每一列的最优长度</li><li>对当前层，对上一层每相邻的两个数据进行比对大小，将较小值加到a[j] 上，记录每一列的最优值</li><li>最后到第０层，取第一层中较小值加到a[0]上</li><li>返回最小值a[0]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">    <span class="comment">// 状态定义 dp[i][j] 包含 dp[i][j]的最小值</span></span><br><span class="line">    <span class="comment">// 地推方程 dp[i][j] = min&#123;dp[i + 1][j], dp[i + 1][j + 1] &#125; + nums[i][j]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (triangle == <span class="keyword">null</span> || triangle.get(<span class="number">0</span>) == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size(), n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            a[i] = triangle.get(n - <span class="number">1</span>).get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            List&lt;Integer&gt; cur = triangle.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                a[j] = a[j] &lt; a[j + <span class="number">1</span>] ? a[j]  : a[j + <span class="number">1</span>];</span><br><span class="line">                a[j] += cur.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n * n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 1 ms, faster than 99.94% of Java online submissions for Triangle.</p><p><strong>Memory Usage</strong>: 37.9 MB, less than 77.62% of Java online submissions for Triangle.</p><p><img src="/picture/lc120.png" alt="lc120"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://www.vazh.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode55-跳跃游戏</title>
    <link href="https://www.vazh.cn/2019/05/07/Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://www.vazh.cn/2019/05/07/Leetcode55-跳跃游戏/</id>
    <published>2019-05-07T03:23:07.000Z</published>
    <updated>2019-09-04T04:27:52.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [2,3,1,1,4]</span><br><span class="line">&gt; 输出: true</span><br><span class="line">&gt; 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [3,2,1,0,4]</span><br><span class="line">&gt; 输出: false</span><br><span class="line">&gt; 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>从后向前遍历，从倒数第二个点判断能否到达最后一个点</li><li>分两种情况，若可以，即nums[i] 大于i到终点距离(minEnd - i), 这时，将终点修改为当前点，因为当前点可达</li><li>若不可以，继续向前遍历，终点minEnd不变，继续寻找，最后若minEnd为起点0,则说明从起点到终点可达</li><li>返回　minEnd 等于0是否为真</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length, minEnd = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = minEnd; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= (minEnd - i)) &#123;</span><br><span class="line">                minEnd = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minEnd == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O( n).</strong> </li><li><strong>Space complexity : O(1).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 1 ms, faster than 99.93% of Java online submissions for Jump Game.</p><p><strong>Memory Usage</strong>: 41.4 MB, less than 16.44% of Java online submissions for Jump Game.</p><p><img src="/picture/lc55.png" alt="lc55"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="Array" scheme="https://www.vazh.cn/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode51-N皇后问题2</title>
    <link href="https://www.vazh.cn/2019/05/07/Leetcode51-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%982/"/>
    <id>https://www.vazh.cn/2019/05/07/Leetcode51-N皇后问题2/</id>
    <published>2019-05-07T02:52:41.000Z</published>
    <updated>2019-09-04T04:26:46.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="/picture/lc51_8-queens.png" alt="img"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: 4</span><br><span class="line">&gt; 输出: 2</span><br><span class="line">&gt; 解释: 4 皇后问题存在如下两个不同的解法。</span><br><span class="line">&gt; [</span><br><span class="line">&gt;  [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">&gt;   &quot;...Q&quot;,</span><br><span class="line">&gt;   &quot;Q...&quot;,</span><br><span class="line">&gt;   &quot;..Q.&quot;],</span><br><span class="line">&gt; </span><br><span class="line">&gt;  [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">&gt;   &quot;Q...&quot;,</span><br><span class="line">&gt;   &quot;...Q&quot;,</span><br><span class="line">&gt;   &quot;.Q..&quot;]</span><br><span class="line">&gt; ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到</li><li>采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放</li><li>利用checkPerRow函数，检测摆放皇后是否满足条件</li><li>若发现摆放的皇后不满足要求，则回退,　list删除刚摆放的不满足的皇后</li><li>若满足条件，则递归，将层数加一，若层数等于N,则将结果加一，即total++</li><li>返回全局变量total</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] rows = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       perRowQueen(<span class="number">0</span>, rows, n);</span><br><span class="line">       <span class="keyword">return</span> total;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">perRowQueen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[] rows, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (row &gt;= n) &#123;</span><br><span class="line">           total++;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           rows[row] = i;</span><br><span class="line">           <span class="keyword">if</span> (checkPerRow(row, rows)) &#123;</span><br><span class="line">               perRowQueen(row + <span class="number">1</span>, rows, n);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPerRow</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[] rows)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (rows[row] == rows[i] || Math.abs(row - i) == Math.abs(rows[row] - rows[i])) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n * n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 1 ms, faster than 97.11% of Java online submissions for N-Queens 2.</p><p><strong>Memory Usage</strong>: 31.7 MB, less than  100.00% of Java online submissions for N-Queens 2. </p><p><img src="/picture/lc52.png" alt="lc52"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="回溯法" scheme="https://www.vazh.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode52-N皇后问题2</title>
    <link href="https://www.vazh.cn/2019/05/07/Leetcode52-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%982/"/>
    <id>https://www.vazh.cn/2019/05/07/Leetcode52-N皇后问题2/</id>
    <published>2019-05-07T02:52:41.000Z</published>
    <updated>2019-09-04T04:27:47.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="/picture/lc51_8-queens.png" alt="img"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: 4</span><br><span class="line">&gt; 输出: 2</span><br><span class="line">&gt; 解释: 4 皇后问题存在如下两个不同的解法。</span><br><span class="line">&gt; [</span><br><span class="line">&gt;  [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">&gt;   &quot;...Q&quot;,</span><br><span class="line">&gt;   &quot;Q...&quot;,</span><br><span class="line">&gt;   &quot;..Q.&quot;],</span><br><span class="line">&gt; </span><br><span class="line">&gt;  [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">&gt;   &quot;Q...&quot;,</span><br><span class="line">&gt;   &quot;...Q&quot;,</span><br><span class="line">&gt;   &quot;.Q..&quot;]</span><br><span class="line">&gt; ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到</li><li>采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放</li><li>利用checkPerRow函数，检测摆放皇后是否满足条件</li><li>若发现摆放的皇后不满足要求，则回退,　list删除刚摆放的不满足的皇后</li><li>若满足条件，则递归，将层数加一，若层数等于N,则将结果加一，即total++</li><li>返回全局变量total</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] rows = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       perRowQueen(<span class="number">0</span>, rows, n);</span><br><span class="line">       <span class="keyword">return</span> total;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">perRowQueen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[] rows, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (row &gt;= n) &#123;</span><br><span class="line">           total++;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           rows[row] = i;</span><br><span class="line">           <span class="keyword">if</span> (checkPerRow(row, rows)) &#123;</span><br><span class="line">               perRowQueen(row + <span class="number">1</span>, rows, n);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPerRow</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[] rows)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (rows[row] == rows[i] || Math.abs(row - i) == Math.abs(rows[row] - rows[i])) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n * n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 1 ms, faster than 97.11% of Java online submissions for N-Queens 2.</p><p><strong>Memory Usage</strong>: 31.7 MB, less than  100.00% of Java online submissions for N-Queens 2. </p><p><img src="/picture/lc52.png" alt="lc52"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="回溯法" scheme="https://www.vazh.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode51-N皇后问题</title>
    <link href="https://www.vazh.cn/2019/05/07/Leetcode51-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>https://www.vazh.cn/2019/05/07/Leetcode51-N皇后问题/</id>
    <published>2019-05-07T02:45:32.000Z</published>
    <updated>2019-09-04T04:26:36.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="/picture/lc51_8-queens.png" alt="img"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: 4</span><br><span class="line">&gt; 输出: [</span><br><span class="line">&gt;  [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">&gt;   &quot;...Q&quot;,</span><br><span class="line">&gt;   &quot;Q...&quot;,</span><br><span class="line">&gt;   &quot;..Q.&quot;],</span><br><span class="line">&gt; </span><br><span class="line">&gt;  [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">&gt;   &quot;Q...&quot;,</span><br><span class="line">&gt;   &quot;...Q&quot;,</span><br><span class="line">&gt;   &quot;.Q..&quot;]</span><br><span class="line">&gt; ]</span><br><span class="line">&gt; 解释: 4 皇后问题存在两个不同的解法。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到</li><li>采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放</li><li>利用三个boolean数组分别对当前皇后的列，左上，右上进行判断（右上则横纵坐标和相等）</li><li>若发现摆放的皇后不满足要求，则回退，将boolean数组值复位（false）,list删除刚摆放的不满足的皇后</li><li>返回res</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">          helper(<span class="number">0</span>,　n,　<span class="keyword">new</span> <span class="keyword">boolean</span>[n],　<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>],　<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>],　<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> row,　<span class="keyword">int</span> n,　<span class="keyword">boolean</span>[] cols,　<span class="keyword">boolean</span>[] d1,　<span class="keyword">boolean</span>[] d2,　List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(row　==　n)&#123;</span><br><span class="line">              res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> col　=　<span class="number">0</span>;　col　&lt;　n;　col++)&#123;</span><br><span class="line">              <span class="keyword">int</span> d1Num　=　col　+　row;</span><br><span class="line">              <span class="keyword">int</span> d2Num　=　col　-　row　+　n　-　<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span>(!cols[col]　&amp;&amp;　!d1[d1Num]　&amp;&amp;!d2[d2Num])&#123;</span><br><span class="line">                  <span class="keyword">char</span>[] temp　=　<span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">                  Arrays.fill(temp,<span class="string">'.'</span>);</span><br><span class="line">                  temp[col]　=　<span class="string">'Q'</span>;</span><br><span class="line">                  cols[col]　=　<span class="keyword">true</span>;</span><br><span class="line">                  d1[d1Num]　=　<span class="keyword">true</span>;</span><br><span class="line">                  d2[d2Num]　=　<span class="keyword">true</span>;</span><br><span class="line">                  list.add(<span class="keyword">new</span> String(temp));</span><br><span class="line">                  helper(row　+　<span class="number">1</span>,　n,　cols,　d1,　d2,　list);</span><br><span class="line">                  cols[col]　=　<span class="keyword">false</span>;</span><br><span class="line">                  d1[d1Num]　=　<span class="keyword">false</span>;</span><br><span class="line">                  d2[d2Num]　=　<span class="keyword">false</span>;</span><br><span class="line">                  list.remove(list.size()　-　<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n * n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 2 ms, faster than 97.49% of Java online submissions for N-Queens.</p><p><strong>Memory Usage</strong>: 38.8 MB, less than 62.86% of Java online submissions for N-Queens.</p><p><img src="/picture/lc51.png" alt="lc51"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="回溯法" scheme="https://www.vazh.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-表、栈和队列</title>
    <link href="https://www.vazh.cn/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://www.vazh.cn/2019/05/05/数据结构与算法-表、栈和队列/</id>
    <published>2019-05-05T04:45:40.000Z</published>
    <updated>2019-05-05T04:46:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表、栈和队列"><a href="#表、栈和队列" class="headerlink" title="表、栈和队列"></a>表、栈和队列</h1><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><ul><li>介绍抽象数据类型的概念</li><li>阐述如何有效的执行表的操作</li><li>介绍栈ADT及其在实现递归方面的应用</li><li>介绍队列ADT及其在操作系统和算法设计中的应用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;表、栈和队列&quot;&gt;&lt;a href=&quot;#表、栈和队列&quot; class=&quot;headerlink&quot; title=&quot;表、栈和队列&quot;&gt;&lt;/a&gt;表、栈和队列&lt;/h1&gt;&lt;h2 id=&quot;本章重点&quot;&gt;&lt;a href=&quot;#本章重点&quot; class=&quot;headerlink&quot; title=&quot;本
      
    
    </summary>
    
      <category term="数据结构" scheme="https://www.vazh.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="https://www.vazh.cn/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://www.vazh.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode14-最长公共前缀</title>
    <link href="https://www.vazh.cn/2019/05/05/Leetcode14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://www.vazh.cn/2019/05/05/Leetcode14-最长公共前缀/</id>
    <published>2019-05-05T03:15:38.000Z</published>
    <updated>2019-09-04T02:54:27.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">&gt; 输出: &quot;fl&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">&gt; 输出: &quot;&quot;</span><br><span class="line">&gt; 解释: 输入不存在公共前缀。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>利用StringBuilder保存第一个字符串，然后分别对另外的n-1个字符串判断，是不是以match为前缀</li><li>使用startWith函数判断，并依次裁剪match直到match满足所有的字符串</li><li>返回match</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        StringBuilder match = <span class="keyword">new</span> StringBuilder(strs[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!strs[i].startsWith(match.toString())) &#123;</span><br><span class="line">                match.deleteCharAt(match.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (match.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 0 ms, faster than 100.00% of Java online submissions for Longest Common Prefix.</p><p><strong>Memory Usage</strong>: 38.8 MB, less than 20.63% of Java online submissions for Longest Common Prefix.</p><p><img src="/picture/lc14_01.png" alt="lc014"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="String" scheme="https://www.vazh.cn/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode01-两数之和</title>
    <link href="https://www.vazh.cn/2019/05/05/Leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://www.vazh.cn/2019/05/05/Leetcode01-两数之和/</id>
    <published>2019-05-05T03:14:36.000Z</published>
    <updated>2019-09-04T02:39:14.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">&gt; </span><br><span class="line">&gt; 因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">&gt; 所以返回 [0, 1]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>题目求解两个数之和等于目标数的数组下标</li><li>转化为将数字存放进哈希表，然后每一次检测目标数减去nums[i] (每一次数组遍历值)</li><li>若找到返回下标值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">                result[<span class="number">0</span>] = map.get(target-nums[i]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 3 ms, faster than 99.54% of Java online submissions for Two Sum.</p><p><strong>Memory Usage</strong>: 38.9 MB, less than 31.85% of Java online submissions for Two Sum.</p><p><img src="/picture/lc01_01.png" alt="lc01"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="HashTable" scheme="https://www.vazh.cn/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode122-买卖股票的最佳时机2</title>
    <link href="https://www.vazh.cn/2019/05/05/Leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2/"/>
    <id>https://www.vazh.cn/2019/05/05/Leetcode122-买卖股票的最佳时机2/</id>
    <published>2019-05-05T02:57:23.000Z</published>
    <updated>2019-09-04T04:32:10.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [7,1,5,3,6,4]</span><br><span class="line">&gt; 输出: 7</span><br><span class="line">&gt; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">&gt;      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [1,2,3,4,5]</span><br><span class="line">&gt; 输出: 4</span><br><span class="line">&gt; 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">&gt;      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">&gt;      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [7,6,4,3,1]</span><br><span class="line">&gt; 输出: 0</span><br><span class="line">&gt; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li>与上一题的买卖股票较为类似，不同的是可以重复购买</li><li>所以只需要计算相邻之间的差值，如果大于0，则累加，即是一次交易（上一次买入，这一次卖出）</li><li>返回数组大于零的累积和</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i] = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; <span class="number">0</span>)</span><br><span class="line">                res += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ul><li><strong>Time complexity : O(n).</strong> </li><li><strong>Space complexity : O(n).</strong></li></ul><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 1 ms, faster than 81.61% of Java online submissions for Buy and Sell Stock 2.</p><p><strong>Memory Usage</strong>: 38.6 MB, less than 56.12% of Java online submissions for Buy and Sell Stock 2.</p><p><img src="/picture/lc122.png" alt="lc122"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组，它的第 &lt;em&gt;i&lt;/em&gt;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="dp" scheme="https://www.vazh.cn/tags/dp/"/>
    
  </entry>
  
</feed>
