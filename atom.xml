<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elvis&#39;s Blogs</title>
  
  <subtitle>研一狗的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.vazh.cn/"/>
  <updated>2020-05-27T13:17:16.265Z</updated>
  <id>https://www.vazh.cn/</id>
  
  <author>
    <name>zkstyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis中字典hash的实现</title>
    <link href="https://www.vazh.cn/2020/05/27/Redis%E4%B8%AD%E5%AD%97%E5%85%B8hash%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.vazh.cn/2020/05/27/Redis中字典hash的实现/</id>
    <published>2020-05-27T13:12:13.000Z</published>
    <updated>2020-05-27T13:17:16.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis中字典的实现"><a href="#Redis中字典的实现" class="headerlink" title="Redis中字典的实现"></a>Redis中字典的实现</h1><p>redis由c语言编写,不含内置的字典数据结构，redis自己实现了字典数据结构，redis服务器中的数据库使用的底层数据结构就是字典，</p><p>哈希键在某些特定情况下也会使用字典作为底层设计。</p><p>（特定:哈希对象的编码可以是ziplist或hashtable，</p><p>　　1.哈希对象保存的所有键值对的键和值得字符串长度都小于64字节，</p><p>　　2.哈希对象保存的键值对数量小于512个， 不能满足这两个条件的哈希对象使用hashtable编码）</p><hr><h2 id="1-哈希表与哈希节点的关系"><a href="#1-哈希表与哈希节点的关系" class="headerlink" title="1.哈希表与哈希节点的关系:"></a><strong>1.哈希表与哈希节点的关系:</strong></h2><p>Redis字典由哈希表构成，哈希表由哈希节点构成. 参考源码 dict.h</p><p><img src="https://img2018.cnblogs.com/i-beta/1555259/202002/1555259-20200201135904304-758245244.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/i-beta/1555259/202002/1555259-20200201142148557-1357932462.png" alt="img"></p><p> 图1-1所示结构，为一个初始大小为4的空的哈希表.</p><p>此时假设向其中存入键值对A,保存后如图1-2所示,具体如何保存到索引位置上,后文有写.</p><p><img src="https://img2018.cnblogs.com/i-beta/1555259/202002/1555259-20200201143020104-198748142.png" alt="img"></p><hr><h2 id="2-Redis字典与哈希表、哈希节点的关系"><a href="#2-Redis字典与哈希表、哈希节点的关系" class="headerlink" title="2.Redis字典与哈希表、哈希节点的关系"></a><strong>2.Redis字典与哈希表、哈希节点的关系</strong></h2><p><img src="https://img2018.cnblogs.com/i-beta/1555259/202002/1555259-20200201143956895-109116658.png" alt="img"></p><p> 字典中ht保存了两个哈希表,一般情况下,字典使用ht[0]哈希表,h[1]哈希表只有在对ht[0]rehash时使用.rehashidx通常为-1,如果正在进行rehash，则值大于-1.</p><p>type指向的dictType结构提供了特定类型的函数，privdata为特定类型函数的可选参数. 比如计算键的哈希值时,使用hash=dict-&gt;type-&gt;hashfunction(key);</p><p><img src="https://img2018.cnblogs.com/i-beta/1555259/202002/1555259-20200201145059486-1092357854.png" alt="img"></p><p> 如图1-3 为一个字典的结构，字典中保存了一个元素。</p><hr><h2 id="3-如何将元素添加到Redis字典中"><a href="#3-如何将元素添加到Redis字典中" class="headerlink" title="3.如何将元素添加到Redis字典中"></a><strong>3.如何将元素添加到Redis字典中</strong></h2><p>　　元素A是如何保存的， 计算元素A的哈希值 ：hash = dict-&gt;type-&gt;hashfunction(元素A的key) </p><p>　　通过哈希表中的sizemask与hash值，计算出索引值 : index = hash &amp; dict-&gt;ht[0].sizemask （不发生rehash时,为ht[0],发生rehash时,可能为ht[0]或ht[1]），</p><p>　　若此时再加入元素B，且元素B最终计算出的索引值与元素A相同，则将B插入A的前面。如图1-4</p><p><img src="https://img2018.cnblogs.com/i-beta/1555259/202002/1555259-20200201152206268-1570060747.png" alt="img"></p><p>Redis将字典作为数据库底层实现时，使用的Murmurhash计算键的哈希值。</p><hr><h2 id="4-rehash的执行"><a href="#4-rehash的执行" class="headerlink" title="4.rehash的执行"></a><strong>4.rehash的执行</strong></h2><h3 id="1-何时开始rehash操作"><a href="#1-何时开始rehash操作" class="headerlink" title="1)何时开始rehash操作"></a><em>1)何时开始rehash操作</em></h3><p>　　字典中的哈希表随着保存元素越来越多，当负载因子load_factor = ht[0].used / ht[0].size 满足某些值时,开始对哈希表执行扩展操作</p><p>　　具体情况如下：</p><p>　　　　a.redis服务器目前正在进行BGSAVE 或BGREWRITEAOF命令,则load_factor的负载因子大于等于5，则开始扩展</p><p>　　　　b.redis服务器没有进行BGSAVE 或BGREWRITEAOF命令,则load_factor的负载因子大于等于1,则开始扩展</p><p>　　服务器进行BGSAVE或BGREWRITEAOF命令时，创建子进程执行命令，此时采用写时复制技术优化子进程效率，所以此时负载因子调大，避免执行扩展操作，节约内存。</p><h3 id="2-rehash流程"><a href="#2-rehash流程" class="headerlink" title="2)rehash流程"></a><em>2)rehash流程</em></h3><p>　　a.当rehash执行扩容时,为ht[1]分配空间，具体分配多大空间呢? ht[1]的大小为第一个大于等于ht[0].used x 2的2的n次幂 举个栗子：此时used 为 8，则扩容应分配16＜= 2的n次幂 所以16就满足。</p><p> 　 当rehash执行收缩时,分配空间为 h[1]的大小为第一个大于等于ht[0].used的2的n次幂　　举个栗子：此时used为8，则2的3次幂就满足要求 ，即ht[1]空间为8</p><p>　　b.空间分配之后，就是元素的重新哈希，将h[0]中的元素 重新哈希计算 添加到h[1]中，并且从h[0]中删除</p><p>　　c.全部元素都迁移完成后释放ht[0]，将ht[1]设置为ht[0],并在ht[1]重新创建一个空白哈希表，为下一次hash做准备</p><h3 id="3-rehash并不是一次就完成的"><a href="#3-rehash并不是一次就完成的" class="headerlink" title="3)rehash并不是一次就完成的"></a><em>3)rehash并不是一次就完成的</em></h3><p>　　rehash操作如果一次处理几百万个 几千万个 或更多的键值对，那服务器就不用干别的了，这段时间都没得服务了。避免这种大批量的rehash，</p><p>　　redis采用渐进式，一次太多，那就分多次，还记得那个rehashidx吧，平时闲着为-1，开始rehash后，rehashid设置为0，标志着从ht[0]哈希表的索引0开始进行rehash。</p><p>　　索引0上的键值对都rehash完成后，rehashidx值＋1.继续下一索引值的rehash。</p><p>　　so完成的rehash过程 ：</p><p>　　　    a.为ht[1]分配空间</p><p>　　　　b.将rehashidx设置为0，开始rehash</p><p>　　　　c.rehash期间，对字典的CRUD操作 还会顺带将rehashidx索引上的键值对rehash到ht[1]上.（新键值对的添加只会在ht[1]上操作，其余操作会在两个哈希表都进行操作）</p><p>　　　　d.随着操作不断进行,某个时间点全部rehash结束,将rehashidx值设置为-1,表示完成这次rehash。</p><p>　　分而治之的渐进式rehash避免了集中式rehash带来的巨大计算量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis中字典的实现&quot;&gt;&lt;a href=&quot;#Redis中字典的实现&quot; class=&quot;headerlink&quot; title=&quot;Redis中字典的实现&quot;&gt;&lt;/a&gt;Redis中字典的实现&lt;/h1&gt;&lt;p&gt;redis由c语言编写,不含内置的字典数据结构，redis自己实现了
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="redis" scheme="https://www.vazh.cn/tags/redis/"/>
    
      <category term="字典" scheme="https://www.vazh.cn/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇(六):LinkedTransferQueue</title>
    <link href="https://www.vazh.cn/2020/05/17/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E5%85%AD-LinkedTransferQueue/"/>
    <id>https://www.vazh.cn/2020/05/17/JUC源码分析-集合篇-六-LinkedTransferQueue/</id>
    <published>2020-05-17T01:04:03.000Z</published>
    <updated>2020-05-21T16:19:09.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC源码分析-集合篇（六）：LinkedTransferQueue"><a href="#JUC源码分析-集合篇（六）：LinkedTransferQueue" class="headerlink" title="JUC源码分析-集合篇（六）：LinkedTransferQueue"></a>JUC源码分析-集合篇（六）：LinkedTransferQueue</h1><blockquote><p>LinkedTransferQueue 是<strong>单向链表结构的无界阻塞队列</strong>， 从JDK1.7开始加入到J.U.C的行列中。通过 CAS 和 LockSupport 实现线程安全，元素操作按照 <strong>FIFO</strong> (first-in-first-out 先入先出) 的顺序。内存一致性遵循<strong>对LinkedTransferQueue的插入操作先行发生于(happen-before)访问或移除操作</strong>。相对于其他传统 Queue，LinkedTransferQueue 有它独特的性质，本章将对其进行详细的讲解。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>LinkedTransferQueue（后称LTQ） 采用一种预占模式。意思就是消费者线程取元素时，如果队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。我们称这种节点操作为“匹配”方式。</p></blockquote><p>LTQ的算法实现可以总结为以下几点：</p><ul><li><strong>双重队列</strong>：<br>和典型的单向链表结构不同，LTQ 的 Node 存储了一个<code>isData</code>的 boolean 型字段，也就是说它的节点可以代表一个数据或者是一个请求，称为<strong>双重队列（Dual Queue）</strong>。上面说过，在消费者获取元素时，如果队列为空，当前消费者就会作为一个“元素为null”的节点被放入队列中等待，所以 LTQ中 的节点存储了生产者节点（item不为null）和消费者节点（item为null），这两种节点就是通过<code>isData</code>来区分的。</li><li><strong>松弛度</strong>：<br>为了节省 CAS 操作的开销，LTQ 引入了“松弛度”的概念：在节点被匹配（被删除）之后，不会立即更新head/tail，而是当 head/tail 节点和最近一个未匹配的节点之间的距离超过一个“<strong>松弛阀值</strong>”之后才会更新（在 LTQ 中，这个值为 2）。这个“松弛阀值”一般为1-3，如果太大会降低缓存命中率，并且会增加遍历链的长度；太小会增加 CAS 的开销。</li><li><strong>节点自链接</strong>：<br>已匹配节点的 next 引用会指向自身。<br>如果GC延迟回收，已删除节点链会积累的很长，此时垃圾收集会耗费高昂的代价，并且所有刚匹配的节点也不会被回收。为了避免这种情况，我们在 CAS 向后推进 head 时，会把已匹配的 head 的”next”引用指向自身（即“<strong>自链接节点</strong>”），这样就限制了连接已删除节点的长度（我们也采取类似的方法，清除在其他节点字段中可能的垃圾保留值）。如果在遍历时遇到一个自链接节点，那就表明当前线程已经滞后于另外一个更新 head 的线程，此时就需要重新获取 head 来遍历。</li></ul><p>所以，在 LTQ 中，数据在某个线程的“某一时刻”可能存在下面这种形式：</p><p><img src="https://upload-images.jianshu.io/upload_images/6050820-6afec565cfff223f.png?imageMogr2/auto-orient/strip|imageView2/2/w/859/format/webp" alt="img"></p><p>LinkedTransferQueue 数据形式</p><p><strong>unmatched node</strong>：未被匹配的节点。可能是一个生产者节点（item不为null），也可能是一个消费者节点（item为null）。<br><strong>matched node</strong>：已经被匹配的节点。可能是一个生产者节点（item不为null）的数据已经被一个消费者拿走；也可能是一个消费者节点（item为null）已经被一个生产者填充上数据。</p><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/6050820-1514eb965ce72781.png?imageMogr2/auto-orient/strip|imageView2/2/w/855/format/webp" alt="img"></p><p>LinkedTransferQueue 继承关系</p><p>LTQ 继承自AbstractQueue，支持传统Queue的所有操作；实现了 TransferQueue 接口，并且是 TransferQueue 的唯一实现，TransferQueue 定义了一种“预占模式”，允许消费者在节点上等待，直到生产者把元素放入节点。</p><hr><h4 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列头节点，第一次入列之前为空</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列尾节点，第一次添加节点之前为空</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//累计到一定次数再清除无效node</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sweepVotes;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当一个节点是队列中的第一个waiter时，在多处理器上进行自旋的次数(随机穿插调用thread.yield)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRONT_SPINS   = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前继节点正在处理，当前节点在阻塞之前的自旋次数，也为FRONT_SPINS</span></span><br><span class="line"><span class="comment">// 的位变化充当增量，也可在自旋时作为yield的平均频率</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sweepVotes的阀值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SWEEP_THRESHOLD = <span class="number">32</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Possible values for "how" argument in xfer method.</span></span><br><span class="line"><span class="comment"> * xfer方法类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOW   = <span class="number">0</span>; <span class="comment">// for untimed poll, tryTransfer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC = <span class="number">1</span>; <span class="comment">// for offer, put, add</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC  = <span class="number">2</span>; <span class="comment">// for transfer, take</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMED = <span class="number">3</span>; <span class="comment">// for timed poll, tryTransfer</span></span><br></pre></td></tr></table></figure><p>这里我们重点说一下<strong>sweepVotes</strong>这个属性，其他的都很简单，就不一一介绍了。</p><p>上面我们提到，head/tail 节点并不是及时更新的，在并发操作时链表内部可能存在已匹配节点，此时就需要一个阀值来决定何时清除已匹配的内部节点链，这就是<code>sweepVotes</code>和<code>SWEEP_THRESHOLD</code>的作用。</p><p>我们通过节点自链接的方式来减少垃圾滞留，同样也会解除内部已移除节点的链接。在匹配超时、线程中断或调用<code>remove</code>时，这也些节点也会被清除（解除链接）。例如，在某一时刻有一个节点 s 已经被移除，我们可以通过 CAS 修改 s 的前继节点的 next 引用的方式来解除 s 的链接。 但是有两种情况并不能保证节点 s 被解除链接：<br>\1. 如果 s 节点是一个 next 为 null 的节点（trailing node），但是它被作为入列时的目标节点，所以只有在其他节点入列之后才能移除它<br>\2. 通过给定 s 的前继节点，不一定会移除 s 节点：因为前继节点有可能已经被解除链接，这种情况下前继节点的前继节点有可能指向了s。</p><p>所以，通过这两点，说明在 s 节点或它的前继节点已经出列时，并不是必须要移除它们。对于这些情况，我们记录了一个解除节点链接失败的值-<strong>sweepVotes</strong>，并且为其定义了一个阀值-<strong>SWEEP_THRESHOLD</strong>，当解除链接失败次数超过这个阀值时就会对队列进行一次“大扫除”（通过<code>sweep()</code>方法），解除所有已取消的节点链接。</p><p><strong>xfer方法类型</strong>：<br>在 LTQ 中，所有的入队/出队操作都是通过<code>xfer</code>方法来控制，并且通过一个类型区分<code>offer, put, poll, take, transfer</code>，这样做大大简化了代码。来看一下<code>xfer</code>的方法类型：<br><code>NOW</code>：不等待，直接返回匹配结果。用在<code>poll, tryTransfer</code>中。<br><code>ASYNC</code>：异步操作，直接把元素添加到队列尾，不等待匹配。用在<code>offer, put, add</code>中。<br><code>SYNC</code>：等待元素被消费者接收。用在<code>transfer, take</code>中。<br><code>TIMED</code>：附带超时时间的<code>NOW</code>，等待指定时间后返回匹配结果。用在附带超时时间的<code>poll, tryTransfer</code>中。</p><hr><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>由于 LTQ 的入列/出列方法都是由<code>xfer</code>来实现，所以我们这里只对<code>xfer</code>进行解析。</p><h2 id="xfer-E-e-boolean-haveData-int-how-long-nanos"><a href="#xfer-E-e-boolean-haveData-int-how-long-nanos" class="headerlink" title="xfer(E e, boolean haveData, int how, long nanos)"></a>xfer(E e, boolean haveData, int how, long nanos)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements all queuing methods. See above for explanation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the item or null for take</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> haveData true if this is a put, else a take</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> how NOW, ASYNC, SYNC, or TIMED</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos timeout in nanosecs, used only if mode is TIMED</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an item if matched, else e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if haveData mode but e is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line">        <span class="comment">//从head开始向后匹配</span></span><br><span class="line">        <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">            <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">            Object item = p.item;</span><br><span class="line">            <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; <span class="comment">// 找到有效节点，进入匹配</span></span><br><span class="line">                <span class="keyword">if</span> (isData == haveData)   <span class="comment">//节点与此次操作模式一致，无法匹配 can't match</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// 匹配成功，cas修改为指定元素 match</span></span><br><span class="line">                    <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                        Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                        <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;<span class="comment">//更新head为匹配节点的next节点</span></span><br><span class="line">                            h.forgetNext();<span class="comment">//旧head节点指向自身等待回收</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;                 <span class="comment">// cas失败，重新获取head  advance and retry</span></span><br><span class="line">                        <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())<span class="comment">//如果head的next节点未被匹配，跳出循环，不更新head，也就是松弛度&lt;2</span></span><br><span class="line">                            <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    LockSupport.unpark(p.waiter);<span class="comment">//唤醒在节点上等待的线程</span></span><br><span class="line">                    <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//匹配失败，继续向后查找节点</span></span><br><span class="line">            Node n = p.next;</span><br><span class="line">            p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//未找到匹配节点，把当前节点加入到队列尾</span></span><br><span class="line">        <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">            <span class="comment">//将新节点s添加到队列尾并返回s的前继节点</span></span><br><span class="line">            Node pred = tryAppend(s, haveData);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span> retry;           <span class="comment">//与其他不同模式线程竞争失败重新循环 lost race vs opposite mode</span></span><br><span class="line">            <span class="keyword">if</span> (how != ASYNC)<span class="comment">//同步操作，等待匹配</span></span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：<code>xfer</code>的基本流程如下：</p><ol><li>从head开始向后匹配，找到一个节点模式跟本次操作的模式不同的未匹配的节点（生产或消费）进行匹配；</li><li>匹配节点成功 CAS 修改匹配节点的 item 为给定元素 e；</li><li>如果此时所匹配节点向后移动，则 CAS 更新 head 节点为匹配节点的 next 节点，旧 head 节点链接指向自身等待被回收（<code>forgetNext()</code>方法）；如果CAS 失败，并且松弛度大于等于2，就需要重新获取 head 重试。</li><li>匹配成功，唤醒匹配节点 p 的等待线程 <code>waiter</code>，返回匹配的 item。</li><li>如果在上述操作中没有找到匹配节点，则根据参数<code>how</code>做不同的处理：<br>NOW：立即返回。<br>SYNC：通过<code>tryAppend</code>方法插入一个新的节点 s(<code>item=e,isData = haveData</code>)到队列尾，然后自旋或阻塞当前线程直到节点被匹配或者取消返回。<br>ASYNC：通过<code>tryAppend</code>方法插入一个新的节点 s(<code>item=e,isData = haveData</code>)到队列尾，异步直接返回。<br>TIMED：通过<code>tryAppend</code>方法插入一个新的节点 s(<code>item=e,isData = haveData</code>)到队列尾，然后自旋或阻塞当前线程直到节点被匹配或者取消或等待超时返回。</li></ol><h3 id="tryAppend-Node-s-boolean-haveData"><a href="#tryAppend-Node-s-boolean-haveData" class="headerlink" title="tryAppend(Node s, boolean haveData)"></a>tryAppend(Node s, boolean haveData)</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to append node s as tail.</span></span><br><span class="line"><span class="comment"> * 尝试添加给定节点s作为尾节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s the node to append</span></span><br><span class="line"><span class="comment"> * @param haveData true if appending in data mode</span></span><br><span class="line"><span class="comment"> * @return null on failure due to losing race with append in</span></span><br><span class="line"><span class="comment"> * different mode, else s's predecessor, or s itself if no</span></span><br><span class="line"><span class="comment"> * predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private Node tryAppend(Node s, boolean haveData) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail, p = t;;) &#123;        <span class="comment">// move p to last node and append</span></span><br><span class="line">        Node n, u;                        <span class="comment">// temps for reads of next &amp; tail</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123;<span class="comment">//head和tail都为null</span></span><br><span class="line">            <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s))<span class="comment">//修改head为新节点s</span></span><br><span class="line">                <span class="keyword">return</span> s;                 <span class="comment">// initialize</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;                  <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.next) != <span class="keyword">null</span>)    <span class="comment">// not last; keep traversing</span></span><br><span class="line">            p = p != t &amp;&amp; t != (u = tail) ? (t = u) : <span class="comment">// stale tail</span></span><br><span class="line">                (p != n) ? n : <span class="keyword">null</span>;      <span class="comment">// restart if off list</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">            p = p.next;                   <span class="comment">// re-read on CAS failure</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != t) &#123;                 <span class="comment">// update if slack now &gt;= 2</span></span><br><span class="line">                <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                       (t = tail)   != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                       (s = t.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                       (s = s.next) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：添加给定节点 s 到队列尾并返回 s 的前继节点，失败时（与其他不同模式线程竞争失败）返回null，没有前继节点返回自身。</p><h3 id="awaitMatch-Node-s-Node-pred-E-e-boolean-timed-long-nanos"><a href="#awaitMatch-Node-s-Node-pred-E-e-boolean-timed-long-nanos" class="headerlink" title="awaitMatch(Node s, Node pred, E e, boolean timed, long nanos)"></a>awaitMatch(Node s, Node pred, E e, boolean timed, long nanos)</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spins/yields/blocks until node s is matched or caller gives up.</span></span><br><span class="line"><span class="comment"> * 自旋/让步/阻塞,直到给定节点s匹配到或放弃匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s the waiting node</span></span><br><span class="line"><span class="comment"> * @param pred the predecessor of s, or s itself if it has no</span></span><br><span class="line"><span class="comment"> * predecessor, or null if unknown (the null case does not occur</span></span><br><span class="line"><span class="comment"> * in any current calls but may in possible future extensions)</span></span><br><span class="line"><span class="comment"> * @param e the comparison value for checking match</span></span><br><span class="line"><span class="comment"> * @param timed if true, wait only until timeout elapses</span></span><br><span class="line"><span class="comment"> * @param nanos timeout in nanosecs, used only if timed is true</span></span><br><span class="line"><span class="comment"> * @return matched item, or e if unmatched on interrupt or timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) &#123;</span><br><span class="line">    <span class="keyword">final</span> long deadline = timed ? System.nanoTime() + nanos : <span class="number">0</span>L;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">//在首个item和取消检查后初始</span></span><br><span class="line">    <span class="built_in">int</span> spins = <span class="number">-1</span>; <span class="comment">// initialized after first item and cancel checks</span></span><br><span class="line">    ThreadLocalRandom randomYields = <span class="keyword">null</span>; <span class="comment">// bound if needed</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">Object</span> item = s.item;</span><br><span class="line">        <span class="keyword">if</span> (item != e) &#123;                  <span class="comment">//matched</span></span><br><span class="line">            <span class="comment">// assert item != s;</span></span><br><span class="line">            s.forgetContents();           <span class="comment">// avoid garbage</span></span><br><span class="line">            <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">                s.casItem(e, s)) &#123;        <span class="comment">//取消匹配，item指向自身 cancel</span></span><br><span class="line">            unsplice(pred, s);<span class="comment">//解除s节点和前继节点的链接</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) &#123;                  <span class="comment">// establish spins at/near front</span></span><br><span class="line">            <span class="keyword">if</span> ((spins = spinsFor(pred, s.isData)) &gt; <span class="number">0</span>)</span><br><span class="line">                randomYields = ThreadLocalRandom.current();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;             <span class="comment">// spin</span></span><br><span class="line">            --spins;</span><br><span class="line">            <span class="keyword">if</span> (randomYields.nextInt(CHAINED_SPINS) == <span class="number">0</span>)</span><br><span class="line">                Thread.<span class="keyword">yield</span>();           <span class="comment">//不定期让步，给其他线程执行机会 occasionally yield</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.waiter = w;                 <span class="comment">// request unpark then recheck</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：当前操作为同步操作时，会调用<code>awaitMatch</code>方法阻塞等待匹配，成功返回匹配节点 item，失败返回给定参数e（s.item）。在等待期间如果线程被中断或等待超时，则取消匹配，并调用<code>unsplice</code>方法解除节点<code>s</code>和其前继节点的链接。</p><p>### </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unsplices (now or later) the given deleted/cancelled node with</span></span><br><span class="line"><span class="comment"> * the given predecessor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解除给定已经被删除/取消节点和前继节点的链接（可能延迟解除）</span></span><br><span class="line"><span class="comment"> * @param pred a node that was at one time known to be the</span></span><br><span class="line"><span class="comment"> * predecessor of s, or null or s itself if s is/was at head</span></span><br><span class="line"><span class="comment"> * @param s the node to be unspliced</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> unsplice(Node pred, Node s) &#123;</span><br><span class="line">    s.forgetContents(); <span class="comment">// forget unneeded fields</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; pred != s &amp;&amp; pred.next == s) &#123;</span><br><span class="line">        Node n = s.next;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span> ||</span><br><span class="line">            (n != s &amp;&amp; pred.casNext(s, n) &amp;&amp; pred.isMatched())) &#123;<span class="comment">//解除s节点的链接</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;               <span class="comment">// check if at, or could be, head</span></span><br><span class="line">                Node h = head;</span><br><span class="line">                <span class="keyword">if</span> (h == pred || h == s || h == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span>;          <span class="comment">// at head or list empty</span></span><br><span class="line">                <span class="keyword">if</span> (!h.isMatched())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                Node hn = h.next;</span><br><span class="line">                <span class="keyword">if</span> (hn == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span>;          <span class="comment">// now empty</span></span><br><span class="line">                <span class="keyword">if</span> (hn != h &amp;&amp; casHead(h, hn))<span class="comment">//更新head</span></span><br><span class="line">                    h.forgetNext();  <span class="comment">// advance head</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pred.next != pred &amp;&amp; s.next != s) &#123; <span class="comment">// recheck if offlist</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;           <span class="comment">// sweep now if enough votes</span></span><br><span class="line">                    <span class="built_in">int</span> v = sweepVotes;</span><br><span class="line">                    <span class="keyword">if</span> (v &lt; SWEEP_THRESHOLD) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (casSweepVotes(v, v + <span class="number">1</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (casSweepVotes(v, <span class="number">0</span>)) &#123;<span class="comment">//达到阀值，进行"大扫除"，清除队列中的无效节点</span></span><br><span class="line">                        sweep();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：首先把给定节点<code>s</code>的next引用指向自身，如果<code>s</code>的前继节点<code>pred</code>还是指向<code>s</code>（<code>pred.next == s</code>），尝试解除<code>s</code>的链接，把<code>pred</code>的 next 引用指向<code>s</code>的 next 节点。如果<code>s</code>不能被解除（由于它是尾节点或者<code>pred</code>可能被解除链接，并且<code>pred</code>和<code>s</code>都不是<code>head</code>节点或已经出列），则添加到<code>sweepVotes</code>，<code>sweepVotes</code>累计到阀值<code>SWEEP_THRESHOLD</code>之后就调用<code>sweep()</code>对队列进行一次“大扫除”，清除队列中所有的无效节点。<code>sweep()</code>源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks matched (typically cancelled) nodes encountered in a</span></span><br><span class="line"><span class="comment"> * traversal from head.</span></span><br><span class="line"><span class="comment"> * 解除(通常是取消)从头部遍历时遇到的已经被匹配的节点的链接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sweep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node p = head, s, n; p != <span class="literal">null</span> &amp;&amp; (s = p.next) != <span class="literal">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.isMatched())</span><br><span class="line">            <span class="comment">// Unmatched nodes are never self-linked</span></span><br><span class="line">            p = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n = s.next) == <span class="literal">null</span>) <span class="comment">// trailing node is pinned</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == n)    <span class="comment">// stale</span></span><br><span class="line">            <span class="comment">// No need to also check for p == s, since that implies s == n</span></span><br><span class="line">            p = head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.casNext(s, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章重点：理解 LinkedTransferQueue 的特性：<strong>双重队列、松弛度、节点的移除操作。</strong><br>在 ConcurrentLinkedQueue 、 ConcurrentLinkeDeque 以及 SynchronousQueue 中都用到了 LinkedTransferQueue 的某些特性，如果同学们对它们感兴趣，理解本章对之后的源码解析会有很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC源码分析-集合篇（六）：LinkedTransferQueue&quot;&gt;&lt;a href=&quot;#JUC源码分析-集合篇（六）：LinkedTransferQueue&quot; class=&quot;headerlink&quot; title=&quot;JUC源码分析-集合篇（六）：LinkedTra
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="LinkedTransferQueue" scheme="https://www.vazh.cn/tags/LinkedTransferQueue/"/>
    
  </entry>
  
  <entry>
    <title>秒杀设计小结</title>
    <link href="https://www.vazh.cn/2020/05/12/%E7%A7%92%E6%9D%80%E8%AE%BE%E8%AE%A1%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.vazh.cn/2020/05/12/秒杀设计小结/</id>
    <published>2020-05-12T11:39:05.000Z</published>
    <updated>2020-05-14T05:15:43.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秒杀设计"><a href="#秒杀设计" class="headerlink" title="秒杀设计"></a>秒杀设计</h1><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>然一次性解决会有问题，那就分多次解决！简单的描主要两个接口　OrderSeckillService商品秒杀查询服务接口　用于查询秒杀结果　电话+秒杀订单号作为查询采纳数　SpikeCommodityService秒杀商品接口　有两个方法　spike方法是秒杀商品接口　addSpikeToken用于生成秒杀库存数量的令牌　基于令牌桶实现秒杀　 新增对应商品库存令牌桶　秒杀高并发方案　提前生成好token拿到token意味抢购成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderSeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getOrder"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">getOrder</span><span class="params">(String phone, Long seckillId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpikeCommodityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户秒杀接口 phone和userid都可以的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@phone</span> 手机号码&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@seckillId</span> 库存id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/spike"</span>)然一次性解决会有问题，那就分多次解决！简单的描</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">spike</span><span class="params">(String phone, Long seckillId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增对应商品库存令牌桶　秒杀高并发方案　提前生成好token拿到token意味抢购成功</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@seckillId</span> 商品库存id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/addSpikeToken"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">addSpikeToken</span><span class="params">(Long seckillId, Long tokenQuantity)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>查询秒杀结果　查询参数手机号+秒杀订单号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSeckillServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseApiService</span>&lt;<span class="title">JSONObject</span>&gt; <span class="keyword">implements</span> <span class="title">OrderSeckillService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">getOrder</span><span class="params">(String phone, Long seckillId)</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;查询秒杀结果线程名称:"</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(phone)) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"手机号码不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (seckillId == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"商品库存id不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">OrderEntity orderEntity = orderMapper.findByOrder(phone, seckillId);</span><br><span class="line"><span class="keyword">if</span> (orderEntity == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"正在排队中....."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> setResultSuccess(<span class="string">"恭喜你秒杀成功!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>秒杀商品实现　主要实现两个方法　spike方法　主要实现多用户争夺令牌桶中的令牌　若获得了token则秒杀成功　addSpikeToken方法异步生成令牌　参数为seckill_id和tokenQuantity　分别是商品标识id与秒杀数量库存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpikeCommodityServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseApiService</span>&lt;<span class="title">JSONObject</span>&gt; <span class="keyword">implements</span> <span class="title">SpikeCommodityService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SeckillMapper seckillMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GenerateToken generateToken;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SpikeCommodityProducer spikeCommodityProducer;</span><br><span class="line"><span class="comment">// 每秒时间存入令牌桶中Token为1个 1s/1r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解 AOP 减少代码重复调用 使用网关开启限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"spikeFallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">spike</span><span class="params">(String phone, Long seckillId)</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">"###&gt;&gt;&gt;&gt;&gt;秒杀接口线程池名称:"</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="comment">// 1.参数验证</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(phone)) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"手机号码不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (seckillId == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"商品库存id不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.从redis从获取对应的秒杀token</span></span><br><span class="line">String seckillToken = generateToken.getListKeyToken(seckillId + <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(seckillToken)) &#123;</span><br><span class="line">log.info(<span class="string">"&gt;&gt;&gt;seckillId:&#123;&#125;, 亲，该秒杀已经售空，请下次再来!"</span>, seckillId);</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"亲，该秒杀已经售空，请下次再来!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取到秒杀token之后，异步放入mq中实现修改商品的库存</span></span><br><span class="line">sendSeckillMsg(seckillId, phone);</span><br><span class="line"><span class="keyword">return</span> setResultSuccess(<span class="string">"正在排队中......."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BaseResponse&lt;JSONObject&gt; <span class="title">spikeFallback</span><span class="params">(String phone, Long seckillId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"服务器忙,请稍后重试!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取到秒杀token之后，异步放入mq中实现修改商品的库存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendSeckillMsg</span><span class="params">(Long seckillId, String phone)</span> </span>&#123;</span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">"seckillId"</span>, seckillId);</span><br><span class="line">jsonObject.put(<span class="string">"phone"</span>, phone);</span><br><span class="line">spikeCommodityProducer.send(jsonObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结业项目中采用rabbitmq实现秒杀</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试官 都喜欢问 你们项目中在那些地方使用到多线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> seckillId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tokenQuantity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用redis数据库类型为 list类型 key为 商品库存id list 多个秒杀token</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">addSpikeToken</span><span class="params">(Long seckillId, Long tokenQuantity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.验证参数lingpai</span></span><br><span class="line"><span class="keyword">if</span> (seckillId == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"商品库存id不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tokenQuantity == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"token数量不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">SeckillEntity seckillEntity = seckillMapper.findBySeckillId(seckillId);</span><br><span class="line"><span class="keyword">if</span> (seckillEntity == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"商品信息不存在!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用多线程异步生产令牌</span></span><br><span class="line">createSeckillToken(seckillId, tokenQuantity);</span><br><span class="line"><span class="keyword">return</span> setResultSuccess(<span class="string">"令牌正在生成中....."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSeckillToken</span><span class="params">(Long seckillId, Long tokenQuantity)</span> </span>&#123;</span><br><span class="line">generateToken.createListToken(<span class="string">"seckill_"</span>, seckillId + <span class="string">""</span>, tokenQuantity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="秒杀生产者与消费者"><a href="#秒杀生产者与消费者" class="headerlink" title="秒杀生产者与消费者"></a>秒杀生产者与消费者</h2><p>生产者　将秒杀成功的用户信息投递到mq中　供消费者消费　异步修改数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpikeCommodityProducer</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(JSONObject jsonObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String jsonString = jsonObject.toJSONString();</span><br><span class="line">        System.out.println(<span class="string">"jsonString:"</span> + jsonString);</span><br><span class="line">        String messAgeId = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 封装消息</span></span><br><span class="line">        Message message = MessageBuilder.withBody(jsonString.getBytes())</span><br><span class="line">                .setContentType(MessageProperties.CONTENT_TYPE_JSON).setContentEncoding(<span class="string">"utf-8"</span>).setMessageId(messAgeId)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 构建回调返回的数据（消息id）</span></span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(jsonString);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"modify_exchange_name"</span>, <span class="string">"modifyRoutingKey"</span>, message, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产消息确认机制 生产者往服务器端发送消息的时候，采用应答机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String jsonString = correlationData.getId();</span><br><span class="line">        System.out.println(<span class="string">"消息id:"</span> + correlationData.getId());</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">"&gt;&gt;&gt;使用MQ消息确认机制确保消息一定要投递到MQ中成功"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(jsonString);</span><br><span class="line">        <span class="comment">// 生产者消息投递失败的话，采用递归重试机制</span></span><br><span class="line">        send(jsonObject);</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;&gt;使用MQ消息确认机制投递到MQ中失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者消费信息　获取秒杀id 查询商品信息　若没有则返回　然后修改商品库存　cas并发加版本号修改库存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillMapper seckillMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"modify_inventory_queue"</span>)</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message, @Headers Map&lt;String, Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;&gt;messageId:&#123;&#125;,msg:&#123;&#125;"</span>, messageId, msg);</span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(msg);</span><br><span class="line">        <span class="comment">// 1.获取秒杀id</span></span><br><span class="line">        Long seckillId = jsonObject.getLong(<span class="string">"seckillId"</span>);</span><br><span class="line">        SeckillEntity seckillEntity = seckillMapper.findBySeckillId(seckillId);</span><br><span class="line">        <span class="keyword">if</span> (seckillEntity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"seckillId:&#123;&#125;,商品信息不存在!"</span>, seckillId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long version = seckillEntity.getVersion();</span><br><span class="line">        <span class="keyword">int</span> inventoryDeduction = seckillMapper.inventoryDeduction(seckillId, version);</span><br><span class="line">        <span class="keyword">if</span> (!toDaoResult(inventoryDeduction)) &#123;</span><br><span class="line">            log.info(<span class="string">"&gt;&gt;&gt;seckillId:&#123;&#125;修改库存失败&gt;&gt;&gt;&gt;inventoryDeduction返回为&#123;&#125; 秒杀失败！"</span>, seckillId, inventoryDeduction);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.添加秒杀订单</span></span><br><span class="line">        OrderEntity orderEntity = <span class="keyword">new</span> OrderEntity();</span><br><span class="line">        String phone = jsonObject.getString(<span class="string">"phone"</span>);</span><br><span class="line">        orderEntity.setUserPhone(phone);</span><br><span class="line">        orderEntity.setSeckillId(seckillId);</span><br><span class="line">        orderEntity.setState(<span class="number">1l</span>);</span><br><span class="line">        <span class="keyword">int</span> insertOrder = orderMapper.insertOrder(orderEntity);</span><br><span class="line">        <span class="keyword">if</span> (!toDaoResult(insertOrder)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;&gt;修改库存成功seckillId:&#123;&#125;&gt;&gt;&gt;&gt;inventoryDeduction返回为&#123;&#125; 秒杀成功"</span>, seckillId, inventoryDeduction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用数据库层判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">toDaoResult</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;秒杀设计&quot;&gt;&lt;a href=&quot;#秒杀设计&quot; class=&quot;headerlink&quot; title=&quot;秒杀设计&quot;&gt;&lt;/a&gt;秒杀设计&lt;/h1&gt;&lt;h2 id=&quot;接口设计&quot;&gt;&lt;a href=&quot;#接口设计&quot; class=&quot;headerlink&quot; title=&quot;接口设计&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="总结" scheme="https://www.vazh.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="秒杀" scheme="https://www.vazh.cn/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>聚合支付小结</title>
    <link href="https://www.vazh.cn/2020/05/12/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.vazh.cn/2020/05/12/聚合支付小结/</id>
    <published>2020-05-12T11:38:50.000Z</published>
    <updated>2020-07-15T04:38:03.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚合支付平台设计"><a href="#聚合支付平台设计" class="headerlink" title="聚合支付平台设计"></a>聚合支付平台设计</h1><h2 id="api接口设计"><a href="#api接口设计" class="headerlink" title="api接口设计"></a>api接口设计</h2><ol><li><p>创建支付令牌接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PayMentTransacTokenService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建支付令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/createPayToken"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">createPayToken</span><span class="params">(@Validated PayCreatePayTokenDto payCreatePayTokenDto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询交易信息接口</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PayMentTransacInfoService</span> </span>&#123;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/tokenByPayMentTransac"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;PayMentTransacDTO&gt; <span class="title">tokenByPayMentTransac</span><span class="params">(@RequestParam(<span class="string">"token"</span>)</span> String token)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>查询所有支付渠道接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentChannelService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有支付渠道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/selectAll"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PaymentChannelDTO&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>策略上下文接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PayContextService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/toPayHtml"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">toPayHtml</span><span class="params">(@RequestParam(<span class="string">"channelId"</span>)</span> String channelId,</span></span><br><span class="line"><span class="function">                                              @<span class="title">RequestParam</span><span class="params">(<span class="string">"payToken"</span>)</span> String payToken)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="聚合支付服务实现"><a href="#聚合支付服务实现" class="headerlink" title="聚合支付服务实现"></a>聚合支付服务实现</h2><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p><img src="/picture/package.png" alt=""></p><h4 id="service-impl包"><a href="#service-impl包" class="headerlink" title="service.impl包"></a>service.impl包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayMentTransacTokenServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseApiService</span>&lt;<span class="title">JSONObject</span>&gt; <span class="keyword">implements</span> <span class="title">PayMentTransacTokenService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PaymentTransactionMapper paymentTransactionMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GenerateToken generateToken;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">createPayToken</span><span class="params">(PayCreatePayTokenDto payCreatePayTokenDto)</span> </span>&#123;</span><br><span class="line">String orderId = payCreatePayTokenDto.getOrderId();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(orderId)) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"订单号码不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Long payAmount = payCreatePayTokenDto.getPayAmount();</span><br><span class="line"><span class="keyword">if</span> (payAmount == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"金额不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Long userId = payCreatePayTokenDto.getUserId();</span><br><span class="line"><span class="keyword">if</span> (userId == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"userId不能为空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.将输入插入数据库中 待支付记录</span></span><br><span class="line">PaymentTransactionEntity paymentTransactionEntity = <span class="keyword">new</span> PaymentTransactionEntity();</span><br><span class="line">paymentTransactionEntity.setOrderId(orderId);</span><br><span class="line">paymentTransactionEntity.setPayAmount(payAmount);</span><br><span class="line">paymentTransactionEntity.setUserId(userId);</span><br><span class="line"><span class="comment">// 使用雪花算法 生成全局id</span></span><br><span class="line">paymentTransactionEntity.setPaymentId(SnowflakeIdUtils.nextId());</span><br><span class="line"><span class="keyword">int</span> result = paymentTransactionMapper.insertPaymentTransaction(paymentTransactionEntity);</span><br><span class="line"><span class="keyword">if</span> (!toDaoResult(result)) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"系统错误!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取主键id</span></span><br><span class="line">Long payId = paymentTransactionEntity.getId();</span><br><span class="line"><span class="keyword">if</span> (payId == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"系统错误!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.生成对应支付令牌</span></span><br><span class="line">String keyPrefix = <span class="string">"pay_"</span>;</span><br><span class="line">String token = generateToken.createToken(keyPrefix, payId + <span class="string">""</span>);</span><br><span class="line">JSONObject dataResult = <span class="keyword">new</span> JSONObject();</span><br><span class="line">dataResult.put(<span class="string">"token"</span>, token);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> setResultSuccess(dataResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PayMentTransacTokenServiceImpl类是PayMentTransacTokenService的实现类，主要用于创建交易订单的支付token生成, 首先对payCreatePayTokenDto进行参数验证，然后设置PaymentTransactionEntity属性值插入数据库，插入预支付记录，数据库中有payment_status标记支付状态，0代表预支付,1代表已支付,使用雪花算法生成全局id . 插入成功后对插入记录判断是否插入成功以及获取id判断雪花生成id是否成功。最后利用工具类创建支付令牌，generateToken对象创建token,然后将token存放在json中返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayMentTransacInfoServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseApiService</span>&lt;<span class="title">PayMentTransacDTO</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PayMentTransacInfoService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GenerateToken generateToken;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PaymentTransactionMapper paymentTransactionMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;PayMentTransacDTO&gt; <span class="title">tokenByPayMentTransac</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.验证token是否为空</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"token参数不能空!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用token查询redisPayMentTransacID</span></span><br><span class="line">String value = generateToken.getToken(token);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"该Token可能已经失效或者已经过期"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.转换为整数类型</span></span><br><span class="line">Long transactionId = Long.parseLong(value);</span><br><span class="line"><span class="comment">// 4.使用transactionId查询支付信息</span></span><br><span class="line">PaymentTransactionEntity paymentTransaction = paymentTransactionMapper.selectById(transactionId);</span><br><span class="line"><span class="keyword">if</span> (paymentTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"未查询到该支付信息"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> setResultSuccess(ElvisBeanUtils.doToDto(paymentTransaction, PayMentTransacDTO.class));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询交易信息实现类　通过token查询交易订单号　查询交易信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentChannelServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseApiService</span>&lt;<span class="title">List</span>&lt;<span class="title">PaymentChannelDTO</span>&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PaymentChannelService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PaymentChannelMapper paymentChannelMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PaymentChannelDTO&gt; <span class="title">selectAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;PaymentChannelEntity&gt; paymentChanneList = paymentChannelMapper.selectAll();</span><br><span class="line"><span class="keyword">return</span> MapperUtils.mapAsList(paymentChanneList, PaymentChannelDTO.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询所有渠道信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayContextServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseApiService</span>&lt;<span class="title">JSONObject</span>&gt; <span class="keyword">implements</span> <span class="title">PayContextService</span> </span>&#123;</span><br><span class="line"><span class="comment">//根据channelId查询classAddres(反射全类名)</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PaymentChannelMapper paymentChannelMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PayMentTransacInfoService payMentTransacInfoService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse&lt;JSONObject&gt; <span class="title">toPayHtml</span><span class="params">(String channelId, String payToken)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.使用渠道id获取渠道信息 classAddres</span></span><br><span class="line">PaymentChannelEntity pymentChannel = paymentChannelMapper.selectBychannelId(channelId);</span><br><span class="line"><span class="keyword">if</span> (pymentChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(<span class="string">"没有查询到该渠道信息"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用payToken获取支付参数</span></span><br><span class="line">BaseResponse&lt;PayMentTransacDTO&gt; tokenByPayMentTransac = payMentTransacInfoService</span><br><span class="line">.tokenByPayMentTransac(payToken);</span><br><span class="line"><span class="keyword">if</span> (!isSuccess(tokenByPayMentTransac)) &#123;</span><br><span class="line"><span class="keyword">return</span> setResultError(tokenByPayMentTransac.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">PayMentTransacDTO payMentTransacDTO = tokenByPayMentTransac.getData();</span><br><span class="line"><span class="comment">// 3.执行具体的支付渠道的算法获取html表单数据 策略设计模式 使用java反射机制 执行具体方法</span></span><br><span class="line">String classAddres = pymentChannel.getClassAddres();</span><br><span class="line">PayStrategy payStrategy = StrategyFactory.getPayStrategy(classAddres);</span><br><span class="line">String payHtml = payStrategy.toPayHtml(pymentChannel, payMentTransacDTO);</span><br><span class="line"><span class="comment">// 4.直接返回html</span></span><br><span class="line">JSONObject data = <span class="keyword">new</span> JSONObject();</span><br><span class="line">data.put(<span class="string">"payHtml"</span>, payHtml);</span><br><span class="line"><span class="keyword">return</span> setResultSuccess(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于策略模式返回不同html,传入渠道id与token,返回对应渠道的支付页面。首先根据渠道id查询对应渠道的全类名，通过token查询支付订单信息,通过全类名反射生成对象,由策略工厂生成,策略接口持有,不同的策略会有不同的实现,如支付宝策略,银联策略</p><h4 id="包strategy-实现不同的渠道调用"><a href="#包strategy-实现不同的渠道调用" class="headerlink" title="包strategy 实现不同的渠道调用"></a>包strategy 实现不同的渠道调用</h4><p>首先是该包下的策略接口　不同的支付渠道有各自的实现策略　如支付宝、银联有具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paymentChannel</span></span><br><span class="line"><span class="comment"> *            渠道参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> payMentTransacDTO</span></span><br><span class="line"><span class="comment"> *            支付参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toPayHtml</span><span class="params">(PaymentChannelEntity paymentChannel, PayMentTransacDTO payMentTransacDTO)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以支付宝为例　下面是支付宝的具体策略实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPayStrategy</span> <span class="keyword">implements</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toPayHtml</span><span class="params">(PaymentChannelEntity pymentChannel, PayMentTransacDTO payMentTransacDTO)</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;支付宝参数封装开始&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得初始化的AlipayClient</span></span><br><span class="line">AlipayClient alipayClient = <span class="keyword">new</span> DefaultAlipayClient(AlipayConfig.gatewayUrl, AlipayConfig.app_id,</span><br><span class="line">AlipayConfig.merchant_private_key, <span class="string">"json"</span>, AlipayConfig.charset, AlipayConfig.alipay_public_key,</span><br><span class="line">AlipayConfig.sign_type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求参数</span></span><br><span class="line">AlipayTradePagePayRequest alipayRequest = <span class="keyword">new</span> AlipayTradePagePayRequest();</span><br><span class="line">alipayRequest.setReturnUrl(AlipayConfig.return_url);</span><br><span class="line">alipayRequest.setNotifyUrl(AlipayConfig.notify_url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商户订单号，商户网站订单系统中唯一订单号，必填</span></span><br><span class="line">String outTradeNo = payMentTransacDTO.getPaymentId();</span><br><span class="line"><span class="comment">// 付款金额，必填</span></span><br><span class="line">String totalAmount = changeF2Y(payMentTransacDTO.getPayAmount() + <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 订单名称，必填</span></span><br><span class="line">String subject = <span class="string">"珊珊幼儿园"</span>;</span><br><span class="line"><span class="comment">// 商品描述，可空</span></span><br><span class="line">String body = <span class="string">"珊珊课程服务"</span>;</span><br><span class="line"></span><br><span class="line">alipayRequest.setBizContent(<span class="string">"&#123;\"out_trade_no\":\""</span> + outTradeNo + <span class="string">"\","</span> + <span class="string">"\"total_amount\":\""</span> + totalAmount</span><br><span class="line">+ <span class="string">"\","</span> + <span class="string">"\"subject\":\""</span> + subject + <span class="string">"\","</span> + <span class="string">"\"body\":\""</span> + body + <span class="string">"\","</span></span><br><span class="line">+ <span class="string">"\"product_code\":\"FAST_INSTANT_TRADE_PAY\"&#125;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String result = alipayClient.pageExecute(alipayRequest).getBody();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 金额为分的格式 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CURRENCY_FEN_REGEX = <span class="string">"\\-?[0-9]+"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将分为单位的转换为元 （除100）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> amount</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">changeF2Y</span><span class="params">(String amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!amount.matches(CURRENCY_FEN_REGEX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BigDecimal.valueOf(Long.valueOf(amount)).divide(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略工厂类　格局全类名生产对应的对象 ConcurrentHashMap维护全类名与具体策略映射  ConcurrentHashMap保存的话后面可以不用每次都实例化　只需要一次实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, PayStrategy&gt; strategyBean = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思考几个点：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PayStrategy <span class="title">getPayStrategy</span><span class="params">(String classAddres)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(classAddres)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">PayStrategy beanPayStrategy = strategyBean.get(classAddres);</span><br><span class="line"><span class="keyword">if</span> (beanPayStrategy != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> beanPayStrategy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.使用Java的反射机制初始化子类</span></span><br><span class="line">Class&lt;?&gt; forName = Class.forName(classAddres);</span><br><span class="line"><span class="comment">// 2.反射机制初始化对象</span></span><br><span class="line">PayStrategy payStrategy = (PayStrategy) forName.newInstance();</span><br><span class="line">strategyBean.put(classAddres, payStrategy);</span><br><span class="line"><span class="keyword">return</span> payStrategy;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="callback包实现异步回调"><a href="#callback包实现异步回调" class="headerlink" title="callback包实现异步回调　"></a>callback包实现异步回调　</h4><p>下面两个包　</p><p>![img]/picture/callback.png)</p><p>首先异步回调采用模板方法进行重构代码　针对支付宝与银联进行公共代码抽取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPayCallbackTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentTransactionLogMapper paymentTransactionLogMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor threadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有请求的参数，封装成Map集合 并且验证是否被篡改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String, String&gt; <span class="title">verifySignature</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步回调执行业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verifySignature</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">asyncService</span><span class="params">(Map&lt;String, String&gt; verifySignature)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">failResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">successResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * *1. 将报文数据存放到es &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 验证报文参数&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 将日志根据支付id存放到数据库中&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. 执行的异步回调业务逻辑&lt;br&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">asyncCallBack</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 验证报文参数 相同点 获取所有的请求参数封装成为map集合 并且进行参数验证</span></span><br><span class="line">        Map&lt;String, String&gt; verifySignature = verifySignature(req, resp);</span><br><span class="line">        <span class="comment">// 2.将日志根据支付id存放到数据库中</span></span><br><span class="line">        String paymentId = verifySignature.get(<span class="string">"paymentId"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(paymentId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> failResult();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.采用异步形式写入日志到数据库中</span></span><br><span class="line">        payLog(paymentId, verifySignature);</span><br><span class="line">        <span class="comment">//new Thread(new PayLogThread(paymentId,verifySignature)).start();</span></span><br><span class="line"></span><br><span class="line">        String result = verifySignature.get(PayConstant.RESULT_NAME);</span><br><span class="line">        <span class="comment">// 4.201报文验证签名失败</span></span><br><span class="line">        <span class="keyword">if</span> (result.equals(PayConstant.RESULT_PAYCODE_201)) &#123;</span><br><span class="line">            <span class="keyword">return</span> failResult();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.执行的异步回调业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> asyncService(verifySignature);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用多线程技术或者MQ形式进行存放到数据库中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paymentId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verifySignature</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">payLog</span><span class="params">(String paymentId, Map&lt;String, String&gt; verifySignature)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;paymentId:&#123;paymentId&#125;,verifySignature:&#123;&#125;"</span>, verifySignature);</span><br><span class="line">        PaymentTransactionLogEntity paymentTransactionLog = <span class="keyword">new</span> PaymentTransactionLogEntity();</span><br><span class="line">        paymentTransactionLog.setTransactionId(paymentId);</span><br><span class="line">        paymentTransactionLog.setAsyncLog(verifySignature.toString());</span><br><span class="line">        paymentTransactionLogMapper.insertTransactionLog(paymentTransactionLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A 1423 B 1234</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用多线程写入日志目的：加快响应 提高程序效率 使用线程池维护线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PayLogThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String paymentId;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, String&gt; verifySignature;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PayLogThread</span><span class="params">(String paymentId, Map&lt;String, String&gt; verifySignature)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.paymentId = paymentId;</span><br><span class="line">            <span class="keyword">this</span>.verifySignature = verifySignature;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;asyncCallBack service 02"</span>);</span><br><span class="line">            payLog(paymentId, verifySignature);</span><br><span class="line">            log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;asyncCallBack service 03"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法抽象异步回调逻辑　asyncCallBack方法组装异步回调逻辑　然后验签、异步回调通知延迟到子类实现</p><p>写日志可以采用多线程或异步mq方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">addMQIntegral<span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionPayCallbackTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractPayCallbackTemplate</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PaymentTransactionMapper paymentTransactionMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IntegralProducer integralProducer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">verifySignature</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">LogUtil.writeLog(<span class="string">"BackRcvResponse接收后台通知开始"</span>);</span><br><span class="line"></span><br><span class="line">String encoding = req.getParameter(SDKConstants.param_encoding);</span><br><span class="line"><span class="comment">// 获取银联通知服务器发送的后台通知参数</span></span><br><span class="line">Map&lt;String, String&gt; reqParam = getAllRequestParam(req);</span><br><span class="line">LogUtil.printRequestLog(reqParam);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要！验证签名前不要修改reqParam中的键值对的内容，否则会验签不过</span></span><br><span class="line"><span class="keyword">if</span> (!AcpService.validate(reqParam, encoding)) &#123;</span><br><span class="line">LogUtil.writeLog(<span class="string">"验证签名结果[失败]."</span>);</span><br><span class="line">reqParam.put(PayConstant.RESULT_NAME, PayConstant.RESULT_PAYCODE_201);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">LogUtil.writeLog(<span class="string">"验证签名结果[成功]."</span>);</span><br><span class="line"><span class="comment">// 【注：为了安全验签成功才应该写商户的成功处理逻辑】交易成功，更新商户订单状态</span></span><br><span class="line">String orderId = reqParam.get(<span class="string">"orderId"</span>); <span class="comment">// 获取后台通知的数据，其他字段也可用类似方式获取</span></span><br><span class="line">reqParam.put(<span class="string">"paymentId"</span>, orderId);</span><br><span class="line">reqParam.put(PayConstant.RESULT_NAME, PayConstant.RESULT_PAYCODE_200);</span><br><span class="line">&#125;</span><br><span class="line">LogUtil.writeLog(<span class="string">"BackRcvResponse接收后台通知结束"</span>);</span><br><span class="line"><span class="keyword">return</span> reqParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调中网络尝试延迟，导致异步回调重复执行 可能存在幂等性问题</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">asyncService</span><span class="params">(Map&lt;String, String&gt; verifySignature)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String orderId = verifySignature.get(<span class="string">"orderId"</span>); <span class="comment">// 获取后台通知的数据，其他字段也可用类似方式获取</span></span><br><span class="line">String respCode = verifySignature.get(<span class="string">"respCode"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断respCode=00、A6后，对涉及资金类的交易，请再发起查询接口查询，确定交易成功后更新数据库。</span></span><br><span class="line">System.out.println(<span class="string">"orderId:"</span> + orderId + <span class="string">",respCode:"</span> + respCode);</span><br><span class="line"><span class="comment">// 1.判断respCode是否为已经支付成功断respCode=00、A6后，</span></span><br><span class="line"><span class="keyword">if</span> (!(respCode.equals(<span class="string">"00"</span>) || respCode.equals(<span class="string">"A6"</span>))) &#123;</span><br><span class="line"><span class="keyword">return</span> failResult();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据日志 手动补偿 使用支付id调用第三方支付接口查询</span></span><br><span class="line">PaymentTransactionEntity paymentTransaction = paymentTransactionMapper.selectByPaymentId(orderId);</span><br><span class="line"><span class="keyword">if</span> (paymentTransaction.getPaymentStatus().equals(PayConstant.PAY_STATUS_SUCCESS)) &#123;</span><br><span class="line"><span class="comment">// 网络重试中，之前已经支付过</span></span><br><span class="line"><span class="keyword">return</span> successResult();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.将状态改为已经支付成功</span></span><br><span class="line">paymentTransactionMapper.updatePaymentStatus(PayConstant.PAY_STATUS_SUCCESS + <span class="string">""</span>, orderId);</span><br><span class="line"><span class="comment">// 3.调用积分服务接口增加积分(处理幂等性问题)　查询支付状态　如果支付成功　不用重试</span></span><br><span class="line">addMQIntegral(paymentTransaction); <span class="comment">// 使用MQ</span></span><br><span class="line"><span class="keyword">return</span> successResult();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于MQ增加积分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addMQIntegral</span><span class="params">(PaymentTransactionEntity paymentTransaction)</span> </span>&#123;</span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">"paymentId"</span>, paymentTransaction.getPaymentId());</span><br><span class="line">jsonObject.put(<span class="string">"userId"</span>, paymentTransaction.getUserId());</span><br><span class="line">jsonObject.put(<span class="string">"integral"</span>, <span class="number">100</span>);</span><br><span class="line">integralProducer.send(jsonObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">failResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PayConstant.YINLIAN_RESULT_FAIL;</span><br><span class="line">&#125;然一次性解决会有问题，那就分多次解决！简单的描</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">successResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PayConstant.YINLIAN_RESULT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取请求参数中所有的信息 当商户上送frontUrl或backUrl地址中带有参数信息的时候，</span></span><br><span class="line"><span class="comment"> * 这种方式会将url地址中的参数读到map中，会导多出来这些信息从而致验签失败，</span></span><br><span class="line"><span class="comment"> * 这个时候可以自行修改过滤掉url中的参数或者使用getAllRequestParamStream方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getAllRequestParam</span><span class="params">(<span class="keyword">final</span> HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, String&gt; res = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">Enumeration&lt;?&gt; temp = request.getParameterNames();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != temp) &#123;</span><br><span class="line"><span class="keyword">while</span> (temp.hasMoreElements()) &#123;</span><br><span class="line">String en = (String) temp.nextElement();</span><br><span class="line">String value = request.getParameter(en);</span><br><span class="line">res.put(en, value);</span><br><span class="line"><span class="comment">// 在报文上送时，如果字段的值为空，则不上送&lt;下面的处理为在获取所有参数数据时，判断若值为空，则删除这个字段&gt;</span></span><br><span class="line"><span class="keyword">if</span> (res.get(en) == <span class="keyword">null</span> || <span class="string">""</span>.equals(res.get(en))) &#123;</span><br><span class="line"><span class="comment">// System.out.println("======为空的字段名===="+en);</span></span><br><span class="line">res.remove(en);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">  ｝</span><br></pre></td></tr></table></figure><p>具体的银联异步回调模板　其中asyncService方法执行具体异步回调通知　首先获取上一步验签的结果　获取状态码　然后进行判断是否执行成功　若失败则返回失败结果　否则通过支付id查询支付状态　若支付成功　可能是网络重试　直接返回成功状态　避免反复重试造成积分等服务的幂等性问题　若支付状态没有修改　则修改支付状态为1 并异步mq增加积分并返回成功状态</p><p>addMQIntegral方法调用积分服务　采用rabbitmq异步增加积分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractPayCallbackTemplate <span class="title">getPayCallbackTemplate</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (AbstractPayCallbackTemplate) SpringContextUtil.getBean(beanId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板工厂根据beanId获取对应的模板　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayAsynCallbackService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNIONPAYCALLBACK_TEMPLATE = <span class="string">"unionPayCallbackTemplate"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银联异步回调接口执行代码</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/unionPayAsynCallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">unionPayAsynCallback</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">AbstractPayCallbackTemplate abstractPayCallbackTemplate = TemplateFactory</span><br><span class="line">.getPayCallbackTemplate(UNIONPAYCALLBACK_TEMPLATE);</span><br><span class="line"><span class="keyword">return</span> abstractPayCallbackTemplate.asyncCallBack(req, resp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PayAsynCallbackService执行异步回调逻辑　调用抽象模板组装业务逻辑的方法asyncCallBack　</p><h3 id="整合积分服务"><a href="#整合积分服务" class="headerlink" title="整合积分服务"></a>整合积分服务</h3><ol><li><p>积分投递成功查询与积分增加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntegralMapper</span> </span>&#123;</span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"INSERT INTO `elvis_integral` VALUES (NULL, #&#123;userId&#125;, #&#123;paymentId&#125;,#&#123;integral&#125;, #&#123;availability&#125;, 0, null, now(), null, now());"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertIntegral</span><span class="params">(IntegralEntity integralEntity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT  id as id ,USER_ID as userId, PAYMENT_ID as PAYMENTID ,INTEGRAL as INTEGRAL ,AVAILABILITY as AVAILABILITY  FROM elvis_integral where PAYMENT_ID=#&#123;paymentId&#125;  AND AVAILABILITY='1';"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> IntegralEntity <span class="title">findIntegral</span><span class="params">(String paymentId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>积分服务 消费者　监听积分队列　处理积分增加幂等性问题　先获取队列信息　首先获取paymentId　如果为空　则可能已经消费手动签收　再进行积分查询　看积分是否已经增加若增加　手动签收　再对userId,integral进行判空验证　最后将积分增加　支付订单+积分保证唯一　若数据库插入成功　手动签收</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegralConsumer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IntegralMapper integralMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"integral_queue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message, @Headers Map&lt;String, Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">log.info(<span class="string">"&gt;&gt;&gt;messageId:&#123;&#125;,msg:&#123;&#125;"</span>, messageId, msg);</span><br><span class="line">JSONObject jsonObject = JSONObject.parseObject(msg);</span><br><span class="line">String paymentId = jsonObject.getString(<span class="string">"paymentId"</span>);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(paymentId)) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;支付id不能为空 paymentId:&#123;&#125;"</span>, paymentId);</span><br><span class="line">basicNack(message, channel);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用paymentId查询是否已经增加过积分 网络重试间隔</span></span><br><span class="line">IntegralEntity resultIntegralEntity = integralMapper.findIntegral(paymentId);</span><br><span class="line"><span class="keyword">if</span> (resultIntegralEntity != <span class="keyword">null</span>) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;paymentId:&#123;&#125;已经增加过积分"</span>, paymentId);</span><br><span class="line"><span class="comment">// 已经增加过积分，通知MQ不要在继续重试。</span></span><br><span class="line">basicNack(message, channel);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer userId = jsonObject.getInteger(<span class="string">"userId"</span>);</span><br><span class="line"><span class="keyword">if</span> (userId == <span class="keyword">null</span>) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;paymentId:&#123;&#125;,对应的用户userId参数为空"</span>, paymentId);</span><br><span class="line">basicNack(message, channel);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Long integral = jsonObject.getLong(<span class="string">"integral"</span>);</span><br><span class="line"><span class="keyword">if</span> (integral == <span class="keyword">null</span>) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;paymentId:&#123;&#125;,对应的用户integral参数为空"</span>, integral);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">IntegralEntity integralEntity = <span class="keyword">new</span> IntegralEntity();</span><br><span class="line">integralEntity.setPaymentId(paymentId);</span><br><span class="line">integralEntity.setIntegral(integral);</span><br><span class="line">integralEntity.setUserId(userId);</span><br><span class="line">integralEntity.setAvailability(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 插入到数据库中</span></span><br><span class="line"><span class="keyword">int</span> insertIntegral = integralMapper.insertIntegral(integralEntity);</span><br><span class="line"><span class="keyword">if</span> (insertIntegral &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 手动签收消息,通知mq服务器端删除该消息</span></span><br><span class="line">basicNack(message, channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 采用重试机制</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;ERROR MSG:"</span>, e.getMessage());</span><br><span class="line">basicNack(message, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者获取到消息之后 手动签收 通知MQ删除该消息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 什么场景下 适合于重试 网络连接、空指针 参数错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>积分生产者　投递增加积分消息 采用重试+ack确认机制保证消息成功投递到mq</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegralProducer</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INTEGRAL_EXCHANGE_NAME = <span class="string">"integral_exchange_name"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INTEGRAL_ROUTINGKEY = <span class="string">"integralRoutingKey"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(JSONObject jsonObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String jsonString = jsonObject.toJSONString();</span><br><span class="line">System.out.println(<span class="string">"jsonString:"</span> + jsonString);</span><br><span class="line">String paymentId = jsonObject.getString(<span class="string">"paymentId"</span>);</span><br><span class="line"><span class="comment">// 封装消息</span></span><br><span class="line">Message message = MessageBuilder.withBody(jsonString.getBytes())</span><br><span class="line">.setContentType(MessageProperties.CONTENT_TYPE_JSON).setContentEncoding(<span class="string">"utf-8"</span>).setMessageId(paymentId)</span><br><span class="line">.build();</span><br><span class="line"><span class="comment">// 构建回调返回的数据（消息id）</span></span><br><span class="line"><span class="keyword">this</span>.rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">this</span>.rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(jsonString);</span><br><span class="line">rabbitTemplate.convertAndSend(INTEGRAL_EXCHANGE_NAME, INTEGRAL_ROUTINGKEY, message, correlationData);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产消息确认机制 生产者往服务器端发送消息的时候，采用应答机制</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">String jsonString = correlationData.getId();</span><br><span class="line">System.out.println(<span class="string">"消息id:"</span> + correlationData.getId());</span><br><span class="line"><span class="keyword">if</span> (ack) &#123;</span><br><span class="line">log.info(<span class="string">"&gt;&gt;&gt;使用MQ消息确认机制确保消息一定要投递到MQ中成功"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">JSONObject jsonObject = JSONObject.parseObject(jsonString);</span><br><span class="line"><span class="comment">// 生产者消息投递失败的话，采用递归重试机制</span></span><br><span class="line">send(jsonObject);</span><br><span class="line">log.info(<span class="string">"&gt;&gt;&gt;使用MQ消息确认机制投递到MQ中失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>积分补偿队列　解决在支付状态与积分增加之间存在的分布式任务问题　因为增加积分是异步的，若事务回滚，积分增加了支付状态还是待支付则出现不一致的分布式事务问题，所以进行补偿，若积分增加了则将支付状态改为已支付状态</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayCheckStateConsumer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PaymentTransactionMapper paymentTransactionMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死信队列（备胎） 消息被拒绝、队列长度满了 定时任务 人工补偿</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"integral_create_queue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message, @Headers Map&lt;String, Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">log.info(<span class="string">"&gt;&gt;&gt;messageId:&#123;&#125;,msg:&#123;&#125;"</span>, messageId, msg);</span><br><span class="line">JSONObject jsonObject = JSONObject.parseObject(msg);</span><br><span class="line">String paymentId = jsonObject.getString(<span class="string">"paymentId"</span>);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(paymentId)) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;支付id不能为空 paymentId:&#123;&#125;"</span>, paymentId);</span><br><span class="line">basicNack(message, channel);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.使用paymentId查询之前是否已经支付过</span></span><br><span class="line">PaymentTransactionEntity paymentTransactionEntity = paymentTransactionMapper.selectByPaymentId(paymentId);</span><br><span class="line"><span class="keyword">if</span> (paymentTransactionEntity == <span class="keyword">null</span>) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;支付id paymentId:&#123;&#125; 未查询到"</span>, paymentId);</span><br><span class="line">basicNack(message, channel);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer paymentStatus = paymentTransactionEntity.getPaymentStatus();</span><br><span class="line"><span class="keyword">if</span> (paymentStatus.equals(PayConstant.PAY_STATUS_SUCCESS)) &#123;</span><br><span class="line">log.error(<span class="string">"&gt;&gt;&gt;&gt;支付id paymentId:&#123;&#125; "</span>, paymentId);</span><br><span class="line">basicNack(message, channel);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 安全起见 主动调用第三方接口查询</span></span><br><span class="line">String paymentChannel = jsonObject.getString(<span class="string">"paymentChannel"</span>);</span><br><span class="line"><span class="keyword">int</span> updatePaymentStatus = paymentTransactionMapper.updatePaymentStatus(PayConstant.PAY_STATUS_SUCCESS + <span class="string">""</span>,</span><br><span class="line">paymentId, paymentChannel);</span><br><span class="line"><span class="keyword">if</span> (updatePaymentStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">basicNack(message, channel);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续重试</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">basicNack(message, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;聚合支付平台设计&quot;&gt;&lt;a href=&quot;#聚合支付平台设计&quot; class=&quot;headerlink&quot; title=&quot;聚合支付平台设计&quot;&gt;&lt;/a&gt;聚合支付平台设计&lt;/h1&gt;&lt;h2 id=&quot;api接口设计&quot;&gt;&lt;a href=&quot;#api接口设计&quot; class=&quot;header
      
    
    </summary>
    
      <category term="项目" scheme="https://www.vazh.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="支付" scheme="https://www.vazh.cn/tags/%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇(五):ConcurrentLinkedDeque</title>
    <link href="https://www.vazh.cn/2020/05/06/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%BA%94-ConcurrentLinkedDeque/"/>
    <id>https://www.vazh.cn/2020/05/06/JUC源码分析-集合篇-五-ConcurrentLinkedDeque/</id>
    <published>2020-05-06T06:32:50.000Z</published>
    <updated>2020-05-12T11:39:09.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC源码分析-集合篇（五）：ConcurrentLinkedDeque"><a href="#JUC源码分析-集合篇（五）：ConcurrentLinkedDeque" class="headerlink" title="JUC源码分析-集合篇（五）：ConcurrentLinkedDeque"></a>JUC源码分析-集合篇（五）：ConcurrentLinkedDeque</h1><blockquote><p>ConcurrentLinkedDeque 是<strong>双向链表结构的无界并发队列</strong>。从JDK 7开始加入到J.U.C的行列中。使用CAS实现并发安全，与 ConcurrentLinkedQueue 的区别是该阻塞队列同时支持<strong>FIFO</strong>和<strong>FILO</strong>两种操作方式，即可以从队列的头和尾同时操作(插入/删除)。适合“多生产，多消费”的场景。内存一致性遵循<strong>对 ConcurrentLinkedDeque 的插入操作先行发生于(happen-before)访问或移除操作</strong>。相较于 ConcurrentLinkedQueue，ConcurrentLinkedDeque 由于是双端队列，所以在操作和概念上会更加复杂，来一起看下。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ConcurrentLinkedDeque（后面称CLD） 的实现方式继承了 ConcurrentLinkedQueue 和 LinkedTransferQueue的思想，在非阻塞算法的实现方面与 ConcurrentLinkedQueue 基本一致。关于 ConcurrentLinkedQueue，请参考笔者的上一篇文章：<a href="https://www.jianshu.com/p/0c5a672b2ade" target="_blank" rel="noopener">JUC源码分析-集合篇（三）：ConcurrentLinkedQueue</a>。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/6050820-1303a196ce819a3c.png?imageMogr2/auto-orient/strip|imageView2/2/w/876/format/webp" alt="img"></p><p>ConcurrentLinkedDeque 继承关系</p><p><strong>重要属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"><span class="comment">//终止节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Node&lt;Object&gt; PREV_TERMINATOR, NEXT_TERMINATOR;</span><br><span class="line"><span class="comment">//移除节点时更新链表属性的阀值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>和ConcurrentLinkedQueue一样，CLD 内部也只维护了<code>head</code>和<code>tail</code>属性，对 head/tail 节点也使用了“不变性”和“可变性”约束，不过跟 ConcurrentLinkedQueue 有些许差异，我们来看一下：</p><p><strong>head/tail 的不变性：</strong></p><ol><li>第一个节点总是能以O(1)的时间复杂度从 head 通过 prev 链接到达；</li><li>最后一个节点总是能以O(1)的时间复杂度从 tail 通过 next 链接到达；</li><li>所有live节点（item不为null的节点），都能从第一个节点通过调用 succ() 方法遍历可达；</li><li>所有live节点（item不为null的节点），都能从最后一个节点通过调用 pred() 方法遍历可达；</li><li>head/tail 不能为 null；</li><li><strong>head</strong> 节点的 next 域不能引用到自身；</li><li>head/tail 不会是GC-unlinked节点（但它可能是unlink节点）。</li></ol><p><strong>head/tail的可变性：</strong></p><ol><li>head/tail 节点的 item 域可能为 null，也可能不为 null；</li><li>head/tail 节点可能从first/last/tail/head 节点访问时不可达；</li><li><strong>tail</strong> 节点的 next 域可以引用到自身。</li></ol><p><em>注：CLD中也对 head/tail 的更新也使用了“松弛阀值”的概念（在 ConcurrentLinkedQueue 一篇中已经分析），除此之外，CLD设定了一个“跳跃阀值”-HOPS（指在查找活动节点时跳过的已删除节点数），在执行出队操作时，跳跃节点数大于2或者操作的节点不是 first/last 节点时才会更新链表（后面源码中详细分析）。</em></p><p>除此之外，再来看看CLD中另外两个属性：</p><ul><li><strong>PREV_TERMINATOR</strong>：prev的终止节点，next指向自身，即<code>PREV_TERMINATOR.next = PREV_TERMINATOR</code>。在 first 节点出列后，会把first.next指向自身(<code>first.next=first</code>)，然后把prev设为<code>PREV_TERMINATOR</code>。</li><li><strong>NEXT_TERMINATOR</strong>：next的终止节点，prev指向自身，即<code>NEXT_TERMINATOR.pre = NEXT_TERMINATOR</code>。在 last 节点出列后，会把last.prev指向自身(<code>last.prev=last</code>)，然后把next设为<br><code>NEXT_TERMINATOR</code>。</li></ul><hr><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>在开始源码分析之前，我们先来看一下CLD中对Node的定义：</p><ol><li><strong>live node</strong>：节点的 item!=null 被称为live节点。当节点的 item 被 CAS 改为 null，逻辑上来讲这个节点已经从链表中移除；一个新的元素通过 CAS 添加到一个包含空 prev 或空 next 的 first 或 last 节点，这个元素的节点在这时是 live节点。</li><li><strong>first node &amp; last node</strong>：首节点(first node)总会有一个空的 prev 引用，终止任何从 live 节点开始的 prev 引用链；同样的最后一个节点(last node)是 next 的终止节点。first/last 节点的 item 可以为 null。并且 first 和 last 节点总是相互可达的。</li><li><strong>active node</strong>：live节点、first/last 节点也被称为活跃节点(active node)，活跃节点一定是被链接的，如果p节点为active节点，则：<code>p.item != null || (p.prev == null &amp;&amp; p.next != p) || (p.next == null &amp;&amp; p.prev != p)</code></li><li><strong>self-node</strong>：自链接节点，prev 或 next 指向自身的节点，自链接节点用在解除链接操作中，并且它们都不是active node。</li><li><strong>head/tail节点</strong>：head/tail 也可能不是 first/last 节点。从 head 节点通过 prev 引用总是可以找到 first 节点，从 tail 节点通过 next 引用总是可以找到 last 节点。允许 head 和 tail 引用已删除的节点，这些节点没有链接，因此可能无法从 live 节点访问到。</li></ol><p>节点删除时经历三个阶段：逻辑删除(logical deletion)，未链接( unlinking)，和gc未链接( gc-unlinking)：</p><ul><li><strong>logical deletion：</strong>通过 CAS 修改节点 item 为 null 来完成，表示当前节点可以被解除链接(unlinking)。</li><li><strong>unlinking：</strong> 这种状态下的节点与其他 active 节点有链接，但是其他 active 节点与之都没有链接，也就是说从这个状态下的节点可以达到 active 节点，但是从 active 节点不可达到这种状态的节点。在任何时候，从 first 通过 next 找到的 live 节点和从 last 通过 prev 找到的节点总是相等的。但是，在节点被逻辑删除时上述结论不成立，这些被逻辑删除的节点也可能只从一端是可达的。</li><li><strong>gc-unlinking：</strong> GC未链接使已删除节点不可达到 active 节点，使GC更容易回收被删除的节点。通过让节点自链接或链接到终止节点（PREV_TERMINATOR 或 NEXT_TERMINATOR）来实现。 gc-unlinking 节点从 head/tail 访问不可达。这一步是为了使数据结构保持GC健壮性(gc-robust)，防止保守式GC（conservative GC，目前已经很少使用）对这些边界空间的使用。对保守式GC来说，使数据结构保持GC健壮性会消除内存无限滞留的问题，同时也提高了分代收机器的性能。</li></ul><p>如果同学们对上述理论还是一头雾水，那么从源码解析中我们就可以直观的看到它们的作用。<br>OK！准备工作已经做完，下面我们正式开始源码解析。</p><hr><h2 id="添加（入列）"><a href="#添加（入列）" class="headerlink" title="添加（入列）"></a>添加（入列）</h2><p>CLD的添加方法包括：<code>offer(E)、add(E)、push(E)、addFirst(E)、addLast(E)、offerFirst(E)、offerLast(E)</code>，所有这些操作都是通过<code>linkFirst(E)</code>或<code>linkLast(E)</code>来实现的。</p><h3 id="linkFirst-E-linkLast-E"><a href="#linkFirst-E-linkLast-E" class="headerlink" title="linkFirst(E) / linkLast(E)"></a>linkFirst(E) / linkLast(E)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as first element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span>(<span class="params">E e</span>)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        <span class="comment">//从head节点往前寻找first节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((q = p.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (q = (p = q).prev) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// Check for head updates every other hop.</span></span><br><span class="line">                <span class="comment">// If p == q, we are sure to follow head instead.</span></span><br><span class="line">                <span class="comment">//如果head被修改，返回head重新查找</span></span><br><span class="line">                p = (h != (h = head)) ? h : q;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.next == p) <span class="comment">// 自链接节点，重新查找</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// p is first node</span></span><br><span class="line">                newNode.lazySetNext(p); <span class="comment">// CAS piggyback</span></span><br><span class="line">                <span class="keyword">if</span> (p.casPrev(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                    <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                    <span class="comment">// for e to become an element of this deque,</span></span><br><span class="line">                    <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                    <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time 跳两个节点时才修改head</span></span><br><span class="line">                        casHead(h, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Lost CAS race to another thread; re-read prev</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkLast</span>(<span class="params">E e</span>)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    restartFromTail:</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        <span class="comment">//从tail节点往后寻找last节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t, q;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((q = p.next) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (q = (p = q).next) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// Check for tail updates every other hop.</span></span><br><span class="line">                <span class="comment">// If p == q, we are sure to follow tail instead.</span></span><br><span class="line">                <span class="comment">//如果tail被修改，返回tail重新查找</span></span><br><span class="line">                p = (t != (t = tail)) ? t : q;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.prev == p) <span class="comment">// 自链接节点，重新查找</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromTail;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// p is last node</span></span><br><span class="line">                newNode.lazySetPrev(p); <span class="comment">// CAS piggyback</span></span><br><span class="line">                <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                    <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                    <span class="comment">// for e to become an element of this deque,</span></span><br><span class="line">                    <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                    <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time 跳两个节点时才修改tail</span></span><br><span class="line">                        casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：<code>linkFirst</code>是插入新节点到队列头的主函数，执行流程如下：<br>首先从 head 节点开始向前循环找到 first 节点(<code>p.prev==null&amp;&amp;p.next!=p</code>)；然后通过<code>lazySetNext</code>设置新节点的 next 节点为 first；然后 CAS 修改 first 的 prev 为新节点。注意这里 CAS 指令成功后会判断 first 节点是否已经跳了两个节点，只有在跳了两个节点才会 CAS 更新 head，这也是为了节省 CAS 指令执行开销。<code>linkLast</code>是插入新节点到队列尾，执行流程与<code>linkFirst</code>一致，不多赘述，具体见源码。<br><em>注：<code>lazySetNext</code>通过 Unsafe 类的<code>putOrderedObject</code>实现，有关这个方法，请参考笔者的另一篇文章：<a href="https://www.jianshu.com/p/a897c4b8929f" target="_blank" rel="noopener">JUC源码分析—CAS和Unsafe</a>。</em></p><hr><h2 id="获取-出列"><a href="#获取-出列" class="headerlink" title="获取(出列)"></a>获取(出列)</h2><p>CLD的获取方法分两种：<br>获取节点：<code>peek、peekFirst 、peekLast、getFirst、getLast</code>，都是通过<code>peekFirst 、peekLast</code>实现。<br>获取并移除节点： <code>poll、pop、remove、pollFirst、pollLast、removeFirst、removeLast</code>，都是通过<code>pollFirst、pollLast</code>实现。</p><p><code>pollFirst、pollLast</code>包括了<code>peekFirst 、peekLast</code>的实现，都是找到并返回 first/last 节点，不同的是，<code>pollFirst、pollLast</code>比<code>peekFirst 、peekLast</code>多了 unlink 这一步。所以这里我们只对<code>pollFirst</code>和<code>pollLast</code>两个方法进行解析。<br>首先来看一下pollFirst() ：</p><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**获取并移除队列首节点*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="literal">null</span>; p = succ(p)) &#123;</span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;</span><br><span class="line">            unlink(p);</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> <code>pollFirst()</code>用于找到链表中首个 item 不为 null 的节点（注意并不是first节点，因为first节点的item可以为null），并返回节点的item。涉及的内部方法较多，不过都很简单，我们通过穿插代码方式分析：</p><ol><li>首先通过<code>first()</code>方法找到 first 节点，first 节点必须为 active 节点(<code>p.prev==null&amp;&amp;p.next!=p</code>)。<code>first()</code>源码如下：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; first() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        <span class="comment">//从head开始往前找</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((q = p.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (q = (p = q).prev) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// Check for head updates every other hop.</span></span><br><span class="line">                <span class="comment">// If p == q, we are sure to follow head instead.</span></span><br><span class="line">                <span class="comment">//如果head被修改则返回新的head重新查找，否则继续向前(prev)查找</span></span><br><span class="line">                p = (h != (h = head)) ? h : q;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == h</span><br><span class="line">                     <span class="comment">// It is possible that p is PREV_TERMINATOR,</span></span><br><span class="line">                     <span class="comment">// but if so, the CAS is guaranteed to fail.</span></span><br><span class="line">                    <span class="comment">//找到的节点不是head节点，CAS修改head</span></span><br><span class="line">                     || casHead(h, p))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果<code>first.item==null</code>（这里是允许的，具体见上面我们对 first/last 节点的介绍），则继续调用<code>succ</code>方法寻找后继节点。<code>succ</code>源码如下：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**返回指定节点的的后继节点，如果指定节点的next指向自己，返回first节点*/</span></span><br><span class="line"><span class="function">final Node&lt;E&gt; <span class="title">succ</span>(<span class="params">Node&lt;E&gt; p</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> should we skip deleted nodes here?</span></span><br><span class="line">    Node&lt;E&gt; q = p.next;</span><br><span class="line">    <span class="keyword">return</span> (p == q) ? first() : q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>CAS 修改节点的 item 为 null（<strong>即 “逻辑删除-logical deletion”</strong>），然后调用<code>unlink(p)</code>方法解除节点链接，最后返回 item。<code>unlink(p)</code>是移除节点的主方法，逻辑较为复杂，后面我们单独分析。</li></ol><h4 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<e> x)</e></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// assert x.item == null;</span></span><br><span class="line">    <span class="comment">// assert x != PREV_TERMINATOR;</span></span><br><span class="line">    <span class="comment">// assert x != NEXT_TERMINATOR;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;<span class="comment">//操作节点为first节点</span></span><br><span class="line">        unlinkFirst(x, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;<span class="comment">//操作节点为last节点</span></span><br><span class="line">        unlinkLast(x, prev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// common case</span></span><br><span class="line">        Node&lt;E&gt; activePred, activeSucc;</span><br><span class="line">        boolean isFirst, isLast;</span><br><span class="line">        int hops = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find active predecessor</span></span><br><span class="line">        <span class="comment">//从被操作节点的prev节点开始找到前继活动节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = prev; ; ++hops) &#123;          </span><br><span class="line">            <span class="keyword">if</span> (p.item != <span class="literal">null</span>) &#123;</span><br><span class="line">                activePred = p;</span><br><span class="line">                isFirst = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;E&gt; q = p.prev;</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.next == p)</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">//自链接节点</span></span><br><span class="line">                activePred = p;</span><br><span class="line">                isFirst = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)<span class="comment">//自链接节点</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find active successor</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = next; ; ++hops) &#123;          </span><br><span class="line">            <span class="keyword">if</span> (p.item != <span class="literal">null</span>) &#123;</span><br><span class="line">                activeSucc = p;</span><br><span class="line">                isLast = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.prev == p)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                activeSucc = p;</span><br><span class="line">                isLast = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)<span class="comment">//自链接节点</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> better HOP heuristics</span></span><br><span class="line">        <span class="comment">//无节点跳跃并且操作节点有first或last节点时不更新链表</span></span><br><span class="line">        <span class="keyword">if</span> (hops &lt; HOPS</span><br><span class="line">            <span class="comment">// always squeeze out interior deleted nodes</span></span><br><span class="line">            &amp;&amp; (isFirst | isLast))          </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Squeeze out deleted nodes between activePred and</span></span><br><span class="line">        <span class="comment">// activeSucc, including x.</span></span><br><span class="line">        <span class="comment">//连接两个活动节点</span></span><br><span class="line">        skipDeletedSuccessors(activePred);            </span><br><span class="line">        skipDeletedPredecessors(activeSucc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to gc-unlink, if possible</span></span><br><span class="line">        <span class="keyword">if</span> ((isFirst | isLast) &amp;&amp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Recheck expected state of predecessor and successor</span></span><br><span class="line">            (activePred.next == activeSucc) &amp;&amp;</span><br><span class="line">            (activeSucc.prev == activePred) &amp;&amp;</span><br><span class="line">            (isFirst ? activePred.prev == <span class="literal">null</span> : activePred.item != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">            (isLast  ? activeSucc.next == <span class="literal">null</span> : activeSucc.item != <span class="literal">null</span>)) &#123;          </span><br><span class="line"></span><br><span class="line">            updateHead(); <span class="comment">// Ensure x is not reachable from head</span></span><br><span class="line">            updateTail(); <span class="comment">// Ensure x is not reachable from tail</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finally, actually gc-unlink</span></span><br><span class="line">            x.lazySetPrev(isFirst ? prevTerminator() : x);</span><br><span class="line">            x.lazySetNext(isLast  ? nextTerminator() : x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：<code>unlink(Node x)</code>方法用于解除已弹出节点的链接，分三种情况：</p><ol><li>首先说一下通常的情况（源码中标注 <code>common case</code> 处），这种情况下，入列和出列非同端操作，即操作节点 x 非 first 和 last 节点， 就执行如下流程：</li></ol><ul><li>首先找到给定节点 x 的活跃（active）前继和后继节点。然后修整它们之间的链接，让它们指向对方（通过<code>skipDeletedSuccessors</code>和<code>skipDeletedPredecessors</code>方法），留下一个从活跃(active)节点不可达的 x 节点（<strong>即“unlinking”</strong>）。</li><li>如果成功执行，或者 x 节点没有 live 的前继/后继节点，再尝试 gc 解除链接(gc-unlink)，在设置 x 节点的 prev/next 指向它们自己或 TERMINATOR 之前（<strong>即“gc-unlink”</strong>），需要检查 x 的前继和后继节点的状态未被改变，并保证 x 节点从 head/tail 不可达（通过<code>updateHead()</code>和<code>updateTail()</code>方法）。</li></ul><ol><li>如果操作节点为 first 节点（入列和出列都发生在 first 端），则调用<code>unlinkFirst</code>解除已删除节点的链接，并链接 first 节点到下一个 active 节点（注意，在执行完此方法之后 first 节点是没有改变的）。<code>unlinkFirst</code>源码如下：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkFirst</span>(<span class="params">Node&lt;E&gt; first, Node&lt;E&gt; next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// assert first != null;</span></span><br><span class="line">    <span class="comment">// assert next != null;</span></span><br><span class="line">    <span class="comment">// assert first.item == null;</span></span><br><span class="line">    <span class="comment">//从next节点开始向后寻找有效节点，o：已删除节点(item为null)</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; o = <span class="literal">null</span>, p = next, q;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="literal">null</span> || (q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//跳过已删除节点，CAS替换first的next节点为一个active节点p</span></span><br><span class="line">            <span class="keyword">if</span> (o != <span class="literal">null</span> &amp;&amp; p.prev != p &amp;&amp; first.casNext(next, p)) &#123;</span><br><span class="line">                <span class="comment">//更新p的prev节点</span></span><br><span class="line">                skipDeletedPredecessors(p);</span><br><span class="line">                <span class="keyword">if</span> (first.prev == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    (p.next == <span class="literal">null</span> || p.item != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                    p.prev == first) &#123;</span><br><span class="line">                    <span class="comment">//更新head节点，确保已删除节点o从head不可达(unlinking)</span></span><br><span class="line">                    updateHead(); <span class="comment">// Ensure o is not reachable from head</span></span><br><span class="line">                    <span class="comment">//更新tail节点，确保已删除节点o从tail不可达(unlinking)</span></span><br><span class="line">                    updateTail(); <span class="comment">// Ensure o is not reachable from tail</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Finally, actually gc-unlink</span></span><br><span class="line">                    <span class="comment">//使unlinking节点next指向自身</span></span><br><span class="line">                    o.lazySetNext(o);</span><br><span class="line">                    <span class="comment">//设置移除节点的prev为PREV_TERMINATOR</span></span><br><span class="line">                    o.lazySetPrev(prevTerminator());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)<span class="comment">//自链接节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            o = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果操作节点为 last 节点（入列和出列都发生在 last 端），则调用<code>unlinkLast</code>解除已删除节点的链接，并链接 last 节点到上一个 active 节点。<code>unlinkLast</code>与<code>unlinkFirst</code>方法执行流程一致，只是操作的是 last 端，在此不多赘述。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章与 ConcurrentLinkedQueue 一篇中的非阻塞算法基本一致，只是为双端操作定义了几个可供操作的节点类型。<br>本章重点：<strong>理解 ConcurrentLinkedDeque 的非阻塞算法及节点删除的三个状态</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC源码分析-集合篇（五）：ConcurrentLinkedDeque&quot;&gt;&lt;a href=&quot;#JUC源码分析-集合篇（五）：ConcurrentLinkedDeque&quot; class=&quot;headerlink&quot; title=&quot;JUC源码分析-集合篇（五）：Concu
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="ConcurrentLinkedDeque" scheme="https://www.vazh.cn/tags/ConcurrentLinkedDeque/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇（四）：ConcurrentLinkedQueue</title>
    <link href="https://www.vazh.cn/2020/05/04/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AConcurrentLinkedQueue/"/>
    <id>https://www.vazh.cn/2020/05/04/JUC源码分析-集合篇（四）：ConcurrentLinkedQueue/</id>
    <published>2020-05-04T07:52:39.000Z</published>
    <updated>2020-05-04T07:56:05.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC源码分析-集合篇（四）：ConcurrentLinkedQueue"><a href="#JUC源码分析-集合篇（四）：ConcurrentLinkedQueue" class="headerlink" title="JUC源码分析-集合篇（四）：ConcurrentLinkedQueue"></a>JUC源码分析-集合篇（四）：ConcurrentLinkedQueue</h1><blockquote><p>Queue 是“生产者-消费者”模型的重要实现，在实际应用中，众多消息系统（例如RocketMQ、ActiveMQ等）都是基于Queue的思想来实现。从本篇开始，我们会对JUC中所有的Queue进行逐一讲解。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>ConcurrentLinkedQueue 是<strong>单向链表结构的无界并发队列</strong>。从JDK1.7开始加入到J.U.C的行列中。使用CAS实现并发安全，元素操作按照 FIFO (first-in-first-out 先入先出) 的顺序。适合“单生产，多消费”的场景。<br>内存一致性遵循<strong>对ConcurrentLinkedQueue的插入操作先行发生于(happen-before)访问或移除操作</strong>。</p></blockquote><p>ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面四点（后面源码解析中都会有详细说明）：</p><ol><li>使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。</li><li>head/tail 节点都允许滞后，也就是说它们并非总是指向队列的头/尾节点，这是因为并不是每次操作队列都更新 head/tail，和 LinkedTransferQueue 一样，使用了一个“松弛阀值（2）”， 当前指针距离 head/tail 节点大于2时才会更新 head/tail，这也是一种优化方式，减少了CAS指令的执行次数。</li><li>由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 对节点使用了“不变性”和“可变性”来约束非阻塞算法的正确性（后面会详细说明）。</li><li>使用“自链接”方式管理出队节点，这样一个自链接节点意味着需要从head向后推进。</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/6050820-b287cb4375ab3641.png?imageMogr2/auto-orient/strip|imageView2/2/w/684/format/webp" alt="img"></p><p>ConcurrentLinkedQueue 继承关系</p><p>ConcurrentLinkedQueue 继承了AbstractQueue，使用Node存储数据，Node是一个单向链表，内部存储元素和下一个节点的引用。ConcurrentLinkedQueue 内部只有两个属性：head 和 tail：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br></pre></td></tr></table></figure><p>首先来看一下上面提到的节点的“不变性”和“可变性”，在 ConcurrentLinkedQueue 中，通过这些性质来约束非阻塞算法的正确性。</p><p><strong>基本不变性：</strong></p><ul><li>当入队插入新节点之后，队列中有一个 next 域为 null （最后一个）的节点。</li><li>从 head 开始遍历队列，可以访问所有 item 域不为 null 的节点。</li></ul><p><strong>head / tail 的不变性</strong></p><ul><li>所有live节点（指未删除节点），都能从 head 通过调用 succ() 方法遍历可达</li><li>通过 tail 调用 succ() 方法，最后节点总是可达的。</li><li>head 节点的 next 域不能引用到自身。</li><li>head / tail 不能为 null。</li></ul><p><strong>head / tail 的可变性：</strong></p><ul><li>head / tail 节点的 item 域可能为 null，也可能不为 null。</li><li>允许 tail 滞后（lag behind）于 head。也就是说，从 head 开始遍历队列，不一定能到达 tail。</li><li>tail 节点的 next 域可以引用到自身。</li></ul><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="offer-E-e"><a href="#offer-E-e" class="headerlink" title="offer(E e)"></a>offer(E e)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**添加节点到队列尾*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">//自旋,t:尾节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;<span class="comment">//p为尾节点</span></span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;<span class="comment">//cas替换p的next节点为新节点</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// 跳两个节点以上时才修改tail</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// cas替换尾节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// p节点指向自身，说明p是一个自链节点，此时需要重新获取tail节点，</span></span><br><span class="line">            <span class="comment">// 如果tail节点被其他线程修改，此时需要从head开始向后遍历，因为</span></span><br><span class="line">            <span class="comment">// 从head可以到达所有的live节点。</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            <span class="comment">//继续向后查找，如果tail节点变化，重新获取tail</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> ConcurrentLinkedQueue 提供了两个添加元素的方法（因为实现了 Queue 和 Collection 接口）：一个是 Queue 的<code>offer</code>方法， 另外一个是 Collection 的<code>add</code>方法，<code>add</code>也是调用<code>offer</code>来实现。新增元素时，把元素放到链表尾部，由于队列是无界的，所以插入时不会返回<code>false</code>或者抛出<code>IllegalStateException</code>。函数逻辑很简单：从<code>tail</code>节点向后自旋查找 next 为 null 的节点，也就是最后一个节点（因为 tail 节点并不是每次都更新，所以我们取到的 tail 节点有可能并不是最后一个节点），然后CAS插入新增节点。<br>上面我们提到过：并不是每次操作都会更新 <code>head/tail</code> 节点，而是使用了一个“松弛阀值”，这个“松弛阀值”就体现在上面源码中<code>if (p != t)</code>这一行，<code>p</code>初始是等于<code>tail</code>的，如果向后查找了一次以上才找到最后一个节点，再加上新增的节点，说明<code>tail</code>已经跳跃了两个（或以上）节点，此时才会CAS更新<code>tail</code>，这里也算是一种编程技巧。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E poll() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//从head节点向后查找第一个live节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;<span class="comment">//找到第一个节点，cas修改节点item为null</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// 跳两个节点以上时才修改head</span></span><br><span class="line">                    <span class="comment">//cas修改head节点</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;<span class="comment">//队列已空，返回null</span></span><br><span class="line">                updateHead(h, p);<span class="comment">//cas修改head节点为p</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)<span class="comment">//p为自链接节点，重新获取head循环</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;<span class="comment">//跳转到restartFromHead重新循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;<span class="comment">//向后查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> ConcurrentLinkedQueue 提供了两个获取节点的方法：<code>poll()</code>和<code>peek()</code>，两个方法都返回头节点元素，不同之处在于<code>poll()</code>会移除头节点，而<code>peek()</code>则不会移除。可以说<code>peek()</code>是<code>poll()</code>的一部分，所以这里我们只介绍<code>poll()</code>。函数执行流程如下：<br>从head节点开始向后查找第一个live（item不为空）节点，CAS修改节点的<code>item</code>为null，并返回节点的item。和<code>offer(E e)</code>一样，<code>poll()</code>也使用了“松弛阀值”，跳两个或以上节点时才会更新<code>head</code>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章重点：理解 ConcurrentLinkedQueue 的非阻塞算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC源码分析-集合篇（四）：ConcurrentLinkedQueue&quot;&gt;&lt;a href=&quot;#JUC源码分析-集合篇（四）：ConcurrentLinkedQueue&quot; class=&quot;headerlink&quot; title=&quot;JUC源码分析-集合篇（四）：Concu
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="Queue" scheme="https://www.vazh.cn/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇（三）：ConcurrentSkipListMap和ConcurrentSkipListSet</title>
    <link href="https://www.vazh.cn/2020/05/03/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AConcurrentSkipListMap%E5%92%8CConcurrentSkipListSet/"/>
    <id>https://www.vazh.cn/2020/05/03/JUC源码分析-集合篇（三）：ConcurrentSkipListMap和ConcurrentSkipListSet/</id>
    <published>2020-05-02T23:51:09.000Z</published>
    <updated>2020-05-02T23:51:09.157Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet</title>
    <link href="https://www.vazh.cn/2020/05/03/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ACopyOnWriteArrayList%E5%92%8CCopyOnWriteArraySet/"/>
    <id>https://www.vazh.cn/2020/05/03/JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet/</id>
    <published>2020-05-02T23:38:24.000Z</published>
    <updated>2020-05-06T06:33:00.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet"></a>JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet</h1><p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，通过内部的 volatile 数组和显式锁 ReentrantLock 来实现线程安全。而 CopyOnWriteArraySet 是线程安全的 Set，它是由 CopyOnWriteArrayList 实现，内部持有一个 CopyOnWriteArrayList 引用，所有的操作都是由 CopyOnWriteArrayList 来实现的，区别就是 CopyOnWriteArraySet 是无序的，并且不允许存放重复值。由于是一个Set，所以也不支持随机索引元素。本章我们重点介绍 CopyOnWriteArrayList。</p><p>和 ArrayList 或 Set 相比，CopyOnWriteArrayList / CopyOnWriteArraySet 拥有以下特性：</p><ol><li>适合元素比较少，并且读取操作高于更新(add/set/remove)操作的场景</li><li>由于每次更新需要复制内部数组，所以更新操作开销比较大</li><li>内部的迭代器 iterator 使用了“快照”技术，存储了内部数组快照， 所以它的 iterator 不支持remove、set、add操作，但是通过迭代器进行并发读取时效率很高。</li></ol><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h5 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存储元素的内部数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList 实现非常简单。内部使用了一个 volatile 数组(array)来存储数据，保证了多线程环境下的可见性。在更新数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给 array。正由于这个原因，涉及到数据更新的操作效率很低。</p><p>由于 CopyOnWriteArrayList 源码比较简单，内部都是对数组的操作，所以咱们这里以<code>add</code>方法为例，其他方法就不一一分析了。</p><h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> index, E element</span>)</span> &#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                    <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="comment">//计算偏移量</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//作为add(E)处理</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//调用native方法根据index拷贝原数组的前半段</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">//拷贝后半段</span></span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                    numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System中arrayCopy的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> native <span class="keyword">void</span> <span class="title">arraycopy</span>(<span class="params">Object src,  <span class="keyword">int</span>  srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 还是那句话，非常简单，通过<code>add()</code>方法就可以看出整个 CopyOnWriteArrayList 的实现就是操作内部数组。首先通过<code>lock</code>加锁，新建一个原数组长度加1的新数组，将原数组（<code>array</code>）的数据拷贝到新数组中，如果给定索引（<code>index</code>）不是原数组最后一个索引，就分两部分拷贝， 然后将给定元素放到新数组中给定索引处；最后，将新数组赋值给<code>array</code>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在整个java.util.concurrent框架里，这两兄弟可以说是最简单的两个类了。操作直观，没有复杂的运算逻辑。本章重点：<strong>CopyOnWriteArrayList 是通过拷贝数组来实现内部元素操作的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet&quot;&gt;&lt;a href=&quot;#JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet&quot; class=&quot;h
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="List" scheme="https://www.vazh.cn/tags/List/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.vazh.cn/2020/05/02/test/"/>
    <id>https://www.vazh.cn/2020/05/02/test/</id>
    <published>2020-05-02T13:28:33.697Z</published>
    <updated>2020-05-02T13:28:33.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解happens-before规则"><a href="#深入理解happens-before规则" class="headerlink" title="深入理解happens-before规则"></a>深入理解happens-before规则</h1><h3 id="为什么会有happens-before-规则？"><a href="#为什么会有happens-before-规则？" class="headerlink" title="为什么会有happens-before 规则？"></a>为什么会有happens-before 规则？</h3><p>因为jvm会对代码进行编译优化，指令会出现重排序的情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">        v = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里x会是多少呢</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抛出问题：假设有两个线程A和B，A执行了writer方法，B执行reader方法，那么B线程中独到的变量x的值会是多少呢？</p></blockquote><p>jdk1.5之前，线程B读到的变量x的值可能是0，也可能是42，jdk1.5之后，变量x的值就是42了。原因是jdk1.5中，对volatile的语义进行了增强。来看一下happens-before规则在这段代码中的体现。</p><h3 id="1-规则一：程序的顺序性规则"><a href="#1-规则一：程序的顺序性规则" class="headerlink" title="1. 规则一：程序的顺序性规则"></a>1. 规则一：程序的顺序性规则</h3><blockquote><p>一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。</p></blockquote><p>对于这一点，可能会有疑问。顺序性是指，我们可以按照顺序推演程序的执行结果，但是编译器未必一定会按照这个顺序编译，但是编译器保证结果一定==顺序推演的结果。</p><h3 id="2-规则二：volatile规则"><a href="#2-规则二：volatile规则" class="headerlink" title="2. 规则二：volatile规则"></a>2. 规则二：volatile规则</h3><blockquote><p>对一个volatile变量的写操作，happens-before后续对这个变量的读操作。</p></blockquote><h3 id="3-规则三：传递性规则"><a href="#3-规则三：传递性规则" class="headerlink" title="3. 规则三：传递性规则"></a>3. 规则三：传递性规则</h3><blockquote><p>如果A happens-before B，B happens-before C，那么A happens-before C。</p></blockquote><p>jdk1.5的增强就体现在这里。回到上面例子中，线程A中，根据规则一，对变量x的写操作是happens-before对变量v的写操作的，根据规则二，对变量v的写操作是happens-before对变量v的读操作的，最后根据规则三，也就是说，线程A对变量x的写操作，一定happens-before线程B对v的读操作，那么线程B在注释处读到的变量x的值，一定是42.</p><h3 id="4-规则四：管程中的锁规则"><a href="#4-规则四：管程中的锁规则" class="headerlink" title="4.规则四：管程中的锁规则"></a>4.规则四：管程中的锁规则</h3><blockquote><p>对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。</p></blockquote><p>这一点不难理解。</p><h3 id="5-规则五：线程start-规则"><a href="#5-规则五：线程start-规则" class="headerlink" title="5.规则五：线程start()规则"></a>5.规则五：线程start()规则</h3><blockquote><p>主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。也就是start() happens before 线程B中的操作。</p></blockquote><h3 id="6-规则六：线程join-规则"><a href="#6-规则六：线程join-规则" class="headerlink" title="6.规则六：线程join()规则"></a>6.规则六：线程join()规则</h3><blockquote><p>主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解happens-before规则&quot;&gt;&lt;a href=&quot;#深入理解happens-before规则&quot; class=&quot;headerlink&quot; title=&quot;深入理解happens-before规则&quot;&gt;&lt;/a&gt;深入理解happens-before规则&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇(九):LinkedBlockingQueue</title>
    <link href="https://www.vazh.cn/2020/04/26/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%B9%9D-LinkedBlockingQueue/"/>
    <id>https://www.vazh.cn/2020/04/26/JUC源码分析-集合篇-九-LinkedBlockingQueue/</id>
    <published>2020-04-26T02:37:24.000Z</published>
    <updated>2020-05-27T11:55:53.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC源码分析-集合篇-九-LinkedBlockingQueue"><a href="#JUC源码分析-集合篇-九-LinkedBlockingQueue" class="headerlink" title="JUC源码分析-集合篇(九):LinkedBlockingQueue"></a>JUC源码分析-集合篇(九):LinkedBlockingQueue</h1><blockquote><p>LinkedBlockingQueue 是<strong>单向链表结构的自定义容量的阻塞队列</strong>，元素操作按照<strong>FIFO(first-in-first-out 先入先出)</strong>的顺序，使用显式锁 ReentrantLock 和 Condition 来保证线程安全。链表结构的队列通常比基于数组的队列（ArrayBlockingQueue）有更高的吞吐量，但是在并发环境下性能却不如数组队列。因为比较简单，本章本来是不在笔者的写作范围内的，但是在后面的线程池源码中用到了LinkedBlockingQueue，我们我们就来简单看一下，加深一下印象。</p></blockquote><p>本章应该是队列篇的终章了，还有LinkedBlockingDeque、ArrayBlockingQueue这些比较简单的队列就不再讲解了，后面我们会开始线程池相关源码分析。</p><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>LinkedBlockingQueue（后称LBQ）队列容量可通过参数来自定义，并且内部是不会自动扩容的。如果未指定容量，将取最大容量<code>Integer.MAX_VALUE</code>。 如果你理解了前几篇我们所讲的队列，那么你会发现 LBQ 非常容易理解，内部没有太多复杂的算法，数据结构也是使用了简单的链表结构。</p></blockquote><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/6050820-1abdfd11c930afd5.png?imageMogr2/auto-orient/strip|imageView2/2/w/581/format/webp" alt="img"></p><p>LinkedBlockingQueue 继承关系</p><p>标准的队列继承关系，不多赘述。</p><h5 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表头</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出列锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待获取(出队)条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入列锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待插入(入列)条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>LBQ 在实现多线程对竞争资源的互斥访问时，对于入列和出列操作分别使用了不同的锁。对于入列操作，通过<code>putLock</code>进行同步；对于出列操作，通过<code>takeLock</code>进行同步。<br>此外，插入锁<code>putLock</code>和出列条件<code>notFull</code>相关联，出列锁<code>takeLock</code>和出列条件<code>notEmpty</code>相关联。通过<code>notFull</code>和<code>notEmpty</code>更细腻的控制锁。</p><ul><li>若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行<code>notEmpty.await()</code>进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用<code>notEmpty.signal()</code>唤醒<code>notEmpty</code>上的等待线程。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取<code>takeLock</code>，在取操作执行完毕再释放<code>takeLock</code>。</li><li>若某线程(线程H)要插入数据时，队列已满，则该线程会它执行<code>notFull.await()</code>进行等待；当其它某个线程(线程I)取出数据之后，会调用<code>notFull.signal()</code>唤醒<code>notFull</code>上的等待线程。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取<code>putLock</code>，在插入操作执行完毕才释放<code>putLock</code>。</li></ul><hr><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="put-E-e"><a href="#put-E-e" class="headerlink" title="put(E e)"></a>put(E e)</h2><p>LBQ 的添加元素的方法有<code>offer()、put()</code>，<code>put</code>是在队列已满的情况下等待，而<code>offer</code>则直接返回结果，它们内部操作都一致。所这里我们只对<code>put</code>进行解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾部插入节点,队列满时会一直等待可用,响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;<span class="comment">//获取入列锁</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;<span class="comment">//获取元素数</span></span><br><span class="line">    putLock.lockInterruptibly();<span class="comment">//响应中断式加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();<span class="comment">//队列已满，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);<span class="comment">//节点添加到队列尾</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：看源码吧。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><p>LBQ 的获取元素的方法有<code>poll()、take()、peek()</code>，<code>take</code>在队列为空的情况下会一直等待，<code>poll</code>不等待直接返回结果，<code>peek</code>是获取但不移除头结点元素，内部操作都差不多。这里我们只对<code>take</code>进行解析：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**获取并消除头节点,会一直等待队列可用,响应中断*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">E</span> take() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">    <span class="type">E</span> x;</span><br><span class="line">    int <span class="built_in">c</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="built_in">count</span> = this.<span class="built_in">count</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = this.takeLock;<span class="comment">//获取出列锁</span></span><br><span class="line">    takeLock.lockInterruptibly();<span class="comment">//响应中断式加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span>.<span class="keyword">get</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();<span class="comment">//队列为空，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();<span class="comment">//首节点出列</span></span><br><span class="line">        <span class="built_in">c</span> = <span class="built_in">count</span>.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">c</span> &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">c</span> == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章比较简单，只是为了加深同学们的印象，为之后线程池源码解析做准备，随便看看就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC源码分析-集合篇-九-LinkedBlockingQueue&quot;&gt;&lt;a href=&quot;#JUC源码分析-集合篇-九-LinkedBlockingQueue&quot; class=&quot;headerlink&quot; title=&quot;JUC源码分析-集合篇(九):LinkedBlock
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇(二):CopyOnWriteArrayList和CopyOnWriteArraySet</title>
    <link href="https://www.vazh.cn/2020/04/26/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%BA%8C-CopyOnWriteArrayList%E5%92%8CCopyOnWriteArraySet/"/>
    <id>https://www.vazh.cn/2020/04/26/JUC源码分析-集合篇-二-CopyOnWriteArrayList和CopyOnWriteArraySet/</id>
    <published>2020-04-26T02:36:14.000Z</published>
    <updated>2020-04-26T02:36:14.848Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇(一):ConcurrentHashMap</title>
    <link href="https://www.vazh.cn/2020/04/26/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%B8%80-ConcurrentHashMap/"/>
    <id>https://www.vazh.cn/2020/04/26/JUC源码分析-集合篇-一-ConcurrentHashMap/</id>
    <published>2020-04-26T02:35:23.000Z</published>
    <updated>2020-04-26T08:18:32.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ConcurrentHashMap 是一个支持并发检索和并发更新的线程安全的HashMap（但不允许空key或value）。不管是在实际工作或者是面试中，ConcurrentHashMap 都是在整个JUC集合框架里出现频率最高的一个类，所以，对ConcurrentHashMap有一个深入的认识对我们自身还是非常重要的。本章我们来从源码层面详细分析 ConcurrentHashMap 的实现（基于JDK 8），希望对大家有所帮助。</p></blockquote><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote><p>ConcurrentHashMap 在JDK 7之前是通过Lock和Segment（分段锁）实现并发安全，JDK 8之后改为CAS+synchronized来保证并发安全（为了序列化兼容，JDK 8的代码中还是保留了Segment的部分代码）。由于笔者没有过多研究过JDK 7的源码，所以我们后面的分析主要针对JDK 8。</p></blockquote><p>首先来看一下ConcurrentHashMap、HashMap和HashTable的区别：</p><ul><li>HashMap 是非线程安全的哈希表，常用于单线程程序中。</li><li>Hashtable 是线程安全的哈希表，由于是通过内置锁 synchronized 来保证线程安全，在资源争用比较高的环境下，Hashtable 的效率比较低。</li><li>ConcurrentHashMap 是一个支持并发操作的线程安全的HashMap，但是他不允许存储空key或value。使用CAS+synchronized来保证并发安全，在并发访问时不需要阻塞线程，所以效率是比Hashtable 要高的。</li></ul><h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h1><p><img src="https:////upload-images.jianshu.io/upload_images/6050820-225eef139360d82d.png?imageMogr2/auto-orient/strip|imageView2/2/w/727/format/webp" alt="img"></p><p>ConcurrentHashMap数据结构</p><p>ConcurrentHashMap 是通过Node来存储K-V的，从上图可以看出，它的内部有很多Node节点（在内部封装了一个Node数组-<code>table</code>），不同的节点有不同的作用。下面我们来详细看一下这几个Node节点类：</p><p><img src="https:////upload-images.jianshu.io/upload_images/6050820-0100f88e72b6ae94.png?imageMogr2/auto-orient/strip|imageView2/2/w/1045/format/webp" alt="img"></p><p>Node</p><ol><li><strong>Node：</strong> 保存k-v、k的<code>hash</code>值和链表的 next 节点引用，其中 V 和 next 用<code>volatile</code>修饰，保证多线程环境下的可见性。</li><li><strong>TreeNode：</strong> 红黑树节点类,当链表长度&gt;=8且数组长度&gt;=64时，Node 会转为 TreeNode，但它不是直接转为红黑树，而是把这些 TreeNode 节点放入TreeBin 对象中，由 TreeBin 完成红黑树的封装。</li><li><strong>TreeBin：</strong> 封装了 TreeNode，红黑树的根节点，也就是说在 ConcurrentHashMap 中红黑树存储的是 TreeBin 对象。</li><li><strong>ForwardingNode：</strong> 在节点转移时用于连接两个 table（table和nextTable）的节点类。包含一个 nextTable 指针，用于指向下一个table。而且这个节点的 k-v 和 next 指针全部为 null，hash 值为-1。只有在扩容时发挥作用，作为一个占位节点放在 table 中表示当前节点已经被移动。</li><li><strong>ReservationNode：</strong> 在<code>computeIfAbsent</code>和<code>compute</code>方法计算时当做一个占位节点，表示当前节点已经被占用，在<code>compute</code>或<code>computeIfAbsent</code>的 function 计算完成后插入元素。hash值为-3。</li></ol><h2 id="2-1-核心参数"><a href="#2-1-核心参数" class="headerlink" title="2.1 核心参数"></a>2.1 核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//数组最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//默认并发度，兼容1.7及之前版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//加载/扩容因子，实际使用n - (n &gt;&gt;&gt; 2)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//链表转红黑树的节点数阀值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//红黑树转链表的节点数阀值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//当数组长度还未超过64,优先数组的扩容,否则将链表转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//扩容时任务的最小转移节点数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//sizeCtl中记录stamp的位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//帮助扩容的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//size在sizeCtl中的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放Node元素的数组,在第一次插入数据时初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//一个过渡的table表,只有在扩容的时候才会使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">//基础计数器值(size = baseCount + CounterCell[i].value)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">//控制table初始化和扩容操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">//节点转移时下一个需要转移的table索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="comment">//元素变化时用于控制自旋</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="comment">// 保存table中的每个节点的元素个数 2的幂次方</span></span><br><span class="line"><span class="comment">// size = baseCount + CounterCell[i].value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><p><strong>table</strong>：Node数组，在第一次插入元素的时候初始化，默认初始大小为16，用来存储Node节点数据，扩容时大小总是2的幂次方。</p><p><strong>nextTable</strong>：默认为null，扩容时生成的新的数组，其大小为原数组的两倍。</p><p><strong>sizeCtl</strong>  ：默认为0，用来控制table的初始化和扩容操作，在不同的情况下有不同的涵义：</p><ul><li>-1 代表table正在初始化</li><li>-N 表示有N-1个线程正在进行扩容操作</li><li>初始化数组或扩容完成后,将<code>sizeCtl</code>的值设为0.75*n</li><li>在扩容操作在进行节点转移前，<code>sizeCtl</code>改为<code>(hash &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>，这个值为负数，并且每有一个线程参与扩容操作<code>sizeCtl</code>就加1</li></ul><p><strong>transferIndex</strong>：扩容时用到，初始时为<code>table.length</code>，表示从索引 0 到<code>transferIndex</code>的节点还未转移 。</p><p><strong>counterCells</strong>： ConcurrentHashMap的特定计数器，实现方法跟<code>LongAdder</code>类似。这个计数器的机制避免了在更新时的资源争用，但是如果并发读取太频繁会导致缓存超负荷，为了避免读取太频繁，只有在添加了两个以上节点时才可以尝试扩容操作。在统一hash分配的前提下，发生这种情况的概率在13%左右，也就是说只有大约1/8的put操作才会检查扩容（并且在扩容后会更少）。</p><p><strong>hash计算公式</strong>：<code>hash = (key.hashCode ^ (key.hashCode &gt;&gt;&gt; 16)) &amp; HASH_BITS</code><br> <strong>索引计算公式</strong>：<code>(table.length-1)&amp;hash</code></p><h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><h2 id="3-1-put-K-V"><a href="#3-1-put-K-V" class="headerlink" title="3.1 put(K, V)"></a>3.1 put(K, V)</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, <span class="keyword">value</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function">final V <span class="title">putVal</span>(<span class="params">K key, V <span class="keyword">value</span>, boolean onlyIfAbsent</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="keyword">value</span> == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//f:索引节点; n:tab.length; i:新节点索引 (n - 1) &amp; hash; fh:f.hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;<span class="comment">//索引i节点为空，直接插入</span></span><br><span class="line">            <span class="comment">//cas插入节点,成功则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点处于移动状态-其他线程正在进行节点转移操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助转移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="literal">null</span>;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//check stable</span></span><br><span class="line">                    <span class="comment">//f.hash&gt;=0,说明f是链表的头结点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;<span class="comment">//记录链表节点数，用于后面是否转换为红黑树做判断</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//key相同 修改</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.<span class="keyword">equals</span>(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = <span class="keyword">value</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//到这里说明已经是链表尾，把当前值作为新的节点插入到队尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          <span class="keyword">value</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树节点操作</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       <span class="keyword">value</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = <span class="keyword">value</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新新元素个数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>在 ConcurrentHashMap 中，put 方法几乎涵盖了所有内部的函数操作。所以，我们将从put函数开始逐步向下分析。<br> 首先说一下put的流程，后面再详细分析每一个流程的具体实现（阅读时请结合源码）：</p><ol><li>计算当前key的hash值，根据hash值计算索引 i <code>（i=(table.length - 1) &amp; hash）</code>；</li><li>如果当前<code>table</code>为null，说明是第一次进行put操作，调用<code>initTable()</code>初始化<code>table</code>；</li><li>如果索引 i 位置的节点 f 为空，则直接把当前值作为新的节点直接插入到索引 i 位置；</li><li>如果节点 f 的<code>hash</code>为-1（<code>f.hash == MOVED(-1)</code>），说明当前节点处于移动状态（或者说是其他线程正在对 f 节点进行转移/扩容操作），此时调用<code>helpTransfer(tab, f)</code>帮助转移/扩容；</li><li>如果不属于上述条件，说明已经有元素存储到索引 i 处，此时需要对索引 i 处的节点 f 进行 put or update 操作，首先使用内置锁 <code>synchronized</code> 对节点 f 进行加锁：</li></ol><ul><li>如果<code>f.hash&gt;=0</code>，说明 i 位置是一个链表，并且节点 f 是这个链表的头节点，则对 f 节点进行遍历，此时分两种情况：<br> –如果链表中某个节点e的hash与当前key的hash相同，则对这个节点e的value进行修改操作。<br> –如果遍历到链表尾都没有找到与当前key的hash相同的节点，则把当前K-V作为一个新的节点插入到这个链表尾部。</li><li>如果节点 f 是<code>TreeBin</code>节点(<code>f instanceof TreeBin</code>)，说明索引 i 位置的节点是一个红黑树，则调用<code>putTreeVal</code>方法找到一个已存在的节点进行修改，或者是把当前K-V放入一个新的节点（put or update）。</li></ul><ol><li>完成插入后，如果索引 i 处是一个链表，并且在插入新的节点后节点数&gt;8，则调用<code>treeifyBin</code>把链表转换为红黑树。</li><li>最后，调用<code>addCount</code>更新元素数量</li></ol><h3 id="3-1-1-initTable"><a href="#3-1-1-initTable" class="headerlink" title="3.1.1 initTable()"></a>3.1.1 initTable()</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> final Node&lt;K,V&gt;[] <span class="title">initTable</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)<span class="comment">//其他线程正在进行初始化或转移操作，让出CPU执行时间片，继续自旋</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, <span class="number">-1</span>)) &#123;<span class="comment">//CAS设置sizectl为-1 表示当前线程正在进行初始化</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//0.75*n 设置扩容阈值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;<span class="comment">//初始化sizeCtl=0.75*n</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>初始化操作，ConcurrentHashMap的初始化在第一次插入数据的时候(判断table是否为null)，注意初始化操作为单线程操作（如果有其他线程正在进行初始化，则调用Thread.yield()让出CPU时间片，自旋等待table初始完成）。</p><h3 id="3-1-2-helpTransfer-Node-lt-K-V-gt-Node-lt-K-V-gt"><a href="#3-1-2-helpTransfer-Node-lt-K-V-gt-Node-lt-K-V-gt" class="headerlink" title="3.1.2 helpTransfer(Node&lt;K,V&gt;[], Node&lt;K,V&gt;)"></a>3.1.2 helpTransfer(Node&lt;K,V&gt;[], Node&lt;K,V&gt;)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帮助其他线程进行转移操作</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//计算操作栈校验码</span></span><br><span class="line">        int rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)<span class="comment">//不需要帮助转移，跳出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;<span class="comment">//CAS更新帮助转移的线程数</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 如果索引到的节点的 hash 为-1，说明当前节点处于移动状态（或者说是其他线程正在对 f 节点进行转移操作。这里主要是靠 ForwardingNode 节点来检测，在<code>transfer</code>方法中，被转移后的节点会改为ForwardingNode，它是一个占位节点，并且hash=MOVED（-1），也就是说，我们可以通过判断hash是否为MOVED来确定当前节点的状态），此时调用<code>helpTransfer(tab, f)</code>帮助转移，主要操作就是更新帮助转移的线程数（sizeCtl+1），然后调用<code>transfer</code>方法进行转移操作，<code>transfer</code>后面我们会详细分析。</p><h3 id="3-1-3-treeifyBin-Node-lt-K-V-gt-index"><a href="#3-1-3-treeifyBin-Node-lt-K-V-gt-index" class="headerlink" title="3.1.3 treeifyBin(Node&lt;K,V&gt;[] , index)"></a>3.1.3 treeifyBin(Node&lt;K,V&gt;[] , index)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当数组长度还未超过64,优先数组的扩容,否则将链表转为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                <span class="comment">//两倍扩容</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;<span class="comment">//check stable</span></span><br><span class="line">                        <span class="comment">//hd：节点头</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//遍历转换节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 在put操作完成后，如果当前节点为一个链表，并且链表长度&gt;=TREEIFY_THRESHOLD(8)，此时就需要调用<code>treeifyBin</code>方法来把当前链表转为一个红黑树。<code>treeifyBin</code>主要进行两步操作：</p><ol><li>如果当前table长度还未超过<code>MIN_TREEIFY_CAPACITY(64)</code>，则优先对数组进行扩容操作，容量为原来的2倍(n&lt;&lt;1)。</li><li>否则就对当前节点进行转换操作（注意这个操作是单线程完成的）。遍历链表节点，把Node转换为TreeNode，然后在通过TreeBin来构造红黑树（红黑树的构造这里就不在详细介绍了）。</li></ol><h3 id="3-1-4-tryPresize-int-size"><a href="#3-1-4-tryPresize-int-size" class="headerlink" title="3.1.4 tryPresize(int size)"></a>3.1.4 tryPresize(int size)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);<span class="comment">//计算一个近似size的2的幂次方数</span></span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">//未初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已达到最大容量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">//正在进行扩容操作</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 当table容量不足时，需要对其进行两倍扩容。<code>tryPresize</code>方法很简单，主要就是用来检查扩容前的必要条件（比如是否超过最大容量），真正的扩容其实也可以叫<strong>“节点转移”</strong>，主要是通过<code>transfer</code>方法完成。</p><h3 id="3-1-5-transfer-Node-lt-K-V-gt-tab-Node-lt-K-V-gt-nextTab"><a href="#3-1-5-transfer-Node-lt-K-V-gt-tab-Node-lt-K-V-gt-nextTab" class="headerlink" title="3.1.5 transfer(Node&lt;K,V&gt; tab, Node&lt;K,V&gt; nextTab)"></a>3.1.5 transfer(Node&lt;K,V&gt; tab, Node&lt;K,V&gt; nextTab)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移或复制节点到新的table</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//转移幅度( tab.length/(NCPU*8) )，最小为16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据当前数组长度,新建一个两倍长度的数组nextTab</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;<span class="comment">//初始为table的最后一个索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//初始化ForwardingNode节点,持有nextTab的引用,在处理完每个节点之后当做占位节点，表示该槽位已经处理过了</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;<span class="comment">//节点是否已经处理</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//自旋移动每个节点，从transferIndex开始移动stride个节点到新的table。</span></span><br><span class="line">    <span class="comment">//i：当前处理的Node索引；bound：需要处理节点的索引边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="comment">//f:当前处理i位置的node; fh:f.hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">//通过while循环获取本次需要移动的节点索引i</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">//nextIndex:下一个要处理的节点索引; nextBound:下一个需要处理的节点的索引边界</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)<span class="comment">//通过--i控制下一个需要移动的节点</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//节点已全部转移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//transferIndex（初值为最后一个节点的索引），表示从transferIndex开始后面所有的节点都已分配，</span></span><br><span class="line">            <span class="comment">//每次线程领取扩容任务后，需要更新transferIndex的值(transferIndex-stride)。</span></span><br><span class="line">            <span class="comment">//CAS修改transferIndex，并更新索引边界</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;<span class="comment">//已完成转移，更新相关属性</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">//1.5*n 扩容阈值设置为原来容量的1.5倍  依然相当于现在容量的0.75倍</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程已经完成转移，但可能还有其他线程正在进行转移操作</span></span><br><span class="line">            <span class="comment">//每个线程完成自己的扩容操作后就对sizeCtl-1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断是否全部任务已经完成,sizeCtl初始值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">                <span class="comment">//这里判断如果还有其他线程正在操作，直接返回，否则的话重新初始化i对原tab进行一遍检查然后再提交</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);<span class="comment">//i位置节点为空，替换为ForwardingNode节点，用于通知其他线程该位置已经处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//节点已经被其他线程处理过，继续处理下一个节点</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//check stable</span></span><br><span class="line">                    <span class="comment">//处理当前拿到的节点,构建两个node:ln/hn。ln:原位置; hn:i+n位置</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">//当前为链表节点（fh&gt;=0）</span></span><br><span class="line">                        <span class="comment">//使用fn&amp;n把原链表中的元素分成两份（fn&amp;n = n or 0）</span></span><br><span class="line">                        <span class="comment">//在表扩容2倍后，索引i可能发生改变，如果原table长度n=2^x，如果hash的x位为1，此时需要加上x位的值，也就是i+n；</span></span><br><span class="line">                        <span class="comment">//如果x位为0，索引i不变</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n; <span class="comment">// n or 0</span></span><br><span class="line">                        <span class="comment">//最后一个与头节点f索引不同的节点</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">//从索引i的节点开始向后查找最后一个有效节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;<span class="comment">//n or 0</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把f链表分解为两个链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="comment">//在原位置</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="comment">//i+n位置</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//nextTab的i位置插入一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//nextTab的i+n位置插入一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 如果该节点是红黑树结构，则构造树节点lo和hi，遍历红黑树中的节点，同样是根据hash&amp;tab.length算法，</span></span><br><span class="line"><span class="comment">                     * 把节点分为两类，分别插入索引i和(i+n)位置。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//转为根结点</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//低位(i)节点和低位尾节点</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//高位(i+n)节点和高位尾节点</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//从首个节点向后遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">//构建树节点</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">//原位置</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//i+n位置</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果扩容后已经不再需要tree的结构 反向转换为链表结构</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> <code>transfer</code>方法是table扩容的核心实现。由于 ConcurrentHashMap 的扩容是新建一个table，所以主要问题就是如何把旧table的元素转移到新的table上。所以，扩容问题就演变成了“节点转移”问题。首先总结一下需要转移节点（调用transfer）的几个条件：</p><ol><li>对table进行扩容时</li><li>在更新元素数目时(addCount方法)，元素总数&gt;=sizeCtl（sizeCtl=0.75n，达到扩容阀值），此时也需要扩容</li><li>在put操作时，发现索引节点正在转移(hash==MOVED)，此时需要帮助转移</li></ol><p>在进行节点转移之前，首先要做的就是重新初始化<code>sizeCtl</code>的值（<code>sizeCtl = (hash &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>），这个值是一个负值，用于标识当前table正在进行转移操作，并且每有一个线程参与转移，<code>sizeCtl</code>就加1。<code>transfer</code>执行步骤如下（请结合源码注释阅读）：</p><ol><li>计算转移幅度<code>stride</code>（或者说是当前线程需要转移的节点数），最小为16；</li><li>创建一个相当于当前 table 两倍容量的 Node 数组，转移完成后用作新的 table；</li><li>从<code>transferIndex</code>（初始为<code>table.length</code>，也就是 table 的最后一个节点）开始，依次向前处理<code>stride</code>个节点。前面介绍过，table 的每个节点都可能是一个链表结构，因为在 put 的时候是根据<code>(table.length-1)&amp;hash</code>计算出的索引，当插入新值时，如果通过 key 计算出的索引已经存在节点，那么这个新值就放在这个索引位节点的尾部(Node.next)。所以，在进行节点转移后，由于 table.length 变为原来的两倍，所以相应的索引也会改变，这时候就需要对链表进行分割，我们来看一下这个分割算法：</li></ol><ul><li>假设当前处理的节点 table[i]=f，并且它是一个链表结构，原table容量为 n=2x，索引计算公式为<code>i=(n - 1)&amp;hash</code>。在表扩张后，由于容量 n 变为 2x+1 = 2*2x，所以索引计算就变为<code>i=(2n - 1)&amp;hash</code>。如果 hash 的 x 位为0，则 hash&amp;(2x-1)=hash，此时 hash&amp;(2x-1) == hash&amp;(2x+1-1)，索引位 i 不变；如果 hash 的 x 位为1，则 hash&amp;2x=2x == n，在扩容后 x 变为 x+1，此时的索引需要加上 x 位的值，即 _i=hash&amp;(2x-1) + hash&amp;2x，也就是 i+n。举个栗子：设 n=100000 (25)，x=5，hash 为100101（x位是1）。n-1=011111，那么i=hash&amp;(n-1)=000101；扩容后容量变为m=1000000(26)，m-1=0111111，那么 i 就变成了 hash&amp;(m-1)=100101，也就是说新的索引位_i = i+n。</li><li>如果当前节点为红黑树结构，也是利用这个算法进行分割，不同的是，在分割完成之后，如果这两个新的树节点&lt;=6，则调用<code>untreeify</code>方法把树结构转为链表结构。</li></ul><ol><li>最后把操作过的节点都设为 ForwardingNode 节点（hash= MOVED，这样别的线程就可以检测到）。</li></ol><p><strong><code>transfer</code>操作完成后，table的结构变化如下：</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/6050820-b17f80ff4712285d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1092/format/webp" alt="img"></p><p>扩容之后的table变化</p><h3 id="3-1-6-addCount-long-int"><a href="#3-1-6-addCount-long-int" class="headerlink" title="3.1.6 addCount(long,int)"></a>3.1.6 addCount(long,int)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> final <span class="keyword">void</span> <span class="title">addCount</span>(<span class="params"><span class="keyword">long</span> x, <span class="keyword">int</span> check</span>)</span> &#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span>; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<span class="comment">//counterCells为null，CAS更新baseCount</span></span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        boolean uncontended = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">as</span> == <span class="literal">null</span> || (m = <span class="keyword">as</span>.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = <span class="keyword">as</span>[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.<span class="keyword">value</span>, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);<span class="comment">//在线程争用资源时，使用fullAddCount计算更新元素数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();<span class="comment">//计算元素总数，用于后面的扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//检查扩容</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">//其他线程在进行扩容操作</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> put操作全部完成后，别忘了更新元素数量。<code>addCount</code>用来更新 ConcurrentHashMap 的元素数，根据所传参数<code>check</code>决定是否检查扩容，如果需要，调用<code>transfer</code>方法进行扩容/节点转移。这里面有一个看起来比较复杂的方法<code>fullAddCount</code>，作用是在线程争用资源时，使用它来计算更新元素数。这个方法的实现类似于LongAdder的add（LongAdder在上面有简单介绍），源码在此就不再详细分析了，有兴趣的同学可以研究下。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>到此，ConcurrentHashMap的分析就告一段落了。总的来说源码比较复杂，真正理解它还是需要一些耐心的。重点是它的<strong>数据结构</strong>和<strong>扩容</strong>的实现。<br> ConcurrentHashMap 源码分析到此结束，希望对大家有所帮助，如您发现文章中有不妥的地方，请留言指正，谢谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ConcurrentHashMap 是一个支持并发检索和并发更新的线程安全的HashMap（但不允许空key或value）。不管是在实际工作或者是面试中，ConcurrentHashMap 都是在整个JUC集合框架里出现频率最高的一个类，所以，对C
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="ConcurrentHashMap" scheme="https://www.vazh.cn/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-集合篇:集合框架</title>
    <link href="https://www.vazh.cn/2020/04/26/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.vazh.cn/2020/04/26/JUC源码分析-集合篇-集合框架/</id>
    <published>2020-04-26T01:39:45.000Z</published>
    <updated>2020-04-26T08:15:04.619Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从JDK1.5开始，Java针对集合类提供了线程安全版本的实现，接下来我们将逐个分析JUC集合类的具体实现，本篇首先介绍一下整个JUC集合类的框架。</p></blockquote><h2 id="1-List和Set"><a href="#1-List和Set" class="headerlink" title="1. List和Set"></a>1. List和Set</h2><p><img src="https:////upload-images.jianshu.io/upload_images/6050820-eb04e136dc4f1541.png?imageMogr2/auto-orient/strip|imageView2/2/w/589/format/webp" alt="img"></p><p>java.util.concurrent：List和Set</p><ul><li><strong>CopyOnWriteArrayList</strong>：相当于线程安全的ArrayList，通过显式锁 ReentrantLock 实现线程安全。允许存储null值。</li><li><strong>CopyOnWriteArraySet</strong>：相当于线程安全的HashSet，内部使用 CopyOnWriteArrayList 实现。允许存储null值。</li><li>ConcurrentSkipListSet在Map中说明</li></ul><h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h2><p><img src="https:////upload-images.jianshu.io/upload_images/6050820-381a4dce355a08d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp" alt="img"></p><p>java.util.concurrent：Map</p><ul><li><strong>ConcurrentHashMap</strong>：线程安全的HashMap（但不允许空key或value），ConcurrentHashMap在JDK1.7之前是通过Lock和segment（分段锁）实现，1.8之后改为CAS+synchronized来保证并发安全。</li><li><strong>ConcurrentSkipListMap</strong>：跳表结构的并发有序哈希表。不允许存储null值。</li><li><strong>ConcurrentSkipListSet</strong>：跳表结构的并发有序集合。内部使用 ConcurrentSkipListMap 实现。不允许存储null值。</li></ul><h2 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h2><p><img src="https:////upload-images.jianshu.io/upload_images/6050820-d52f71c9ff9fe1e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>java.util.concurrent：Queue</p><ul><li><strong>ArrayBlockingQueue</strong>：<strong>数组实现的线程安全的有界的阻塞队列</strong>，使用Lock机制实现并发访问，队列元素使用 FIFO（先进先出）方式。</li><li><strong>LinkedBlockingQueue</strong>：<strong>单向链表实现的（指定大小）阻塞队列</strong>，使用Lock机制实现并发访问，队列元素使用 FIFO（先进先出）方式。</li><li><strong>LinkedBlockingDeque</strong>：<strong>双向链表实现的（指定大小）双向并发阻塞队列</strong>，使用Lock机制实现并发访问，该阻塞队列同时支持FIFO和FILO两种操作方式。</li><li><strong>ConcurrentLinkedQueue</strong>：<strong>单向链表实现的无界并发队列</strong>，通过CAS实现并发访问，队列元素使用 FIFO（先进先出）方式。</li><li><strong>ConcurrentLinkedDeque</strong>：<strong>双向链表实现的无界并发队列</strong>，通过CAS实现并发访问，该队列同时支持FIFO和FILO两种操作方式。</li><li><strong>DelayQueue</strong>：<strong>延时无界阻塞队列</strong>，使用Lock机制实现并发访问。队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。</li><li><strong>PriorityBlockingQueue</strong>：<strong>无界优先级阻塞队列</strong>，使用Lock机制实现并发访问。priorityQueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。</li><li><strong>SynchronousQueue</strong>：<strong>没有容量的同步队列</strong>，通过CAS实现并发访问，支持FIFO和FILO。</li><li><strong>LinkedTransferQueue</strong>：1.7新增，单向链表实现的无界阻塞队列，通过CAS实现并发访问，队列元素使用 FIFO（先进先出）方式。LinkedTransferQueue可以说是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集, 它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;从JDK1.5开始，Java针对集合类提供了线程安全版本的实现，接下来我们将逐个分析JUC集合类的具体实现，本篇首先介绍一下整个JUC集合类的框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-List和Set&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="集合" scheme="https://www.vazh.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码分析-数据结构(一)：HashMap</title>
    <link href="https://www.vazh.cn/2020/04/23/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80-%EF%BC%9AHashMap/"/>
    <id>https://www.vazh.cn/2020/04/23/JDK源码分析-数据结构-一-：HashMap/</id>
    <published>2020-04-23T03:23:46.000Z</published>
    <updated>2020-04-28T13:41:50.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将对HashMap（基于JDK1.8）的源码进行具体分析，包括<strong>构造方法</strong>以及<strong>增、删、改、查</strong>等基本操作。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="需要先了解的知识"><a href="#需要先了解的知识" class="headerlink" title="需要先了解的知识"></a>需要先了解的知识</h2><h3 id="将会用到的实例常量"><a href="#将会用到的实例常量" class="headerlink" title="将会用到的实例常量"></a>将会用到的实例常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;     <span class="comment">//默认初始容量，为2^4</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//最大容量，为2^30</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;     <span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;     <span class="comment">//树化阀值</span></span><br></pre></td></tr></table></figure><h3 id="将会用到的实例变量"><a href="#将会用到的实例变量" class="headerlink" title="将会用到的实例变量"></a>将会用到的实例变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;     <span class="comment">//加载因子</span></span><br><span class="line">  <span class="keyword">int</span> threshold;      <span class="comment">//扩容的阀值，当键值对的数量超过这个阀值就扩容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * table（一般称为哈希桶）在首次使用时初始化，并根据需要调整大小。</span></span><br><span class="line"><span class="comment">    * 分配时，长度始终是2的幂（某些情况下可以为0）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;     <span class="comment">//HashMap被结构修改的次数</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;     <span class="comment">//当前的键值对数量</span></span><br></pre></td></tr></table></figure><h3 id="Node（存储键值对的节点）"><a href="#Node（存储键值对的节点）" class="headerlink" title="Node（存储键值对的节点）"></a>Node（存储键值对的节点）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个节点的hashCode是将key和value的hashCode进行异或操作后得到的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置新的value，返回旧的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;   </span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有当两节点的key和value通过equals方法比较后都返回true时，equals方法才返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashMap的构造方法有4种。</p><h3 id="默认的构造方法"><a href="#默认的构造方法" class="headerlink" title="默认的构造方法"></a>默认的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载因子设置为默认的0.75f</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带一个Map类型参数的构造方法"><a href="#带一个Map类型参数的构造方法" class="headerlink" title="带一个Map类型参数的构造方法"></a>带一个Map类型参数的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;  <span class="comment">//加载因子设置为默认的0.75f</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造方法的作用是深拷贝一个HashMap</p><h3 id="带一个int参数的构造方法"><a href="#带一个int参数的构造方法" class="headerlink" title="带一个int参数的构造方法"></a>带一个int参数的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造方法直接调用另一构造方法，其参数的作用是指定初始化容量</p><h3 id="带两个int参数的构造方法"><a href="#带两个int参数的构造方法" class="headerlink" title="带两个int参数的构造方法"></a>带两个int参数的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param initialCapacity 指定的初始容量</span></span><br><span class="line"><span class="comment"> * @param loadFactor 指定的加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;     <span class="comment">//初始化容量不能大于2^30</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) <span class="comment">//加载因子必须大于0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;   <span class="comment">//指定加载因子</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);     <span class="comment">//根据指定初始容量获取扩容的阀值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看下是如何通过初始容量来获取扩容阀值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回的结果是一个大于或等于初始化容量的2^n，例如输入6，则返回8；输入16，则返回16。</p><h2 id="put方法（增）"><a href="#put方法（增）" class="headerlink" title="put方法（增）"></a>put方法（增）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法又调用了putVal方法，先看一下hash方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;  </span><br><span class="line">    <span class="comment">//h保存key的hashCode，最终返回的hash值是h和h无符号右移16位后的数进行异或操作</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要计算一个hash值，而不是直接用hashCode呢？</p><p>因为哈希桶容量通常是很小的，而hashCode是32位。所以在进行(n - 1) &amp; hashCode这个运算时，通常只能用上低16位。这可能会导致键值对在哈希桶中的分布不均匀，一些桶的链表过长。所以无符号右移16位就相当于把高16位推到了低16位，再与低16位进行异或操作，并把结果作为hash值，就间接地利用了高16位，从而可以在一定程度上使得键值对分布更加均匀，降低hash冲突的概率。</p><h3 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent"></a>putIfAbsent</h3><p>put方法插入元素时，如果该元素已存在，会将旧的value替换为新的value（实现改的效果），如果不希望旧的value被替换，可以使用putIfAbsent方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该方法同样是调用了putVal方法。在看putVal方法之前，需要先了解resize方法。</p><h3 id="resize方法（扩容）"><a href="#resize方法（扩容）" class="headerlink" title="resize方法（扩容）"></a>resize方法（扩容）</h3><p>该方法的作用是初始化或加倍哈希桶的容量，并返回新的哈希桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;     <span class="comment">//旧的哈希桶</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;  <span class="comment">//旧桶的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;     <span class="comment">//旧的扩容阀值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;     <span class="comment">//新桶容量和新的扩容阀值初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;   <span class="comment">//如果旧桶容量大于0</span></span><br><span class="line">        <span class="comment">//如果旧桶容量已经大于等于最大容量，则扩容阀值设置为最大值，并返回旧桶</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;   </span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新桶的容量设置为旧桶容量的两倍</span></span><br><span class="line">        <span class="comment">//如果新桶容量小于最大容量，并且旧桶容量大于默认初始容量，则将新的扩容阀值设置为旧扩容阀值的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧桶容量为0，但旧的扩容阀值大于0，那么将新桶容量设置为该扩容阀值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">//如果旧的桶容量和扩容阀值都为0</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="comment">//新桶容量设置为默认初始容量</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">//新的扩容阀值设置为：默认初始容量*默认加载因子</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果此时新的扩容阀值为0，对应情况为：旧桶容量为0但旧的扩容阀值大于0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;  <span class="comment">//ft为新桶容量*加载因子</span></span><br><span class="line">        <span class="comment">//当新桶容量和ft都小于最大容量时，新的扩容阀值为ft，否则为最大值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新扩容阀值</span></span><br><span class="line">    threshold = newThr;     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新的哈希桶</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; </span><br><span class="line">    <span class="comment">//更新哈希桶</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果旧哈希桶不为空，需要将旧哈希桶中的所有节点移动到新哈希桶</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;    <span class="comment">//e用于保存旧的节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;   <span class="comment">//将旧节点置空</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;   <span class="comment">//如果该节点后面没有节点（说明没有发生哈希冲突）</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 将当前节点放到新哈希桶的相应位置</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 注意：由于newCap的值为2^n，所以(newCap-1)与e.hash作与运算其实是一个</span></span><br><span class="line"><span class="comment">                     * 取模运算（e.hash对newCap取模），但这样写效率更高。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) &#123; <span class="comment">//如果当前节点是一棵红黑树</span></span><br><span class="line">                    <span class="comment">//需要先将树拆分，然后再移动到新哈希桶中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果当前节点是一个节点数小于8的链表</span></span><br><span class="line">                </span><br><span class="line">                    <span class="comment">//将原链表拆分为两个链表（low链表和high链表）</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">do</span> &#123;    <span class="comment">//当e不为null时执行该循环</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//将当前节点的hash值与oldCap作与运算（有两种结果，0或oldCap，而且这两种结果出现的概率各占50%）</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;   <span class="comment">//结果为0，加入low链表</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//结果为oldCap，加入high链表                            </span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//将low链表存在原索引上</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将high链表存在原索引加上旧桶容量上</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回新的哈希桶</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总共包含以下几个步骤：</p><ol><li>获取新哈希桶的容量，更新扩容阀值</li><li>创建新哈希桶，并更新哈希桶</li><li>将旧哈希桶中的所以节点移动到新哈希桶上</li><li>返回新的哈希桶</li></ol><h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当哈希桶为空或其长度为0时</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在resize方法中初始化哈希桶，并且将其长度赋给n</span></span><br><span class="line">        n = (tab = resize()).length;    </span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//i为新节点的索引，如果该索引对应的节点为空，说明没有哈希冲突，直接创建一个新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//发生哈希冲突</span></span><br><span class="line">        </span><br><span class="line">        Node&lt;K,V&gt; e;    <span class="comment">//e用于存储已存在的节点   </span></span><br><span class="line">        K k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p为新节点索引对应的原节点，k为p的key</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;   </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果p的哈希值和新节点相等，并且p的key和新节点的key通过equals方法比较后返回true，</span></span><br><span class="line"><span class="comment">             * 说明新节点已存在。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            e = p;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            <span class="comment">//如果p节点为红黑树</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//此时p节点为链表，将新节点放到链表的末尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//当链表的长度大于等于树化阀值（8）时，将链表转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    <span class="comment">//说明新节点已存在</span></span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果e不为空，说明新节点已存在</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果onlyIfAbsent为false或者旧的value为null，更新节点的value</span></span><br><span class="line">                e.value = value;    </span><br><span class="line">            &#125;                   </span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;    <span class="comment">//返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ++modCount;     <span class="comment">//结构修改次数加一</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) &#123;   <span class="comment">//当前键值对数量大于扩容阀值的时候</span></span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    &#125;              </span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//新加入的节点不重复时返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal方法的执行步骤如下：</p><ol><li>先判断哈希桶是否有初始化，没有初始化的话先初始化（所以哈希桶的初始化是发生在第一次添加元素的时候，之所以不在HashMap初始化的时候为哈希桶分配空间，是为了防止只创建集合而不添加元素时造成的空间浪费）</li><li>根据插入元素的hash值寻找相应的位置，判断该位置是否为空，为空则直接创建节点并插入，不为空时：<ol><li>判断是否存在相等的key</li><li>判断该位置存储的是红黑树还是链表，根据不同情况有不同的插入</li><li>插入完成后，如果key相等，则判断是否要替换value，并返回旧的value。</li></ol></li><li>更新修改次数、当前键值对数量。如果当前键值对数量超过了扩容阀值，则进行扩容操作。</li><li>能够执行到最后，说明插入的键值对是新的，没有旧value，所以返回null。</li></ol><h2 id="remove方法（删）"><a href="#remove方法（删）" class="headerlink" title="remove方法（删）"></a>remove方法（删）</h2><p>remove有两个重载方法：</p><p>删除指定key的remove方法，如果删除成功，返回删除键值对的value，否则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除指定键值对的remove，如果删除成功，返回true，否则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法都是调用了removeNode方法</p><h3 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//tab用于存储哈希桶，n存储哈希桶的容量,index存储hash值对应的哈希桶索引,p存储hash值所对应的头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果哈希桶不为空且长度大于0，并且该key存在对应的节点，才会执行删除操作，否则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e;   <span class="comment">//node存储要删除结点</span></span><br><span class="line">        K k; V v;   <span class="comment">//k存储p节点对应的key</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//如果要删除的节点的hash值和key都与p节点相等</span></span><br><span class="line">            node = p;   </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//如果p节点是红黑树</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);   </span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//p节点是单链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;  <span class="comment">//p记录要删除节点的上一节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果找到了要删除的节点（如果还指明了要删除的value的话，还要比较value是否一致）</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123; <span class="comment">//删除红黑树中的节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == p) &#123; <span class="comment">//要删除节点是链表的头结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//要删除节点不是链表的头结点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            ++modCount; <span class="comment">//增加修改次数</span></span><br><span class="line">            --size;     <span class="comment">//减少哈希桶的容量</span></span><br><span class="line">            afterNodeRemoval(node); </span><br><span class="line">            <span class="keyword">return</span> node;    <span class="comment">//返回删除节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除节点的步骤如下：</p><ol><li>先要确保哈希桶不为空且长度大于0，并且要删除的key在哈希桶中有对应节点。如果不满足这些条件，直接返回null。</li><li>如果对应节点就是要删除的节点，那么直接记录下该节点。如果不是的话，还要判断对应节点是红黑树还是单链表，分情况找到要删除的节点。</li><li>如果最终没有找到要删除的节点，返回null。如果找到了要删除的节点，就把该节点从红黑树或链表中删除，并返回该节点。</li></ol><h2 id="replace方法（改）"><a href="#replace方法（改）" class="headerlink" title="replace方法（改）"></a>replace方法（改）</h2><p>replace有两个重载方法</p><p>带三个参数的重载方法传入要修改的键值对的key和value，以及要更新后的value。如果找到该键值对并修改成功，返回true，否则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;   <span class="comment">//e存储要修改的节点，v存储修改节点的旧value</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果找到要修改的节点并且该节点的value和oldValue一致，执行修改操作，否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;             </span><br><span class="line">        e.value = newValue;     <span class="comment">//更新该节点的value</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带两个参数的重载方法传入要修改的键值对的key以及更新后的value。如果修改成功，返回旧的value，否则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果找到要修改的节点，执行修改操作，否则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;   </span><br><span class="line">        e.value = value;    <span class="comment">//更新该节点的value</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;    <span class="comment">//返回该节点的旧value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个重载方法都调用了getNode方法</p><h3 id="getNode"><a href="#getNode" class="headerlink" title="getNode"></a>getNode</h3><p>getNode方法的作用是根据传入的hash值和key值，找到对应的节点并返回，若没有找到则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e;    <span class="comment">//tab存储哈希桶，first存储hash值所对应的头节点</span></span><br><span class="line">    <span class="keyword">int</span> n; K k;     <span class="comment">//n存储哈希桶容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当哈希桶不为空并且其长度大于0，同时存在要查找的hash值所对应的头节点时，</span></span><br><span class="line"><span class="comment">     * 才执行相关查找操作，否则直接返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;   </span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123; <span class="comment">//先检查该头节点是否就是要查找的节点</span></span><br><span class="line">            <span class="keyword">return</span> first;   </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) &#123;    <span class="comment">//该节点是红黑树</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">do</span> &#123;    <span class="comment">//该节点是单链表</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get方法（查）"><a href="#get方法（查）" class="headerlink" title="get方法（查）"></a>get方法（查）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果找到对应节点，则返回该节点的value，否则返回null。</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，get方法也是通过getNode方法来查找节点。在分析replace方法时已经分析过该方法，这里不再多说。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文对HashMap的构造方法以及增删改查等基本操作进行了源码分析，分析过后，对于HashMap有了更深的认识，在这里小结一下：</p><ol><li>HashMap有4种构造方法，除了默认的方法外，我们还可以通过其他的构造方法初始化HashMap的元素，或者根据需要设置哈希桶的初始化容量和加载因子。</li><li>哈希桶的初始化不是发生在创建HashMap的时候，而是发生在第一次插入元素的时候，通过扩容操作初始化。</li><li>哈希桶在扩容时，如果旧桶容量大于0并且小于最大容量（2^30），那么新桶容量是旧桶容量的两倍。旧桶中的链表会被拆分为两个链表存到新桶中。</li><li>哈希桶的数据结构是数组，在处理哈希冲突时，如果发生冲突的元素小于8个的时候，是用单链表存起来的。一旦冲突的元素个数大于等于8个，那么单链表将转化为红黑树。</li></ol><p>作者：MrFengZH<br>链接：<a href="https://www.jianshu.com/p/5c1ffa06aec7" target="_blank" rel="noopener">https://www.jianshu.com/p/5c1ffa06aec7</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文将对HashMap（基于JDK1.8）的源码进行具体分析，包括&lt;strong&gt;构造方法&lt;/strong&gt;以及&lt;strong&gt;增、删、改、
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="https://www.vazh.cn/tags/JDK/"/>
    
      <category term="HashMap" scheme="https://www.vazh.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-JUC锁（三）：CountDownLatch</title>
    <link href="https://www.vazh.cn/2020/04/23/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JUC%E9%94%81%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ACountDownLatch/"/>
    <id>https://www.vazh.cn/2020/04/23/JUC源码分析-JUC锁（三）：CountDownLatch/</id>
    <published>2020-04-23T02:41:39.000Z</published>
    <updated>2020-04-23T10:55:21.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC源码分析-JUC锁（三）：CountDownLatch"><a href="#JUC源码分析-JUC锁（三）：CountDownLatch" class="headerlink" title="JUC源码分析-JUC锁（三）：CountDownLatch"></a>JUC源码分析-JUC锁（三）：CountDownLatch</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote><p>CountDownLatch是一个同步辅助类，通过AQS实现的一个闭锁。在其他线程完成它们的操作之前，允许一个多个线程等待。简单来说，CountDownLatch中有一个锁计数，在计数到达0之前，线程会一直等待。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6050820-31525b28d22df2b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp" alt="img"></p><p>CountDownLatch运行机制</p><h2 id="2-数据结构和核心参数"><a href="#2-数据结构和核心参数" class="headerlink" title="2. 数据结构和核心参数"></a>2. 数据结构和核心参数</h2><p><img src="https://upload-images.jianshu.io/upload_images/6050820-b93909094116df2f.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp" alt="img"></p><p>CountDownLatch继承关系</p><p>从锁类别来说，CountDownLatch是一个“共享锁”，内部定义了自己的同步器Sync，Sync继承自AQS，实现了<code>tryAcquireShared</code>和<code>tryReleaseShared</code>两个方法。需要注意的是，<strong>CountDownLatch中的锁是响应中断的，如果线程在对锁进行操作期间发生中断，会直接抛出<code>InterruptedException</code>。</strong></p><h2 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CountDownLatch中的计数其实就是AQS的state</span></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：从构造函数中可以看出，CountDownLatch的“锁计数”本质上就是AQS的资源数<code>state</code>。下面我们将通过<code>await()</code>和<code>countDown()</code>两个方法来分析CountDownLatch的“latch”实现。</p><h3 id="3-1-await"><a href="#3-1-await" class="headerlink" title="3.1 await()"></a>3.1 await()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS中acquireSharedInterruptibly(1)的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tryAcquireShared在CountDownLatch中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:<code>await()</code>的实现非常简单，就是通过对资源<code>state</code>剩余量（<code>state==0 ? 1 : -1</code>）来判断是否获取到锁。在《AQS》篇中我们讲到过，<code>tryAcquireShared</code>函数规定了它的返回值类型：<strong>成功获取并且还有可用资源返回正数；成功获取但是没有可用资源时返回0；获取资源失败返回一个负数。</strong> 也就是说，只要<code>state!=0</code>，线程就进入等待队列阻塞。</p><h3 id="3-2-countDown"><a href="#3-2-countDown" class="headerlink" title="3.2 countDown()"></a>3.2 countDown()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS中releaseShared(1)的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后续节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tryReleaseShared在CountDownLatch中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>如果释放资源后<code>state==0</code>,说明已经到达latch，此时就可以调用<code>doReleaseShared</code>唤醒等待的线程。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>相对其他同步类来说，CountDownLatch可以说是最简单的同步类实现了。它完全依赖了AQS，只要理解了AQS，那么理解它就不成问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC源码分析-JUC锁（三）：CountDownLatch&quot;&gt;&lt;a href=&quot;#JUC源码分析-JUC锁（三）：CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;JUC源码分析-JUC锁（三）：CountDownLatch&quot;&gt;
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="CountDownLatch" scheme="https://www.vazh.cn/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>JUC源码分析-JUC锁（四）：CyclicBarrier</title>
    <link href="https://www.vazh.cn/2020/04/23/JUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JUC%E9%94%81%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ACyclicBarrier/"/>
    <id>https://www.vazh.cn/2020/04/23/JUC源码分析-JUC锁（四）：CyclicBarrier/</id>
    <published>2020-04-23T02:17:38.000Z</published>
    <updated>2020-04-23T11:06:25.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><blockquote><p>CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。如果一个程序中有固定的线程数，并且线程之间需要相互等待，这时候CyclicBarrier是一个很好的选择。之所以叫它cyclic，是因为在释放等待线程之后，它可以被重用。</p></blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/6050820-c89ef6dc60470065.png?imageMogr2/auto-orient/strip|imageView2/2/w/527/format/webp" alt="img"></p><p>CyclicBarrier运行机制</p><p><strong>CountDownLatch和CyclicBarrier的区别：</strong></p><ol><li>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</li><li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</li></ol><h1 id="2-函数列表和核心参数"><a href="#2-函数列表和核心参数" class="headerlink" title="2. 函数列表和核心参数"></a>2. 函数列表和核心参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------核心参数------------------------------</span></span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 守护barrier入口的锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** 等待条件，直到所有线程到达barrier */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">/** 要屏障的线程数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">/* 当线程都到达barrier，运行的 barrierCommand*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">/** The current generation */</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"><span class="comment">//等待到达barrier的参与线程数量，count=0 -&gt; tripped</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------函数列表------------------------------</span></span><br><span class="line"><span class="comment">//构造函数，指定参与线程数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="comment">//构造函数，指定参与线程数，并在所有线程到达barrier之后执行给定的barrierAction逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span>;</span><br><span class="line"><span class="comment">//等待所有的参与者到达barrier</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//等待所有的参与者到达barrier，或等待给定的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"><span class="comment">//获取参与等待到达barrier的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询barrier是否处于broken状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//重置barrier为初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回等待barrier的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol><li><strong>Generation：</strong>每个使用中的barrier都表示为一个<code>generation</code>实例。当barrier触发trip条件或重置时<code>generation</code>随之改变。使用barrier时有很多<code>generation</code>与线程关联，由于不确定性的方式，锁可能分配给等待的线程。但是在同一时间只有一个是活跃的<code>generation</code>(通过<code>count</code>变量确定)，并且其余的要么被销毁，要么被trip条件等待。如果有一个中断，但没有随后的重置，就不需要有活跃的<code>generation</code>。<strong><code>CyclicBarrier</code>的可重用特性就是通过<code>Generation</code>来实现，每一次触发tripped都会new一个新的Generation</strong>。</li><li><strong>barrierCommand：</strong><code>CyclicBarrier</code>的另一个特性是在所有参与线程到达barrier触发一个自定义函数，这个函数就是<code>barrierCommand</code>，在<code>CyclicBarrier</code>的构造函数中初始化。</li></ol><h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障位置，线程被阻塞。</li><li>另外一个构造方法CyclicBarrier(int parties, Runnable barrierAction)，其中barrierAction任务会在所有线程到达屏障后执行。</li></ol><h2 id="3-2-await"><a href="#3-2-await" class="headerlink" title="3.2 await()"></a>3.2 await()</h2><p>最主要的方法就是await()方法，调用await()的线程会等待直到有足够数量的线程调用await——也就是开闸状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">        BrokenBarrierException,</span></span><br><span class="line"><span class="function">        TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await()和await(long, TimeUnit)都是调用dowait方法，区别就是参数不同，我们来看看dowait方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">        TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)   <span class="comment">// 如果当前Generation是处于打破状态则传播这个BrokenBarrierExcption</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程被中断则使得当前generation处于打破状态，重置剩余count。</span></span><br><span class="line">            <span class="comment">// 并且唤醒状态变量。这时候其他线程会传播BrokenBarrierException。</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;    <span class="comment">// 尝试降低当前count</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果当前状态将为0，则Generation处于开闸状态。运行可能存在的command，</span></span><br><span class="line"><span class="comment">         * 设置下一个Generation。相当于每次开闸之后都进行了一次reset。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 如果运行command失败也会导致当前屏障被打破。</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 阻塞在当前的状态变量。</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;    <span class="comment">// 如果当前线程被中断了则使得屏障被打破。并抛出异常。</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从阻塞恢复之后，需要重新判断当前的状态。</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><code>dowait()</code>是<code>await()</code>的实现函数，它的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，当前线程才继续执行。当所有parties到达barrier（<code>count=0</code>），如果<code>barrierCommand</code>不为空，则执行<code>barrierCommand</code>。然后调用<code>nextGeneration()</code>进行换代操作。<br> 在<code>for(;;)</code>自旋中。<code>timed</code>是用来表示当前是不是“超时等待”线程。如果不是，则通过<code>trip.await()</code>进行等待；否则，调用<code>awaitNanos()</code>进行超时等待。</p><p>此外再看下两个小过程：</p><p>这两个小过程当然是需要锁的，但是由于这两个方法只是通过其他方法调用，所以依然是在持有锁的范围内运行的。这两个方法都是对域进行操作。</p><p>nextGeneration实际上在屏障开闸之后重置状态。以待下一次调用。<br> breakBarrier实际上是在屏障打破之后设定打破状态，以唤醒其他线程并通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、reset"><a href="#3-4、reset" class="headerlink" title="3.4、reset"></a>3.4、reset</h2><p>reset方法比较简单。但是这里还是要注意一下要先打破当前屏蔽，然后再重建一个新的屏蔽。否则的话可能会导致信号丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>CyclicBarrier</code>主要通过独占锁<code>ReentrantLock</code>和<code>Condition</code>配合实现。类本身实现很简单，重点是分清<code>CyclicBarrier</code>和<code>CountDownLatch</code>的用法及区别，还有在jdk1.7新增的另外一个与它们相似的同步锁<code>Phaser</code>，在后面文章中会详细讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (com
      
    
    </summary>
    
      <category term="源码分析" scheme="https://www.vazh.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JUC" scheme="https://www.vazh.cn/tags/JUC/"/>
    
      <category term="CyclicBarrier" scheme="https://www.vazh.cn/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令基础</title>
    <link href="https://www.vazh.cn/2020/02/19/Linux%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.vazh.cn/2020/02/19/Linux命令基础/</id>
    <published>2020-02-19T03:04:06.000Z</published>
    <updated>2020-02-27T05:58:31.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-文件及目录管理"><a href="#2-文件及目录管理" class="headerlink" title="2. 文件及目录管理"></a>2. 文件及目录管理</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>文件及目录管理<ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id3" target="_blank" rel="noopener">创建和删除</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id4" target="_blank" rel="noopener">目录切换</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id5" target="_blank" rel="noopener">列出目录项</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#find-locate" target="_blank" rel="noopener">查找目录及文件 find/locate</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id6" target="_blank" rel="noopener">查看文件内容</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id7" target="_blank" rel="noopener">查找文件内容</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id8" target="_blank" rel="noopener">文件与目录权限修改</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id9" target="_blank" rel="noopener">给文件增加别名</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id10" target="_blank" rel="noopener">管道和重定向</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id11" target="_blank" rel="noopener">设置环境变量</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#bash" target="_blank" rel="noopener">Bash快捷输入或删除</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id12" target="_blank" rel="noopener">综合应用</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id13" target="_blank" rel="noopener">总结</a></li></ul></li></ul><p>文件管理主要有文件或目录的创建、删除、查询、移动，文件查询是重点，用find来进行查询；find的参数丰富，也非常强大；</p><p>查看文件内容是个大的话题，文本的处理有太多的工具供我们使用，在本章中只是点到即止，后面会有专门的一章来介绍文本的处理工具；</p><p>有时候，需要给文件创建一个别名，我们需要用到ln，使用这个别名和使用原文件是相同的效果；</p><h3 id="2-1-创建和删除"><a href="#2-1-创建和删除" class="headerlink" title="2.1 创建和删除"></a>2.1 创建和删除</h3><ul><li><p>创建：mkdir</p></li><li><p>删除：rm</p></li><li><p>删除非空目录：rm -rf file目录</p></li><li><p>删除日志 rm <em>log (等价: $find ./ -name “</em>log” -exec rm {} ;)</p></li><li><p>移动：mv</p></li><li><p>复制：cp (复制目录：cp -r )</p><p>查看当前目录下文件个数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$find ./ | wc -l</span><br></pre></td></tr></table></figure><p>复制目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r source_dir dest_dir</span><br></pre></td></tr></table></figure><h3 id="2-2-目录切换"><a href="#2-2-目录切换" class="headerlink" title="2.2. 目录切换"></a>2.2. 目录切换</h3><ul><li>找到文件/目录位置：cd</li><li>切换到上一个工作目录： cd -</li><li>切换到home目录： cd or cd ~</li><li>显示当前路径: pwd</li><li>更改当前工作路径为path: $cd path</li></ul><h3 id="2-3-列出目录项"><a href="#2-3-列出目录项" class="headerlink" title="2.3. 列出目录项"></a>2.3. 列出目录项</h3><ul><li>显示当前目录下的文件 ls</li><li>按时间排序，以列表的方式显示目录项 ls -lrt</li></ul><p>以上这个命令用到的频率如此之高，以至于我们需要为它建立一个快捷命令方式:</p><p>在.bashrc 中设置命令别名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias lsl=&apos;ls -lrt&apos;</span><br><span class="line">alias lm=&apos;ls -al|more&apos;</span><br></pre></td></tr></table></figure><p>这样，使用lsl，就可以显示目录中的文件按照修改时间排序；以列表方式显示；</p><ul><li><p>给每项文件前面增加一个id编号(看上去更加整洁):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ls | cat -n</span><br></pre></td></tr></table></figure><blockquote><p>1 a 2 a.out 3 app 4 b 5 bin 6 config</p></blockquote></li></ul><p>注：.bashrc 在/home/你的用户名/ 文件夹下，以隐藏文件的方式存储；可使用 ls -a 查看；</p><h3 id="2-4-查找目录及文件-find-locate"><a href="#2-4-查找目录及文件-find-locate" class="headerlink" title="2.4. 查找目录及文件 find/locate"></a>2.4. 查找目录及文件 find/locate</h3><p>搜寻文件或目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$find ./ -name &quot;core*&quot; | xargs file</span><br></pre></td></tr></table></figure><p>查找目标文件夹中是否有obj文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$find ./ -name &apos;*.o&apos;</span><br></pre></td></tr></table></figure><p>递归当前目录及子目录删除所有.o文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$find ./ -name &quot;*.o&quot; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>find是实时查找，如果需要更快的查询，可试试locate；locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$locate string</span><br></pre></td></tr></table></figure><p>寻找包含有string的路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$updatedb</span><br></pre></td></tr></table></figure><p>与find不同，locate并不是实时查找。你需要更新数据库，以获得最新的文件索引信息。</p><h2 id="2-5-查看文件内容"><a href="#2-5-查看文件内容" class="headerlink" title="2.5. 查看文件内容"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id19" target="_blank" rel="noopener">2.5. 查看文件内容</a></h2><p>查看文件：cat vi head tail more</p><p>显示时同时显示行号:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cat -n</span><br></pre></td></tr></table></figure><p>按页显示列表内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ls -al | more</span><br></pre></td></tr></table></figure><p>只看前10行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$head - 10 **</span><br></pre></td></tr></table></figure><p>显示文件第一行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$head -1 filename</span><br></pre></td></tr></table></figure><p>显示文件倒数第五行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$tail -5 filename</span><br></pre></td></tr></table></figure><p>查看两个文件间的差别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$diff file1 file2</span><br></pre></td></tr></table></figure><p>动态显示文本最新信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$tail -f crawler.log</span><br></pre></td></tr></table></figure><h2 id="2-6-查找文件内容"><a href="#2-6-查找文件内容" class="headerlink" title="2.6. 查找文件内容"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id20" target="_blank" rel="noopener">2.6. 查找文件内容</a></h2><p>使用egrep查询文件内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egrep &apos;03.1\/CO\/AE&apos; TSF_STAT_111130.log.012</span><br><span class="line">egrep &apos;A_LMCA777:C&apos; TSF_STAT_111130.log.035 &gt; co.out2</span><br></pre></td></tr></table></figure><h2 id="2-7-文件与目录权限修改"><a href="#2-7-文件与目录权限修改" class="headerlink" title="2.7. 文件与目录权限修改"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id21" target="_blank" rel="noopener">2.7. 文件与目录权限修改</a></h2><ul><li>改变文件的拥有者 chown</li><li>改变文件读、写、执行等属性 chmod</li><li>递归子目录修改： chown -R tuxapp source/</li><li>增加脚本可执行权限： chmod a+x myscript</li></ul><h2 id="2-8-给文件增加别名"><a href="#2-8-给文件增加别名" class="headerlink" title="2.8. 给文件增加别名"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id22" target="_blank" rel="noopener">2.8. 给文件增加别名</a></h2><p>创建符号链接/硬链接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln cc ccAgain :硬连接；删除一个，将仍能找到；</span><br><span class="line">ln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）</span><br></pre></td></tr></table></figure><h2 id="2-9-管道和重定向"><a href="#2-9-管道和重定向" class="headerlink" title="2.9. 管道和重定向"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id23" target="_blank" rel="noopener">2.9. 管道和重定向</a></h2><ul><li>批处理命令连接执行，使用 |</li><li>串联: 使用分号 ;</li><li>前面成功，则执行后面一条，否则，不执行:&amp;&amp;</li><li>前面失败，则后一条执行: ||</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /proc &amp;&amp; echo  suss! || echo failed.</span><br></pre></td></tr></table></figure><p>能够提示命名是否执行成功or失败；</p><p>与上述相同效果的是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ls /proc; then echo suss; else echo fail; fi</span><br></pre></td></tr></table></figure><p>重定向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls  proc/*.c &gt; list 2&gt; &amp;l 将标准输出和标准错误重定向到同一文件；</span><br></pre></td></tr></table></figure><p>等价的是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls  proc/*.c &amp;&gt; list</span><br></pre></td></tr></table></figure><p>清空文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&gt; a.txt</span><br></pre></td></tr></table></figure><p>重定向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo aa &gt;&gt; a.txt</span><br></pre></td></tr></table></figure><h2 id="2-10-设置环境变量"><a href="#2-10-设置环境变量" class="headerlink" title="2.10. 设置环境变量"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id24" target="_blank" rel="noopener">2.10. 设置环境变量</a></h2><p>启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；</p><p>安装的软件路径一般需要加入到path中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=$APPDIR:/opt/app/soft/bin:$PATH:/usr/local/bin:$TUXDIR/bin:$ORACLE_HOME/bin;export PATH</span><br></pre></td></tr></table></figure><h2 id="2-11-Bash快捷输入或删除"><a href="#2-11-Bash快捷输入或删除" class="headerlink" title="2.11. Bash快捷输入或删除"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id25" target="_blank" rel="noopener">2.11. Bash快捷输入或删除</a></h2><p>快捷键:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctl-U   删除光标到行首的所有字符,在某些设置下,删除全行</span><br><span class="line">Ctl-W   删除当前光标到前边的最近一个空格之间的字符</span><br><span class="line">Ctl-H   backspace,删除光标前边的字符</span><br><span class="line">Ctl-R   匹配最相近的一个文件，然后输出</span><br></pre></td></tr></table></figure><h2 id="2-12-综合应用"><a href="#2-12-综合应用" class="headerlink" title="2.12. 综合应用"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id26" target="_blank" rel="noopener">2.12. 综合应用</a></h2><p>查找record.log中包含AAA，但不包含BBB的记录的总数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -v record.log | grep AAA | grep -v BBB | wc -l</span><br></pre></td></tr></table></figure><h2 id="2-13-总结"><a href="#2-13-总结" class="headerlink" title="2.13. 总结"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/02_file_manage.html#id27" target="_blank" rel="noopener">2.13. 总结</a></h2><p>文件管理，目录的创建、删除、查询、管理: mkdir rm mv</p><p>文件的查询和检索: find locate</p><p>查看文件内容：cat vi tail more</p><p>管道和重定向: ; | &amp;&amp; &gt;</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2-文件及目录管理&quot;&gt;&lt;a href=&quot;#2-文件及目录管理&quot; class=&quot;headerlink&quot; title=&quot;2. 文件及目录管理&quot;&gt;&lt;/a&gt;2. 文件及目录管理&lt;/h2&gt;&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.vazh.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.vazh.cn/tags/Linux/"/>
    
      <category term="目录管理" scheme="https://www.vazh.cn/tags/%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    
      <category term="文本处理" scheme="https://www.vazh.cn/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
      <category term="磁盘管理" scheme="https://www.vazh.cn/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="性能监控" scheme="https://www.vazh.cn/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
      <category term="网络工具" scheme="https://www.vazh.cn/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
      <category term="用户管理" scheme="https://www.vazh.cn/tags/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    
      <category term="系统管理" scheme="https://www.vazh.cn/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode10正则表达式匹配</title>
    <link href="https://www.vazh.cn/2020/01/20/Leetcode10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>https://www.vazh.cn/2020/01/20/Leetcode10正则表达式匹配/</id>
    <published>2020-01-19T23:52:29.000Z</published>
    <updated>2020-01-20T01:10:36.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>    输出：7 -&gt; 0 -&gt; 8<br>    原因：342 + 465 = 807</p></blockquote><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li><p>状态<br>首先状态 dp 一定能自己想出来。<br>dp[i][j] 表示 s 的前 ii 个是否能被 p 的前 jj 个匹配</p><p>转移方程<br>怎么想转移方程？首先想的时候从已经求出了 dp[i-1][j-1] 入手，再加上已知 s[i]、p[j]，要想的问题就是怎么去求 dp[i][j]。</p><p>已知 dp[i-1][j-1] 意思就是前面子串都匹配上了，不知道新的一位的情况。<br>那就分情况考虑，所以对于新的一位 p[j] s[i] 的值不同，要分情况讨论：</p><p>考虑最简单的 p[j] == s[i] : dp[i][j] = dp[i-1][j-1]<br>然后从 p[j] 可能的情况来考虑，让 p[j]=各种能等于的东西。</p><p>p[j] == “.” : dp[i][j] = dp[i-1][j-1]</p><p>p[j] ==” * “:</p><p>第一个难想出来的点：怎么区分 <em>∗ 的两种讨论情况<br>首先给了 </em>，明白 <em> 的含义是 匹配零个或多个前面的那一个元素，所以要考虑他前面的元素 p[j-1]。</em> 跟着他前一个字符走，前一个能匹配上 s[i]，<em> 才能有用，前一个都不能匹配上 s[i]，</em> 也无能为力，只能让前一个字符消失，也就是匹配 00 次前一个字符。<br>所以按照 p[j-1] 和 s[i] 是否相等，我们分为两种情况：</p><p>3.1 p[j-1] != s[i] : dp[i][j] = dp[i][j-2]<br>这就是刚才说的那种前一个字符匹配不上的情况。<br>比如(ab, abc <em> )。遇到 </em> 往前看两个，发现前面 s[i] 的 ab 对 p[j-2] 的 ab 能匹配，虽然后面是 c<em>，但是可以看做匹配 00 次 c，相当于直接去掉 c </em>，所以也是 True。注意 (ab, abc**) 是 False。<br>3.2 p[j-1] == s[i] or p[j-1] == “.”：</p><ul><li>前面那个字符，能匹配 s[i]，或者 <em> 前面那个字符是万能的 .<br>因为 . </em> 就相当于 . .，那就只要看前面可不可以匹配就行。<br>比如 (##b , ###b <em>)，或者 ( ##b , ### . </em> ) 只看 ### 后面一定是能够匹配上的。<br>所以要看 b 和 b <em> 前面那部分 ## 的地方匹不匹配。<br>第二个难想出来的点：怎么判断前面是否匹配<br>dp[i][j] = dp[i-1][j] // 多个字符匹配的情况<br>or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况<br>or dp[i][j] = dp[i][j-2] // 没有匹配的情况<br>看 ### 匹不匹配，不是直接只看 ### 匹不匹配，要综合后面的 b b</em> 来分析<br>这三种情况是 oror 的关系，满足任意一种都可以匹配上，同时是最难以理解的地方：</li></ul><p>dp[i-1][j] 就是看 s 里 b 多不多， ### 和 ###b <em> 是否匹配，一旦匹配，s 后面再添个 b 也不影响，因为有 </em> 在，也就是 ###b 和 ###b *也会匹配。</p><p>dp[i][j-1] 就是去掉 * 的那部分，###b 和 ###b 是否匹配，比如 qqb qqb</p><p>dp[i][j-2] 就是 去掉多余的 b <em>，p 本身之前的能否匹配，###b 和 ### 是否匹配，比如 qqb qqbb</em> 之前的 qqb qqb 就可以匹配，那多了的 b <em> 也无所谓，因为 b </em> 可以是匹配 00 次 b，相当于 b * 可以直接去掉了。</p><p>三种满足一种就能匹配上。</p><p>为什么没有 dp[i-1][j-2] 的情况？ 就是 ### 和 ### 是否匹配？因为这种情况已经是 dp[i][j-1] 的子问题。也就是 s[i]==p[j-1]，则 dp[i-1][j-2]=dp[i][j-1]。</p><p>最后来个归纳：<br>如果 p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]；<br>如果 p.charAt(j) == ‘.’ : dp[i][j] = dp[i-1][j-1]；<br>如果 p.charAt(j) == ‘<em>‘：<br>如果 p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a</em> only counts as empty<br>如果 p.charAt(j-1) == s.charAt(i) or p.charAt(i-1) == ‘.’：<br>dp[i][j] = dp[i-1][j] //in this case, a<em> counts as multiple a<br>or dp[i][j] = dp[i][j-1] // in this case, a</em> counts as single a<br>or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> isMatchHelper(s, <span class="number">0</span>, p, <span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[(s.length() + <span class="number">1</span>) * (p.length() + <span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatchHelper</span><span class="params">(String s, <span class="keyword">int</span> sIndex, String p, <span class="keyword">int</span> pIndex, <span class="keyword">byte</span>[] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[sIndex * p.length() + pIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[sIndex * p.length() + pIndex] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pIndex == p.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> sIndex == s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> match;</span><br><span class="line">        <span class="keyword">boolean</span> firstMatch = sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == <span class="string">'.'</span> || p.charAt(pIndex) == s.charAt(sIndex));</span><br><span class="line">        <span class="keyword">if</span>(pIndex + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(pIndex + <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            match = isMatchHelper(s, sIndex, p, pIndex + <span class="number">2</span>, dp) || (firstMatch &amp;&amp; isMatchHelper(s, sIndex + <span class="number">1</span>, p, pIndex, dp));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            match = firstMatch &amp;&amp; isMatchHelper(s, sIndex + <span class="number">1</span>, p, pIndex + <span class="number">1</span>, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[sIndex * p.length() + pIndex] = (<span class="keyword">byte</span>) (match ? <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：因为while循环遍历的次数是线性的，假设L1与L2的最大长度为 r , 则时间复杂度为O(r)</strong></p><p><strong>空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1)</strong></p><h2 id="leetcode-92-Solution"><a href="#leetcode-92-Solution" class="headerlink" title="leetcode 92% Solution"></a>leetcode 92% Solution</h2><h3 id="java执行用时-31ms"><a href="#java执行用时-31ms" class="headerlink" title="java执行用时: 31ms"></a>java执行用时: 31ms</h3><p><img src="/picture/lc02.png" alt="pic02.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode04-寻找两个有序数组的中位数</title>
    <link href="https://www.vazh.cn/2019/11/07/Leetcode04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://www.vazh.cn/2019/11/07/Leetcode04-寻找两个有序数组的中位数/</id>
    <published>2019-11-07T06:27:43.000Z</published>
    <updated>2019-11-17T06:58:32.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0<br>示例 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>为了解决这个问题，我们需要理解 “中位数的作用是什么”。在统计中，中位数被用来：</p><blockquote><p>将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</p></blockquote><p>如果理解了中位数的划分作用，我们就很接近答案了。</p><p>首先，让我们在任一位置 iii 将 A\text{A}A 划分成两个部分：</p><pre><code>      left_A                                      |                right_AA[0], A[1], ..., A[i-1]                  |                  A[i], A[i+1], ..., A[m-1]</code></pre><p>由于 A 中有 m 个元素， 所以我们有 m+1种划分的方法（i=0∼m）。</p><p>我们知道：</p><blockquote><p>len(left_A) = i, len(right_A) = m−i</p><p>注意：当 i=0 时，left_A 为空集， 而当 i=m 时, right_A 为空集。</p></blockquote><p>采用同样的方式，我们在任一位置 j将 B 划分成两个部分：</p><pre><code>      left_B                                                 |        right_BB[0], B[1], ..., B[j-1]                          |  B[j], B[j+1], ..., B[n-1]</code></pre><p>将 left_A 和 left_B放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：</p><pre><code>      left_part                                          |                                        right_partA[0], A[1], ..., A[i-1]                           |                              A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1]                           |                              B[j], B[j+1], ..., B[n-1]</code></pre><p>如果我们可以确认：</p><blockquote><ol><li>len(left_part) = len(right_part)</li><li>max⁡(left_part)≤min⁡(right_part)</li></ol></blockquote><p>那么，我们已经将 {A,B}中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：</p><p>$$<br>median=\frac{max(left_part)+min(right_part)}{2}<br>$$<br>要确保这两个条件，我们只需要保证：</p><blockquote><p>$$<br>i+j=m−i+n−j（或：m - i + n - j + 1 )<br>$$</p><p>$$<br>如果 n≥m，只需要使 i = 0 ~ m,\ j = \frac{m + n + 1}{2} - i<br>$$</p><p>$$<br>\text{B}[j-1] \leq \text{A}[i]  和  \text{A}[i-1] \leq \text{B}[j]<br>$$</p></blockquote><p>ps.1 为了简化分析，我假设 A[i−1],B[j−1],A[i],B[j]总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。<br>我将在最后讨论如何处理这些临界值。</p><p>ps.2 为什么 n≥m？由于0≤i≤m　且<br>$$<br>j= \frac{m + n + 1}{2} - i<br>$$<br> 我必须确保 j 不是负数。如果 n&lt;m，那么 j 将可能是负数，而这会造成错误的答案。</p><p>所以，我们需要做的是：</p><blockquote><p>在 [0，m]中搜索并找到目标对象 i，以使：</p><p>$$<br>B[j−1]≤A[i] 且 \text{A}[i-1] \leq \text{B}[j], 其中 j = \frac{m + n + 1}{2} - i<br>$$</p></blockquote><p>接着，我们可以按照以下步骤来进行二叉树搜索：</p><ol><li><p>设 imin=0，imax=m, 然后开始在 [imin,imax]中进行搜索。</p></li><li><p>令<br>$$<br> i = \frac{\text{imin} + \text{imax}}{2},<br>  j = \frac{m + n + 1}{2} - i</p><p>$$</p></li></ol><ol start="3"><li><p>现在我们有 len(left_part)=len(right_part)。 而且我们只会遇到三种情况：</p><ul><li><p>B[j−1]≤A[i] 且 A[i−1]≤B[j]：<br>这意味着我们找到了目标对象 i，所以可以停止搜索。</p></li><li><p>B[j−1]&gt;A[i]：<br>这意味着 A[i]太小，我们必须调整 i 以使 B[j−1]≤A[i]。<br>我们可以增大 i 吗？  </p><pre><code>是的，因为当 i 被增大的时候，j 就会被减小。  因此 B\[j−1] 会减小，而 A\[i] 会增大，那么 B\[j−1\]≤A\[i]就可能被满足。  </code></pre><p>我们可以减小 i吗？  </p><pre><code>不行，因为当 i 被减小的时候，j就会被增大。  因此 B\[j−1] 会增大，而 A\[i]会减小，那么 B\[j−1\]≤A\[i]就可能不满足。  </code></pre><p>所以我们必须增大 i。也就是说，我们必须将搜索范围调整为 [i+1,imax]。<br>因此，设 imin=i+1，并转到步骤 2。</p></li><li><p>A[i−1]>B[j]：<br>这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1]≤B[j]。<br>也就是说，我们必须将搜索范围调整为 [imin,i−1]。<br>因此，设 imax=i−1，并转到步骤 2。</p></li></ul></li></ol><p>当找到目标对象 i 时，中位数为：</p><blockquote><p>max⁡(A[i−1],B[j−1]), 当 m+n为奇数时</p></blockquote><blockquote><p>$$<br>\frac{max(A[i−1],B[j−1])+min(A[i],B[j])}{2} , 当m+n为偶数时<br>$$</p></blockquote><p>现在，让我们来考虑这些临界值  i = 0,i = m, j = 0, j = n，此时A[i − 1], B[j − 1], A[i], B[j] 可能不存在。<br>其实这种情况⽐你想象的要容易得多。其实这种情况比你想象的要容易得多。</p><p>我们需要做的是确保 max(left_part)≤min(right_part)。 因此，如果i 和 j 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j]全部存在）, 那么我们必须同时检查 B[j−1]≤A[i]以及 A[i−1]≤B[j]是否成立。<br>但是如果 A[i−1],B[j−1],A[i],B[j]中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。<br>举个例子，如果 i=0，那么 A[i−1] 不存在，我们就不需要检查 A[i−1]≤B[j]是否成立。<br>所以，我们需要做的是：</p><blockquote><p>在 [0，m]中搜索并找到目标对象 i，以使：</p><p>(j =0 or i =m or B[j−1]≤A[i]) 或是<br>(i =0 or j =n or A[i−1]≤B[j]), 其中<br>$$<br>j = \frac{m + n + 1}{2} - i<br>$$</p></blockquote><p>在循环搜索中，我们只会遇到三种情况：</p><blockquote><ol><li>(j =0 or i =m or B[j−1]≤A[i]) 或是  (i =0 or j =n or A[i−1]≤B[j])，这意味着 i 是完美的，我们可以停止搜索。</li><li>j>0 and i<m and="" b\[j−1\]\="">A[i] 这意味着 i 太小，我们必须增大它。</m></li><li>i>0  and j<n and="" a\[i−1\]\="">B[j] 这意味着 i 太大，我们必须减小它。</n></li></ol></blockquote><ol><li>i&lt;m⟹  j>0   以及  i>0 ⟹ j&lt;n 始终成立，这是因为：</li></ol><blockquote><p>$$<br>m≤n, i&lt;m⟹j= \frac{m+n+1}{2} - i  &gt; \frac{m+n+1}{2} - m ≥ \frac{2m+1}{2} - m ≥ 0<br>$$</p><p>$$<br>m≤n, i&gt;0⟹j= \frac{m+n+1}{2} - i  &lt;\frac{m+n+1}{2}  ≤ \frac{2n+1}{2} ≤ n<br>$$</p></blockquote><p>所以，在情况 2 和 3中，我们不需要检查 j>0  或是 j&lt;n 是否成立。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays_P</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; maxLeft = B[j-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; maxLeft = A[i-<span class="number">1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：O(log⁡(min(m,n)))，<br>首先，查找的区间是 [0,m]。<br>而该区间的长度在每次循环之后都会减少为原来的一半。<br>所以，我们只需要执行 log⁡(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log⁡(m))。<br>由于 m≤n ，所以时间复杂度是 O(log⁡(min(m,n)))。</p></li><li><p>空间复杂度：O(1 ，<br>我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1) 。</p></li></ul><h2 id="leetcode-99-Solution"><a href="#leetcode-99-Solution" class="headerlink" title="leetcode 99% Solution"></a>leetcode 99% Solution</h2><p>执行用时 :3 ms, 在所有 java 提交中击败了99.23%的用户</p><p>内存消耗 :47 MB, 在所有 java 提交中击败了94.74%的用户</p><p><img src="/picture/lc04.png" alt="pic02.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="二分查找" scheme="https://www.vazh.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数组" scheme="https://www.vazh.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode257-二叉树的所有路径</title>
    <link href="https://www.vazh.cn/2019/09/04/Leetcode275-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.vazh.cn/2019/09/04/Leetcode275-二叉树的所有路径/</id>
    <published>2019-09-04T01:48:42.000Z</published>
    <updated>2019-09-04T04:42:56.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>输入:</p><p>   1<br> /   \<br>2     3<br> \<br>  5</p><p>输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p><p>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul><li><strong>如果二叉树为空,返回空的list</strong></li><li>深度遍历二叉树,如果左右孩子节点为空　则为叶子节点　字符串拼接</li><li>s += root.val + “-&gt;”;　拼接每一次的值</li><li>如果左子树不为空　深度搜索</li><li>如果右子树不为空　深度搜索</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        dfs(root, list, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;String&gt; list, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(s + root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += root.val + <span class="string">"-&gt;"</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            dfs(root.left, list, s);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            dfs(root.right, list, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a><strong>Complexity Analysis</strong></h3><ol><li><strong>Time complexity : O(n).</strong></li><li><strong>Space complexity : O(1).</strong></li></ol><h3 id="Accepted"><a href="#Accepted" class="headerlink" title="Accepted"></a>Accepted</h3><p><strong>Runtime</strong>: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.</p><p><strong>Memory Usage</strong>: 36.4 MB, less than 100.00% of Java online submissions for Binary Tree Paths.</p><p><img src="/picture/lc257.png" alt="lc275"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://www.vazh.cn/categories/Leetcode/"/>
    
    
      <category term="DFS" scheme="https://www.vazh.cn/tags/DFS/"/>
    
      <category term="BST" scheme="https://www.vazh.cn/tags/BST/"/>
    
  </entry>
  
</feed>
