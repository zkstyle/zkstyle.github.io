<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇(六):LinkedTransferQueue]]></title>
    <url>%2F2020%2F05%2F17%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E5%85%AD-LinkedTransferQueue%2F</url>
    <content type="text"><![CDATA[JUC源码分析-集合篇（六）：LinkedTransferQueue LinkedTransferQueue 是单向链表结构的无界阻塞队列， 从JDK1.7开始加入到J.U.C的行列中。通过 CAS 和 LockSupport 实现线程安全，元素操作按照 FIFO (first-in-first-out 先入先出) 的顺序。内存一致性遵循对LinkedTransferQueue的插入操作先行发生于(happen-before)访问或移除操作。相对于其他传统 Queue，LinkedTransferQueue 有它独特的性质，本章将对其进行详细的讲解。 概述 LinkedTransferQueue（后称LTQ） 采用一种预占模式。意思就是消费者线程取元素时，如果队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。我们称这种节点操作为“匹配”方式。 LTQ的算法实现可以总结为以下几点： 双重队列：和典型的单向链表结构不同，LTQ 的 Node 存储了一个isData的 boolean 型字段，也就是说它的节点可以代表一个数据或者是一个请求，称为双重队列（Dual Queue）。上面说过，在消费者获取元素时，如果队列为空，当前消费者就会作为一个“元素为null”的节点被放入队列中等待，所以 LTQ中 的节点存储了生产者节点（item不为null）和消费者节点（item为null），这两种节点就是通过isData来区分的。 松弛度：为了节省 CAS 操作的开销，LTQ 引入了“松弛度”的概念：在节点被匹配（被删除）之后，不会立即更新head/tail，而是当 head/tail 节点和最近一个未匹配的节点之间的距离超过一个“松弛阀值”之后才会更新（在 LTQ 中，这个值为 2）。这个“松弛阀值”一般为1-3，如果太大会降低缓存命中率，并且会增加遍历链的长度；太小会增加 CAS 的开销。 节点自链接：已匹配节点的 next 引用会指向自身。如果GC延迟回收，已删除节点链会积累的很长，此时垃圾收集会耗费高昂的代价，并且所有刚匹配的节点也不会被回收。为了避免这种情况，我们在 CAS 向后推进 head 时，会把已匹配的 head 的”next”引用指向自身（即“自链接节点”），这样就限制了连接已删除节点的长度（我们也采取类似的方法，清除在其他节点字段中可能的垃圾保留值）。如果在遍历时遇到一个自链接节点，那就表明当前线程已经滞后于另外一个更新 head 的线程，此时就需要重新获取 head 来遍历。 所以，在 LTQ 中，数据在某个线程的“某一时刻”可能存在下面这种形式： LinkedTransferQueue 数据形式 unmatched node：未被匹配的节点。可能是一个生产者节点（item不为null），也可能是一个消费者节点（item为null）。matched node：已经被匹配的节点。可能是一个生产者节点（item不为null）的数据已经被一个消费者拿走；也可能是一个消费者节点（item为null）已经被一个生产者填充上数据。 数据结构 LinkedTransferQueue 继承关系 LTQ 继承自AbstractQueue，支持传统Queue的所有操作；实现了 TransferQueue 接口，并且是 TransferQueue 的唯一实现，TransferQueue 定义了一种“预占模式”，允许消费者在节点上等待，直到生产者把元素放入节点。 核心参数1234567891011121314151617181920212223242526//队列头节点，第一次入列之前为空transient volatile Node head;//队列尾节点，第一次添加节点之前为空private transient volatile Node tail;//累计到一定次数再清除无效nodeprivate transient volatile int sweepVotes;//当一个节点是队列中的第一个waiter时，在多处理器上进行自旋的次数(随机穿插调用thread.yield)private static final int FRONT_SPINS = 1 &lt;&lt; 7;// 当前继节点正在处理，当前节点在阻塞之前的自旋次数，也为FRONT_SPINS// 的位变化充当增量，也可在自旋时作为yield的平均频率private static final int CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; 1;//sweepVotes的阀值static final int SWEEP_THRESHOLD = 32;/* * Possible values for "how" argument in xfer method. * xfer方法类型 */private static final int NOW = 0; // for untimed poll, tryTransferprivate static final int ASYNC = 1; // for offer, put, addprivate static final int SYNC = 2; // for transfer, takeprivate static final int TIMED = 3; // for timed poll, tryTransfer 这里我们重点说一下sweepVotes这个属性，其他的都很简单，就不一一介绍了。 上面我们提到，head/tail 节点并不是及时更新的，在并发操作时链表内部可能存在已匹配节点，此时就需要一个阀值来决定何时清除已匹配的内部节点链，这就是sweepVotes和SWEEP_THRESHOLD的作用。 我们通过节点自链接的方式来减少垃圾滞留，同样也会解除内部已移除节点的链接。在匹配超时、线程中断或调用remove时，这也些节点也会被清除（解除链接）。例如，在某一时刻有一个节点 s 已经被移除，我们可以通过 CAS 修改 s 的前继节点的 next 引用的方式来解除 s 的链接。 但是有两种情况并不能保证节点 s 被解除链接：\1. 如果 s 节点是一个 next 为 null 的节点（trailing node），但是它被作为入列时的目标节点，所以只有在其他节点入列之后才能移除它\2. 通过给定 s 的前继节点，不一定会移除 s 节点：因为前继节点有可能已经被解除链接，这种情况下前继节点的前继节点有可能指向了s。 所以，通过这两点，说明在 s 节点或它的前继节点已经出列时，并不是必须要移除它们。对于这些情况，我们记录了一个解除节点链接失败的值-sweepVotes，并且为其定义了一个阀值-SWEEP_THRESHOLD，当解除链接失败次数超过这个阀值时就会对队列进行一次“大扫除”（通过sweep()方法），解除所有已取消的节点链接。 xfer方法类型：在 LTQ 中，所有的入队/出队操作都是通过xfer方法来控制，并且通过一个类型区分offer, put, poll, take, transfer，这样做大大简化了代码。来看一下xfer的方法类型：NOW：不等待，直接返回匹配结果。用在poll, tryTransfer中。ASYNC：异步操作，直接把元素添加到队列尾，不等待匹配。用在offer, put, add中。SYNC：等待元素被消费者接收。用在transfer, take中。TIMED：附带超时时间的NOW，等待指定时间后返回匹配结果。用在附带超时时间的poll, tryTransfer中。 源码解析由于 LTQ 的入列/出列方法都是由xfer来实现，所以我们这里只对xfer进行解析。 xfer(E e, boolean haveData, int how, long nanos)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Implements all queuing methods. See above for explanation. * * @param e the item or null for take * @param haveData true if this is a put, else a take * @param how NOW, ASYNC, SYNC, or TIMED * @param nanos timeout in nanosecs, used only if mode is TIMED * @return an item if matched, else e * @throws NullPointerException if haveData mode but e is null */private E xfer(E e, boolean haveData, int how, long nanos) &#123; if (haveData &amp;&amp; (e == null)) throw new NullPointerException(); Node s = null; // the node to append, if needed retry: for (;;) &#123; // restart on append race //从head开始向后匹配 for (Node h = head, p = h; p != null;) &#123; // find &amp; match first node boolean isData = p.isData; Object item = p.item; if (item != p &amp;&amp; (item != null) == isData) &#123; // 找到有效节点，进入匹配 if (isData == haveData) //节点与此次操作模式一致，无法匹配 can't match break; if (p.casItem(item, e)) &#123; // 匹配成功，cas修改为指定元素 match for (Node q = p; q != h;) &#123; Node n = q.next; // update by 2 unless singleton if (head == h &amp;&amp; casHead(h, n == null ? q : n)) &#123;//更新head为匹配节点的next节点 h.forgetNext();//旧head节点指向自身等待回收 break; &#125; // cas失败，重新获取head advance and retry if ((h = head) == null || (q = h.next) == null || !q.isMatched())//如果head的next节点未被匹配，跳出循环，不更新head，也就是松弛度&lt;2 break; // unless slack &lt; 2 &#125; LockSupport.unpark(p.waiter);//唤醒在节点上等待的线程 return LinkedTransferQueue.&lt;E&gt;cast(item); &#125; &#125; //匹配失败，继续向后查找节点 Node n = p.next; p = (p != n) ? n : (h = head); // Use head if p offlist &#125; //未找到匹配节点，把当前节点加入到队列尾 if (how != NOW) &#123; // No matches available if (s == null) s = new Node(e, haveData); //将新节点s添加到队列尾并返回s的前继节点 Node pred = tryAppend(s, haveData); if (pred == null) continue retry; //与其他不同模式线程竞争失败重新循环 lost race vs opposite mode if (how != ASYNC)//同步操作，等待匹配 return awaitMatch(s, pred, e, (how == TIMED), nanos); &#125; return e; // not waiting &#125;&#125; 说明：xfer的基本流程如下： 从head开始向后匹配，找到一个节点模式跟本次操作的模式不同的未匹配的节点（生产或消费）进行匹配； 匹配节点成功 CAS 修改匹配节点的 item 为给定元素 e； 如果此时所匹配节点向后移动，则 CAS 更新 head 节点为匹配节点的 next 节点，旧 head 节点链接指向自身等待被回收（forgetNext()方法）；如果CAS 失败，并且松弛度大于等于2，就需要重新获取 head 重试。 匹配成功，唤醒匹配节点 p 的等待线程 waiter，返回匹配的 item。 如果在上述操作中没有找到匹配节点，则根据参数how做不同的处理：NOW：立即返回。SYNC：通过tryAppend方法插入一个新的节点 s(item=e,isData = haveData)到队列尾，然后自旋或阻塞当前线程直到节点被匹配或者取消返回。ASYNC：通过tryAppend方法插入一个新的节点 s(item=e,isData = haveData)到队列尾，异步直接返回。TIMED：通过tryAppend方法插入一个新的节点 s(item=e,isData = haveData)到队列尾，然后自旋或阻塞当前线程直到节点被匹配或者取消或等待超时返回。 tryAppend(Node s, boolean haveData)1234567891011121314151617181920212223242526272829303132333435/** * Tries to append node s as tail. * 尝试添加给定节点s作为尾节点 * * @param s the node to append * @param haveData true if appending in data mode * @return null on failure due to losing race with append in * different mode, else s's predecessor, or s itself if no * predecessor */private Node tryAppend(Node s, boolean haveData) &#123; for (Node t = tail, p = t;;) &#123; // move p to last node and append Node n, u; // temps for reads of next &amp; tail if (p == null &amp;&amp; (p = head) == null) &#123;//head和tail都为null if (casHead(null, s))//修改head为新节点s return s; // initialize &#125; else if (p.cannotPrecede(haveData)) return null; // lost race vs opposite mode else if ((n = p.next) != null) // not last; keep traversing p = p != t &amp;&amp; t != (u = tail) ? (t = u) : // stale tail (p != n) ? n : null; // restart if off list else if (!p.casNext(null, s)) p = p.next; // re-read on CAS failure else &#123; if (p != t) &#123; // update if slack now &gt;= 2 while ((tail != t || !casTail(t, s)) &amp;&amp; (t = tail) != null &amp;&amp; (s = t.next) != null &amp;&amp; // advance and retry (s = s.next) != null &amp;&amp; s != t); &#125; return p; &#125; &#125;&#125; 说明：添加给定节点 s 到队列尾并返回 s 的前继节点，失败时（与其他不同模式线程竞争失败）返回null，没有前继节点返回自身。 awaitMatch(Node s, Node pred, E e, boolean timed, long nanos)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Spins/yields/blocks until node s is matched or caller gives up. * 自旋/让步/阻塞,直到给定节点s匹配到或放弃匹配 * * @param s the waiting node * @param pred the predecessor of s, or s itself if it has no * predecessor, or null if unknown (the null case does not occur * in any current calls but may in possible future extensions) * @param e the comparison value for checking match * @param timed if true, wait only until timeout elapses * @param nanos timeout in nanosecs, used only if timed is true * @return matched item, or e if unmatched on interrupt or timeout */private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; Thread w = Thread.currentThread(); //在首个item和取消检查后初始 int spins = -1; // initialized after first item and cancel checks ThreadLocalRandom randomYields = null; // bound if needed for (;;) &#123; Object item = s.item; if (item != e) &#123; //matched // assert item != s; s.forgetContents(); // avoid garbage return LinkedTransferQueue.&lt;E&gt;cast(item); &#125; if ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= 0)) &amp;&amp; s.casItem(e, s)) &#123; //取消匹配，item指向自身 cancel unsplice(pred, s);//解除s节点和前继节点的链接 return e; &#125; if (spins &lt; 0) &#123; // establish spins at/near front if ((spins = spinsFor(pred, s.isData)) &gt; 0) randomYields = ThreadLocalRandom.current(); &#125; else if (spins &gt; 0) &#123; // spin --spins; if (randomYields.nextInt(CHAINED_SPINS) == 0) Thread.yield(); //不定期让步，给其他线程执行机会 occasionally yield &#125; else if (s.waiter == null) &#123; s.waiter = w; // request unpark then recheck &#125; else if (timed) &#123; nanos = deadline - System.nanoTime(); if (nanos &gt; 0L) LockSupport.parkNanos(this, nanos); &#125; else &#123; LockSupport.park(this); &#125; &#125;&#125; 说明：当前操作为同步操作时，会调用awaitMatch方法阻塞等待匹配，成功返回匹配节点 item，失败返回给定参数e（s.item）。在等待期间如果线程被中断或等待超时，则取消匹配，并调用unsplice方法解除节点s和其前继节点的链接。 ### 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Unsplices (now or later) the given deleted/cancelled node with * the given predecessor. * * 解除给定已经被删除/取消节点和前继节点的链接（可能延迟解除） * @param pred a node that was at one time known to be the * predecessor of s, or null or s itself if s is/was at head * @param s the node to be unspliced */final void unsplice(Node pred, Node s) &#123; s.forgetContents(); // forget unneeded fields if (pred != null &amp;&amp; pred != s &amp;&amp; pred.next == s) &#123; Node n = s.next; if (n == null || (n != s &amp;&amp; pred.casNext(s, n) &amp;&amp; pred.isMatched())) &#123;//解除s节点的链接 for (;;) &#123; // check if at, or could be, head Node h = head; if (h == pred || h == s || h == null) return; // at head or list empty if (!h.isMatched()) break; Node hn = h.next; if (hn == null) return; // now empty if (hn != h &amp;&amp; casHead(h, hn))//更新head h.forgetNext(); // advance head &#125; if (pred.next != pred &amp;&amp; s.next != s) &#123; // recheck if offlist for (;;) &#123; // sweep now if enough votes int v = sweepVotes; if (v &lt; SWEEP_THRESHOLD) &#123; if (casSweepVotes(v, v + 1)) break; &#125; else if (casSweepVotes(v, 0)) &#123;//达到阀值，进行"大扫除"，清除队列中的无效节点 sweep(); break; &#125; &#125; &#125; &#125; &#125;&#125; 说明：首先把给定节点s的next引用指向自身，如果s的前继节点pred还是指向s（pred.next == s），尝试解除s的链接，把pred的 next 引用指向s的 next 节点。如果s不能被解除（由于它是尾节点或者pred可能被解除链接，并且pred和s都不是head节点或已经出列），则添加到sweepVotes，sweepVotes累计到阀值SWEEP_THRESHOLD之后就调用sweep()对队列进行一次“大扫除”，清除队列中所有的无效节点。sweep()源码如下： 12345678910111213141516171819/** * Unlinks matched (typically cancelled) nodes encountered in a * traversal from head. * 解除(通常是取消)从头部遍历时遇到的已经被匹配的节点的链接 */private void sweep() &#123; for (Node p = head, s, n; p != null &amp;&amp; (s = p.next) != null; ) &#123; if (!s.isMatched()) // Unmatched nodes are never self-linked p = s; else if ((n = s.next) == null) // trailing node is pinned break; else if (s == n) // stale // No need to also check for p == s, since that implies s == n p = head; else p.casNext(s, n); &#125;&#125; 小结本章重点：理解 LinkedTransferQueue 的特性：双重队列、松弛度、节点的移除操作。在 ConcurrentLinkedQueue 、 ConcurrentLinkeDeque 以及 SynchronousQueue 中都用到了 LinkedTransferQueue 的某些特性，如果同学们对它们感兴趣，理解本章对之后的源码解析会有很大的帮助。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>LinkedTransferQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒杀设计小结]]></title>
    <url>%2F2020%2F05%2F12%2F%E7%A7%92%E6%9D%80%E8%AE%BE%E8%AE%A1%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[秒杀设计接口设计然一次性解决会有问题，那就分多次解决！简单的描主要两个接口 OrderSeckillService商品秒杀查询服务接口 用于查询秒杀结果 电话+秒杀订单号作为查询采纳数 SpikeCommodityService秒杀商品接口 有两个方法 spike方法是秒杀商品接口 addSpikeToken用于生成秒杀库存数量的令牌 基于令牌桶实现秒杀 新增对应商品库存令牌桶 秒杀高并发方案 提前生成好token拿到token意味抢购成功 123456789101112131415161718192021222324252627public interface OrderSeckillService &#123; @RequestMapping("/getOrder") public BaseResponse&lt;JSONObject&gt; getOrder(String phone, Long seckillId);&#125;public interface SpikeCommodityService &#123; /** * 用户秒杀接口 phone和userid都可以的 * * @phone 手机号码&lt;br&gt; * @seckillId 库存id * @return */ @RequestMapping("/spike")然一次性解决会有问题，那就分多次解决！简单的描 public BaseResponse&lt;JSONObject&gt; spike(String phone, Long seckillId); /** * 新增对应商品库存令牌桶 秒杀高并发方案 提前生成好token拿到token意味抢购成功 * * @seckillId 商品库存id */ @RequestMapping("/addSpikeToken") public BaseResponse&lt;JSONObject&gt; addSpikeToken(Long seckillId, Long tokenQuantity);&#125; 接口实现查询秒杀结果 查询参数手机号+秒杀订单号 123456789101112131415161718192021222324@RestController@Slf4jpublic class OrderSeckillServiceImpl extends BaseApiService&lt;JSONObject&gt; implements OrderSeckillService &#123; @Autowired private OrderMapper orderMapper; @Override public BaseResponse&lt;JSONObject&gt; getOrder(String phone, Long seckillId) &#123; log.info("&gt;&gt;&gt;&gt;&gt;&gt;查询秒杀结果线程名称:" + Thread.currentThread().getName()); if (StringUtils.isEmpty(phone)) &#123; return setResultError("手机号码不能为空!"); &#125; if (seckillId == null) &#123; return setResultError("商品库存id不能为空!"); &#125; OrderEntity orderEntity = orderMapper.findByOrder(phone, seckillId); if (orderEntity == null) &#123; return setResultError("正在排队中....."); &#125; return setResultSuccess("恭喜你秒杀成功!"); &#125;&#125; 秒杀商品实现 主要实现两个方法 spike方法 主要实现多用户争夺令牌桶中的令牌 若获得了token则秒杀成功 addSpikeToken方法异步生成令牌 参数为seckill_id和tokenQuantity 分别是商品标识id与秒杀数量库存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@RestController@Slf4jpublic class SpikeCommodityServiceImpl extends BaseApiService&lt;JSONObject&gt; implements SpikeCommodityService &#123; @Autowired private SeckillMapper seckillMapper; @Autowired private GenerateToken generateToken; @Autowired private SpikeCommodityProducer spikeCommodityProducer; // 每秒时间存入令牌桶中Token为1个 1s/1r /** * 注解 AOP 减少代码重复调用 使用网关开启限流 */ @Override @Transactional @HystrixCommand(fallbackMethod = "spikeFallback") public BaseResponse&lt;JSONObject&gt; spike(String phone, Long seckillId) &#123; log.info("###&gt;&gt;&gt;&gt;&gt;秒杀接口线程池名称:" + Thread.currentThread().getName()); // 1.参数验证 if (StringUtils.isEmpty(phone)) &#123; return setResultError("手机号码不能为空!"); &#125; if (seckillId == null) &#123; return setResultError("商品库存id不能为空!"); &#125; // 2.从redis从获取对应的秒杀token String seckillToken = generateToken.getListKeyToken(seckillId + ""); if (StringUtils.isEmpty(seckillToken)) &#123; log.info("&gt;&gt;&gt;seckillId:&#123;&#125;, 亲，该秒杀已经售空，请下次再来!", seckillId); return setResultError("亲，该秒杀已经售空，请下次再来!"); &#125; // 3.获取到秒杀token之后，异步放入mq中实现修改商品的库存 sendSeckillMsg(seckillId, phone); return setResultSuccess("正在排队中......."); &#125; private BaseResponse&lt;JSONObject&gt; spikeFallback(String phone, Long seckillId) &#123; return setResultError("服务器忙,请稍后重试!"); &#125; /** * 获取到秒杀token之后，异步放入mq中实现修改商品的库存 */ @Async private void sendSeckillMsg(Long seckillId, String phone) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("seckillId", seckillId); jsonObject.put("phone", phone); spikeCommodityProducer.send(jsonObject); &#125; // 结业项目中采用rabbitmq实现秒杀 /** * 面试官 都喜欢问 你们项目中在那些地方使用到多线程 * * @param seckillId * @param tokenQuantity * @return */ // 采用redis数据库类型为 list类型 key为 商品库存id list 多个秒杀token @Override public BaseResponse&lt;JSONObject&gt; addSpikeToken(Long seckillId, Long tokenQuantity) &#123; // 1.验证参数lingpai if (seckillId == null) &#123; return setResultError("商品库存id不能为空!"); &#125; if (tokenQuantity == null) &#123; return setResultError("token数量不能为空!"); &#125; SeckillEntity seckillEntity = seckillMapper.findBySeckillId(seckillId); if (seckillEntity == null) &#123; return setResultError("商品信息不存在!"); &#125; // 2.使用多线程异步生产令牌 createSeckillToken(seckillId, tokenQuantity); return setResultSuccess("令牌正在生成中....."); &#125; @Async public void createSeckillToken(Long seckillId, Long tokenQuantity) &#123; generateToken.createListToken("seckill_", seckillId + "", tokenQuantity); &#125;&#125; 秒杀生产者与消费者生产者 将秒杀成功的用户信息投递到mq中 供消费者消费 异步修改数据库 123456789101112131415161718192021222324252627282930313233343536373839@Component@Slf4jpublic class SpikeCommodityProducer implements RabbitTemplate.ConfirmCallback &#123; @Autowired private RabbitTemplate rabbitTemplate; @Transactional public void send(JSONObject jsonObject) &#123; String jsonString = jsonObject.toJSONString(); System.out.println("jsonString:" + jsonString); String messAgeId = UUID.randomUUID().toString().replace("-", ""); // 封装消息 Message message = MessageBuilder.withBody(jsonString.getBytes()) .setContentType(MessageProperties.CONTENT_TYPE_JSON).setContentEncoding("utf-8").setMessageId(messAgeId) .build(); // 构建回调返回的数据（消息id） this.rabbitTemplate.setMandatory(true); this.rabbitTemplate.setConfirmCallback(this); CorrelationData correlationData = new CorrelationData(jsonString); rabbitTemplate.convertAndSend("modify_exchange_name", "modifyRoutingKey", message, correlationData); &#125; // 生产消息确认机制 生产者往服务器端发送消息的时候，采用应答机制 @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; String jsonString = correlationData.getId(); System.out.println("消息id:" + correlationData.getId()); if (ack) &#123; log.info("&gt;&gt;&gt;使用MQ消息确认机制确保消息一定要投递到MQ中成功"); return; &#125; JSONObject jsonObject = JSONObject.parseObject(jsonString); // 生产者消息投递失败的话，采用递归重试机制 send(jsonObject); log.info("&gt;&gt;&gt;使用MQ消息确认机制投递到MQ中失败"); &#125;&#125; 消费者消费信息 获取秒杀id 查询商品信息 若没有则返回 然后修改商品库存 cas并发加版本号修改库存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component@Slf4jpublic class StockConsumer &#123; @Autowired private SeckillMapper seckillMapper; @Autowired private OrderMapper orderMapper; @RabbitListener(queues = "modify_inventory_queue") @Transactional public void process(Message message, @Headers Map&lt;String, Object&gt; headers, Channel channel) throws IOException &#123; String messageId = message.getMessageProperties().getMessageId(); String msg = new String(message.getBody(), "UTF-8"); log.info("&gt;&gt;&gt;messageId:&#123;&#125;,msg:&#123;&#125;", messageId, msg); JSONObject jsonObject = JSONObject.parseObject(msg); // 1.获取秒杀id Long seckillId = jsonObject.getLong("seckillId"); SeckillEntity seckillEntity = seckillMapper.findBySeckillId(seckillId); if (seckillEntity == null) &#123; log.warn("seckillId:&#123;&#125;,商品信息不存在!", seckillId); return; &#125; Long version = seckillEntity.getVersion(); int inventoryDeduction = seckillMapper.inventoryDeduction(seckillId, version); if (!toDaoResult(inventoryDeduction)) &#123; log.info("&gt;&gt;&gt;seckillId:&#123;&#125;修改库存失败&gt;&gt;&gt;&gt;inventoryDeduction返回为&#123;&#125; 秒杀失败！", seckillId, inventoryDeduction); return; &#125; // 2.添加秒杀订单 OrderEntity orderEntity = new OrderEntity(); String phone = jsonObject.getString("phone"); orderEntity.setUserPhone(phone); orderEntity.setSeckillId(seckillId); orderEntity.setState(1l); int insertOrder = orderMapper.insertOrder(orderEntity); if (!toDaoResult(insertOrder)) &#123; return; &#125; log.info("&gt;&gt;&gt;修改库存成功seckillId:&#123;&#125;&gt;&gt;&gt;&gt;inventoryDeduction返回为&#123;&#125; 秒杀成功", seckillId, inventoryDeduction); &#125; // 调用数据库层判断 public Boolean toDaoResult(int result) &#123; return result &gt; 0 ? true : false; &#125;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚合支付小结]]></title>
    <url>%2F2020%2F05%2F12%2F%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[聚合支付平台设计api接口设计 创建支付令牌接口 123456789public interface PayMentTransacTokenService &#123; /** * 创建支付令牌 * * @return */ @GetMapping("/createPayToken") public BaseResponse&lt;JSONObject&gt; createPayToken(@Validated PayCreatePayTokenDto payCreatePayTokenDto);&#125; 查询交易信息接口 123456789101112131415161718yMentTransacTokenService &#123; @Autowired private PaymentTransactionMapper paymentTransactionMapper; @Autowired private GenerateToken generateToken; @Override public BaseResponse&lt;JSONObject&gt; createPayToken(PayCreatePayTokenDto payCreatePayTokenDto) &#123; String orderId = payCreatePayTokenDto.getOrpublic interface PayMentTransacTokenService &#123; /** * 创建支付令牌 * * @return */ @GetMapping("/createPayToken") public BaseResponse&lt;JSONObject&gt; createPayToken(@Validated PayCreatePayTokenDto payCreatePayTokenDto);&#125; 查询所有支付渠道接口 123456789public interface PaymentChannelService &#123; /** * 查询所有支付渠道 * * @return */ @GetMapping("/selectAll") public List&lt;PaymentChannelDTO&gt; selectAll();&#125; 策略上下文接口 123456public interface PayContextService &#123; @GetMapping("/toPayHtml") public BaseResponse&lt;JSONObject&gt; toPayHtml(@RequestParam("channelId") String channelId, @RequestParam("payToken") String payToken);&#125; 聚合支付服务实现包结构 service.impl包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@RestControllerpublic class PayMentTransacTokenServiceImpl extends BaseApiService&lt;JSONObject&gt; implements PayMentTransacTokenService &#123; @Autowired private PaymentTransactionMapper paymentTransactionMapper; @Autowired private GenerateToken generateToken; @Override public BaseResponse&lt;JSONObject&gt; createPayToken(PayCreatePayTokenDto payCreatePayTokenDto) &#123; String orderId = payCreatePayTokenDto.getOrderId(); if (StringUtils.isEmpty(orderId)) &#123; return setResultError("订单号码不能为空!"); &#125; Long payAmount = payCreatePayTokenDto.getPayAmount(); if (payAmount == null) &#123; return setResultError("金额不能为空!"); &#125; Long userId = payCreatePayTokenDto.getUserId(); if (userId == null) &#123; return setResultError("userId不能为空!"); &#125; // 2.将输入插入数据库中 待支付记录 PaymentTransactionEntity paymentTransactionEntity = new PaymentTransactionEntity(); paymentTransactionEntity.setOrderId(orderId); paymentTransactionEntity.setPayAmount(payAmount); paymentTransactionEntity.setUserId(userId); // 使用雪花算法 生成全局id paymentTransactionEntity.setPaymentId(SnowflakeIdUtils.nextId()); int result = paymentTransactionMapper.insertPaymentTransaction(paymentTransactionEntity); if (!toDaoResult(result)) &#123; return setResultError("系统错误!"); &#125; // 获取主键id Long payId = paymentTransactionEntity.getId(); if (payId == null) &#123; return setResultError("系统错误!"); &#125; // 3.生成对应支付令牌 String keyPrefix = "pay_"; String token = generateToken.createToken(keyPrefix, payId + ""); JSONObject dataResult = new JSONObject(); dataResult.put("token", token); return setResultSuccess(dataResult); &#125;&#125; PayMentTransacTokenServiceImpl类是PayMentTransacTokenService的实现类，主要用于创建交易订单的支付token生成, 首先对payCreatePayTokenDto进行参数验证，然后设置PaymentTransactionEntity属性值插入数据库，插入预支付记录，数据库中有payment_status标记支付状态，0代表预支付,1代表已支付,使用雪花算法生成全局id . 插入成功后对插入记录判断是否插入成功以及获取id判断雪花生成id是否成功。最后利用工具类创建支付令牌，generateToken对象创建token,然后将token存放在json中返回。 1234567891011121314151617181920212223242526272829@RestControllerpublic class PayMentTransacInfoServiceImpl extends BaseApiService&lt;PayMentTransacDTO&gt; implements PayMentTransacInfoService &#123; @Autowired private GenerateToken generateToken; @Autowired private PaymentTransactionMapper paymentTransactionMapper; @Override public BaseResponse&lt;PayMentTransacDTO&gt; tokenByPayMentTransac(String token) &#123; // 1.验证token是否为空 if (StringUtils.isEmpty(token)) &#123; return setResultError("token参数不能空!"); &#125; // 2.使用token查询redisPayMentTransacID String value = generateToken.getToken(token); if (StringUtils.isEmpty(value)) &#123; return setResultError("该Token可能已经失效或者已经过期"); &#125; // 3.转换为整数类型 Long transactionId = Long.parseLong(value); // 4.使用transactionId查询支付信息 PaymentTransactionEntity paymentTransaction = paymentTransactionMapper.selectById(transactionId); if (paymentTransaction == null) &#123; return setResultError("未查询到该支付信息"); &#125; return setResultSuccess(ElvisBeanUtils.doToDto(paymentTransaction, PayMentTransacDTO.class)); &#125;&#125; 查询交易信息实现类 通过token查询交易订单号 查询交易信息 123456789101112@RestControllerpublic class PaymentChannelServiceImpl extends BaseApiService&lt;List&lt;PaymentChannelDTO&gt;&gt; implements PaymentChannelService &#123; @Autowired private PaymentChannelMapper paymentChannelMapper; @Override public List&lt;PaymentChannelDTO&gt; selectAll() &#123; List&lt;PaymentChannelEntity&gt; paymentChanneList = paymentChannelMapper.selectAll(); return MapperUtils.mapAsList(paymentChanneList, PaymentChannelDTO.class); &#125;&#125; 查询所有渠道信息 123456789101112131415161718192021222324252627282930313233@RestControllerpublic class PayContextServiceImpl extends BaseApiService&lt;JSONObject&gt; implements PayContextService &#123; //根据channelId查询classAddres(反射全类名) @Autowired private PaymentChannelMapper paymentChannelMapper; @Autowired private PayMentTransacInfoService payMentTransacInfoService; @Override public BaseResponse&lt;JSONObject&gt; toPayHtml(String channelId, String payToken) &#123; // 1.使用渠道id获取渠道信息 classAddres PaymentChannelEntity pymentChannel = paymentChannelMapper.selectBychannelId(channelId); if (pymentChannel == null) &#123; return setResultError("没有查询到该渠道信息"); &#125; // 2.使用payToken获取支付参数 BaseResponse&lt;PayMentTransacDTO&gt; tokenByPayMentTransac = payMentTransacInfoService .tokenByPayMentTransac(payToken); if (!isSuccess(tokenByPayMentTransac)) &#123; return setResultError(tokenByPayMentTransac.getMsg()); &#125; PayMentTransacDTO payMentTransacDTO = tokenByPayMentTransac.getData(); // 3.执行具体的支付渠道的算法获取html表单数据 策略设计模式 使用java反射机制 执行具体方法 String classAddres = pymentChannel.getClassAddres(); PayStrategy payStrategy = StrategyFactory.getPayStrategy(classAddres); String payHtml = payStrategy.toPayHtml(pymentChannel, payMentTransacDTO); // 4.直接返回html JSONObject data = new JSONObject(); data.put("payHtml", payHtml); return setResultSuccess(data); &#125;&#125; 基于策略模式返回不同html,传入渠道id与token,返回对应渠道的支付页面。首先根据渠道id查询对应渠道的全类名，通过token查询支付订单信息,通过全类名反射生成对象,由策略工厂生成,策略接口持有,不同的策略会有不同的实现,如支付宝策略,银联策略 包strategy 实现不同的渠道调用首先是该包下的策略接口 不同的支付渠道有各自的实现策略 如支付宝、银联有具体的实现 12345678910111213public interface PayStrategy &#123; /** * * @param paymentChannel * 渠道参数 * @param payMentTransacDTO * 支付参数 * @return */ public String toPayHtml(PaymentChannelEntity paymentChannel, PayMentTransacDTO payMentTransacDTO);&#125; 以支付宝为例 下面是支付宝的具体策略实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Slf4jpublic class AliPayStrategy implements PayStrategy &#123; @Override public String toPayHtml(PaymentChannelEntity pymentChannel, PayMentTransacDTO payMentTransacDTO) &#123; log.info("&gt;&gt;&gt;&gt;&gt;支付宝参数封装开始&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); // 获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, "json", AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type); // 设置请求参数 AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest(); alipayRequest.setReturnUrl(AlipayConfig.return_url); alipayRequest.setNotifyUrl(AlipayConfig.notify_url); // 商户订单号，商户网站订单系统中唯一订单号，必填 String outTradeNo = payMentTransacDTO.getPaymentId(); // 付款金额，必填 String totalAmount = changeF2Y(payMentTransacDTO.getPayAmount() + ""); // 订单名称，必填 String subject = "珊珊幼儿园"; // 商品描述，可空 String body = "珊珊课程服务"; alipayRequest.setBizContent("&#123;\"out_trade_no\":\"" + outTradeNo + "\"," + "\"total_amount\":\"" + totalAmount + "\"," + "\"subject\":\"" + subject + "\"," + "\"body\":\"" + body + "\"," + "\"product_code\":\"FAST_INSTANT_TRADE_PAY\"&#125;"); // 请求 try &#123; String result = alipayClient.pageExecute(alipayRequest).getBody(); return result; &#125; catch (Exception e) &#123; return null; &#125; &#125; /** 金额为分的格式 */ public static final String CURRENCY_FEN_REGEX = "\\-?[0-9]+"; /** * 将分为单位的转换为元 （除100） * * @param amount * @return * @throws Exception */ public static String changeF2Y(String amount) &#123; if (!amount.matches(CURRENCY_FEN_REGEX)) &#123; return null; &#125; return BigDecimal.valueOf(Long.valueOf(amount)).divide(new BigDecimal(100)).toString(); &#125;&#125; 策略工厂类 格局全类名生产对应的对象 ConcurrentHashMap维护全类名与具体策略映射 ConcurrentHashMap保存的话后面可以不用每次都实例化 只需要一次实例化 123456789101112131415161718192021222324public class StrategyFactory &#123; private static Map&lt;String, PayStrategy&gt; strategyBean = new ConcurrentHashMap&lt;&gt;(); // 思考几个点： public static PayStrategy getPayStrategy(String classAddres) &#123; try &#123; if (StringUtils.isEmpty(classAddres)) &#123; return null; &#125; PayStrategy beanPayStrategy = strategyBean.get(classAddres); if (beanPayStrategy != null) &#123; return beanPayStrategy; &#125; // 1.使用Java的反射机制初始化子类 Class&lt;?&gt; forName = Class.forName(classAddres); // 2.反射机制初始化对象 PayStrategy payStrategy = (PayStrategy) forName.newInstance(); strategyBean.put(classAddres, payStrategy); return payStrategy; &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; callback包实现异步回调 下面两个包 ![img]/picture/callback.png) 首先异步回调采用模板方法进行重构代码 针对支付宝与银联进行公共代码抽取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293@Slf4jpublic abstract class AbstractPayCallbackTemplate &#123; @Autowired private PaymentTransactionLogMapper paymentTransactionLogMapper; @Autowired private ThreadPoolTaskExecutor threadPoolTaskExecutor; /** * 获取所有请求的参数，封装成Map集合 并且验证是否被篡改 * * @param req * @param resp * @return */ @Transactional public abstract Map&lt;String, String&gt; verifySignature(HttpServletRequest req, HttpServletResponse resp); /** * 异步回调执行业务逻辑 * * @param verifySignature */ public abstract String asyncService(Map&lt;String, String&gt; verifySignature); public abstract String failResult(); public abstract String successResult(); /** * *1. 将报文数据存放到es &lt;br&gt; * 1. 验证报文参数&lt;br&gt; * 2. 将日志根据支付id存放到数据库中&lt;br&gt; * 3. 执行的异步回调业务逻辑&lt;br&gt; */ @Transactional public String asyncCallBack(HttpServletRequest req, HttpServletResponse resp) &#123; // 1. 验证报文参数 相同点 获取所有的请求参数封装成为map集合 并且进行参数验证 Map&lt;String, String&gt; verifySignature = verifySignature(req, resp); // 2.将日志根据支付id存放到数据库中 String paymentId = verifySignature.get("paymentId"); if (StringUtils.isEmpty(paymentId)) &#123; return failResult(); &#125; // 3.采用异步形式写入日志到数据库中 payLog(paymentId, verifySignature); //new Thread(new PayLogThread(paymentId,verifySignature)).start(); String result = verifySignature.get(PayConstant.RESULT_NAME); // 4.201报文验证签名失败 if (result.equals(PayConstant.RESULT_PAYCODE_201)) &#123; return failResult(); &#125; // 5.执行的异步回调业务逻辑 return asyncService(verifySignature); &#125; /** * 采用多线程技术或者MQ形式进行存放到数据库中 * * @param paymentId * @param verifySignature */ private void payLog(String paymentId, Map&lt;String, String&gt; verifySignature) &#123; log.info("&gt;&gt;paymentId:&#123;paymentId&#125;,verifySignature:&#123;&#125;", verifySignature); PaymentTransactionLogEntity paymentTransactionLog = new PaymentTransactionLogEntity(); paymentTransactionLog.setTransactionId(paymentId); paymentTransactionLog.setAsyncLog(verifySignature.toString()); paymentTransactionLogMapper.insertTransactionLog(paymentTransactionLog); &#125; // A 1423 B 1234 /** * 使用多线程写入日志目的：加快响应 提高程序效率 使用线程池维护线程 */ class PayLogThread implements Runnable &#123; private String paymentId; private Map&lt;String, String&gt; verifySignature; public PayLogThread(String paymentId, Map&lt;String, String&gt; verifySignature) &#123; this.paymentId = paymentId; this.verifySignature = verifySignature; &#125; @Override public void run() &#123; log.info("&gt;&gt;&gt;&gt;&gt;asyncCallBack service 02"); payLog(paymentId, verifySignature); log.info("&gt;&gt;&gt;&gt;&gt;asyncCallBack service 03"); &#125; &#125;&#125; 模板方法抽象异步回调逻辑 asyncCallBack方法组装异步回调逻辑 然后验签、异步回调通知延迟到子类实现 写日志可以采用多线程或异步mq方式实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106addMQIntegral@Componentpublic class UnionPayCallbackTemplate extends AbstractPayCallbackTemplate &#123; @Autowired private PaymentTransactionMapper paymentTransactionMapper; @Autowired private IntegralProducer integralProducer; @Override public Map&lt;String, String&gt; verifySignature(HttpServletRequest req, HttpServletResponse resp) &#123; LogUtil.writeLog("BackRcvResponse接收后台通知开始"); String encoding = req.getParameter(SDKConstants.param_encoding); // 获取银联通知服务器发送的后台通知参数 Map&lt;String, String&gt; reqParam = getAllRequestParam(req); LogUtil.printRequestLog(reqParam); // 重要！验证签名前不要修改reqParam中的键值对的内容，否则会验签不过 if (!AcpService.validate(reqParam, encoding)) &#123; LogUtil.writeLog("验证签名结果[失败]."); reqParam.put(PayConstant.RESULT_NAME, PayConstant.RESULT_PAYCODE_201); &#125; else &#123; LogUtil.writeLog("验证签名结果[成功]."); // 【注：为了安全验签成功才应该写商户的成功处理逻辑】交易成功，更新商户订单状态 String orderId = reqParam.get("orderId"); // 获取后台通知的数据，其他字段也可用类似方式获取 reqParam.put("paymentId", orderId); reqParam.put(PayConstant.RESULT_NAME, PayConstant.RESULT_PAYCODE_200); &#125; LogUtil.writeLog("BackRcvResponse接收后台通知结束"); return reqParam; &#125; // 异步回调中网络尝试延迟，导致异步回调重复执行 可能存在幂等性问题 @Override @Transactional public String asyncService(Map&lt;String, String&gt; verifySignature) &#123; String orderId = verifySignature.get("orderId"); // 获取后台通知的数据，其他字段也可用类似方式获取 String respCode = verifySignature.get("respCode"); // 判断respCode=00、A6后，对涉及资金类的交易，请再发起查询接口查询，确定交易成功后更新数据库。 System.out.println("orderId:" + orderId + ",respCode:" + respCode); // 1.判断respCode是否为已经支付成功断respCode=00、A6后， if (!(respCode.equals("00") || respCode.equals("A6"))) &#123; return failResult(); &#125; // 根据日志 手动补偿 使用支付id调用第三方支付接口查询 PaymentTransactionEntity paymentTransaction = paymentTransactionMapper.selectByPaymentId(orderId); if (paymentTransaction.getPaymentStatus().equals(PayConstant.PAY_STATUS_SUCCESS)) &#123; // 网络重试中，之前已经支付过 return successResult(); &#125; // 2.将状态改为已经支付成功 paymentTransactionMapper.updatePaymentStatus(PayConstant.PAY_STATUS_SUCCESS + "", orderId); // 3.调用积分服务接口增加积分(处理幂等性问题) 查询支付状态 如果支付成功 不用重试 addMQIntegral(paymentTransaction); // 使用MQ return successResult(); &#125; /** * 基于MQ增加积分 */ @Async protected void addMQIntegral(PaymentTransactionEntity paymentTransaction) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("paymentId", paymentTransaction.getPaymentId()); jsonObject.put("userId", paymentTransaction.getUserId()); jsonObject.put("integral", 100); integralProducer.send(jsonObject); &#125; @Override public String failResult() &#123; return PayConstant.YINLIAN_RESULT_FAIL; &#125;然一次性解决会有问题，那就分多次解决！简单的描 @Override public String successResult() &#123; return PayConstant.YINLIAN_RESULT_SUCCESS; &#125; /** * 获取请求参数中所有的信息 当商户上送frontUrl或backUrl地址中带有参数信息的时候， * 这种方式会将url地址中的参数读到map中，会导多出来这些信息从而致验签失败， * 这个时候可以自行修改过滤掉url中的参数或者使用getAllRequestParamStream方法。 * * @param request * @return */ public static Map&lt;String, String&gt; getAllRequestParam(final HttpServletRequest request) &#123; Map&lt;String, String&gt; res = new HashMap&lt;String, String&gt;(); Enumeration&lt;?&gt; temp = request.getParameterNames(); if (null != temp) &#123; while (temp.hasMoreElements()) &#123; String en = (String) temp.nextElement(); String value = request.getParameter(en); res.put(en, value); // 在报文上送时，如果字段的值为空，则不上送&lt;下面的处理为在获取所有参数数据时，判断若值为空，则删除这个字段&gt; if (res.get(en) == null || "".equals(res.get(en))) &#123; // System.out.println("======为空的字段名===="+en); res.remove(en); &#125; &#125; &#125; return res; &#125; ｝ 具体的银联异步回调模板 其中asyncService方法执行具体异步回调通知 首先获取上一步验签的结果 获取状态码 然后进行判断是否执行成功 若失败则返回失败结果 否则通过支付id查询支付状态 若支付成功 可能是网络重试 直接返回成功状态 避免反复重试造成积分等服务的幂等性问题 若支付状态没有修改 则修改支付状态为1 并异步mq增加积分并返回成功状态 addMQIntegral方法调用积分服务 采用rabbitmq异步增加积分 1234567public class TemplateFactory &#123; public static AbstractPayCallbackTemplate getPayCallbackTemplate(String beanId) &#123; return (AbstractPayCallbackTemplate) SpringContextUtil.getBean(beanId); &#125;&#125; 模板工厂根据beanId获取对应的模板 123456789101112131415161718@RestControllerpublic class PayAsynCallbackService &#123; private static final String UNIONPAYCALLBACK_TEMPLATE = "unionPayCallbackTemplate"; /** * 银联异步回调接口执行代码 * * @param req * @param resp * @return */ @RequestMapping("/unionPayAsynCallback") public String unionPayAsynCallback(HttpServletRequest req, HttpServletResponse resp) &#123; AbstractPayCallbackTemplate abstractPayCallbackTemplate = TemplateFactory .getPayCallbackTemplate(UNIONPAYCALLBACK_TEMPLATE); return abstractPayCallbackTemplate.asyncCallBack(req, resp); &#125;&#125; PayAsynCallbackService执行异步回调逻辑 调用抽象模板组装业务逻辑的方法asyncCallBack 整合积分服务 积分投递成功查询与积分增加 1234567public interface IntegralMapper &#123; @Insert("INSERT INTO `elvis_integral` VALUES (NULL, #&#123;userId&#125;, #&#123;paymentId&#125;,#&#123;integral&#125;, #&#123;availability&#125;, 0, null, now(), null, now());") public int insertIntegral(IntegralEntity integralEntity); @Select("SELECT id as id ,USER_ID as userId, PAYMENT_ID as PAYMENTID ,INTEGRAL as INTEGRAL ,AVAILABILITY as AVAILABILITY FROM elvis_integral where PAYMENT_ID=#&#123;paymentId&#125; AND AVAILABILITY='1';") public IntegralEntity findIntegral(String paymentId);&#125; 积分服务 消费者 监听积分队列 处理积分增加幂等性问题 先获取队列信息 首先获取paymentId 如果为空 则可能已经消费手动签收 再进行积分查询 看积分是否已经增加若增加 手动签收 再对userId,integral进行判空验证 最后将积分增加 支付订单+积分保证唯一 若数据库插入成功 手动签收 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Component@Slf4jpublic class IntegralConsumer &#123; @Autowired private IntegralMapper integralMapper; @RabbitListener(queues = "integral_queue") public void process(Message message, @Headers Map&lt;String, Object&gt; headers, Channel channel) throws IOException &#123; try &#123; String messageId = message.getMessageProperties().getMessageId(); String msg = new String(message.getBody(), "UTF-8"); log.info("&gt;&gt;&gt;messageId:&#123;&#125;,msg:&#123;&#125;", messageId, msg); JSONObject jsonObject = JSONObject.parseObject(msg); String paymentId = jsonObject.getString("paymentId"); if (StringUtils.isEmpty(paymentId)) &#123; log.error("&gt;&gt;&gt;&gt;支付id不能为空 paymentId:&#123;&#125;", paymentId); basicNack(message, channel); return; &#125; // 使用paymentId查询是否已经增加过积分 网络重试间隔 IntegralEntity resultIntegralEntity = integralMapper.findIntegral(paymentId); if (resultIntegralEntity != null) &#123; log.error("&gt;&gt;&gt;&gt;paymentId:&#123;&#125;已经增加过积分", paymentId); // 已经增加过积分，通知MQ不要在继续重试。 basicNack(message, channel); return; &#125; Integer userId = jsonObject.getInteger("userId"); if (userId == null) &#123; log.error("&gt;&gt;&gt;&gt;paymentId:&#123;&#125;,对应的用户userId参数为空", paymentId); basicNack(message, channel); return; &#125; Long integral = jsonObject.getLong("integral"); if (integral == null) &#123; log.error("&gt;&gt;&gt;&gt;paymentId:&#123;&#125;,对应的用户integral参数为空", integral); return; &#125; IntegralEntity integralEntity = new IntegralEntity(); integralEntity.setPaymentId(paymentId); integralEntity.setIntegral(integral); integralEntity.setUserId(userId); integralEntity.setAvailability(1); // 插入到数据库中 int insertIntegral = integralMapper.insertIntegral(integralEntity); if (insertIntegral &gt; 0) &#123; // 手动签收消息,通知mq服务器端删除该消息 basicNack(message, channel); &#125; // 采用重试机制 &#125; catch (Exception e) &#123; log.error("&gt;&gt;&gt;&gt;ERROR MSG:", e.getMessage()); basicNack(message, channel); &#125; &#125; // 消费者获取到消息之后 手动签收 通知MQ删除该消息 private void basicNack(Message message, Channel channel) throws IOException &#123; channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); &#125; // 什么场景下 适合于重试 网络连接、空指针 参数错误&#125; 积分生产者 投递增加积分消息 采用重试+ack确认机制保证消息成功投递到mq 1234567891011121314151617181920212223242526272829303132333435363738394041@Component@Slf4jpublic class IntegralProducer implements RabbitTemplate.ConfirmCallback &#123; @Autowired private RabbitTemplate rabbitTemplate; private static final String INTEGRAL_EXCHANGE_NAME = "integral_exchange_name"; private static final String INTEGRAL_ROUTINGKEY = "integralRoutingKey"; @Transactional public void send(JSONObject jsonObject) &#123; String jsonString = jsonObject.toJSONString(); System.out.println("jsonString:" + jsonString); String paymentId = jsonObject.getString("paymentId"); // 封装消息 Message message = MessageBuilder.withBody(jsonString.getBytes()) .setContentType(MessageProperties.CONTENT_TYPE_JSON).setContentEncoding("utf-8").setMessageId(paymentId) .build(); // 构建回调返回的数据（消息id） this.rabbitTemplate.setMandatory(true); this.rabbitTemplate.setConfirmCallback(this); CorrelationData correlationData = new CorrelationData(jsonString); rabbitTemplate.convertAndSend(INTEGRAL_EXCHANGE_NAME, INTEGRAL_ROUTINGKEY, message, correlationData); &#125; // 生产消息确认机制 生产者往服务器端发送消息的时候，采用应答机制 @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; String jsonString = correlationData.getId(); System.out.println("消息id:" + correlationData.getId()); if (ack) &#123; log.info("&gt;&gt;&gt;使用MQ消息确认机制确保消息一定要投递到MQ中成功"); return; &#125; JSONObject jsonObject = JSONObject.parseObject(jsonString); // 生产者消息投递失败的话，采用递归重试机制 send(jsonObject); log.info("&gt;&gt;&gt;使用MQ消息确认机制投递到MQ中失败"); &#125;&#125; 积分补偿队列 解决在支付状态与积分增加之间存在的分布式任务问题 因为增加积分是异步的，若事务回滚，积分增加了支付状态还是待支付则出现不一致的分布式事务问题，所以进行补偿，若积分增加了则将支付状态改为已支付状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Component@Slf4jpublic class PayCheckStateConsumer &#123; @Autowired private PaymentTransactionMapper paymentTransactionMapper; // 死信队列（备胎） 消息被拒绝、队列长度满了 定时任务 人工补偿 @RabbitListener(queues = "integral_create_queue") public void process(Message message, @Headers Map&lt;String, Object&gt; headers, Channel channel) throws IOException &#123; try &#123; String messageId = message.getMessageProperties().getMessageId(); String msg = new String(message.getBody(), "UTF-8"); log.info("&gt;&gt;&gt;messageId:&#123;&#125;,msg:&#123;&#125;", messageId, msg); JSONObject jsonObject = JSONObject.parseObject(msg); String paymentId = jsonObject.getString("paymentId"); if (StringUtils.isEmpty(paymentId)) &#123; log.error("&gt;&gt;&gt;&gt;支付id不能为空 paymentId:&#123;&#125;", paymentId); basicNack(message, channel); return; &#125; // 1.使用paymentId查询之前是否已经支付过 PaymentTransactionEntity paymentTransactionEntity = paymentTransactionMapper.selectByPaymentId(paymentId); if (paymentTransactionEntity == null) &#123; log.error("&gt;&gt;&gt;&gt;支付id paymentId:&#123;&#125; 未查询到", paymentId); basicNack(message, channel); return; &#125; Integer paymentStatus = paymentTransactionEntity.getPaymentStatus(); if (paymentStatus.equals(PayConstant.PAY_STATUS_SUCCESS)) &#123; log.error("&gt;&gt;&gt;&gt;支付id paymentId:&#123;&#125; ", paymentId); basicNack(message, channel); return; &#125; // 安全起见 主动调用第三方接口查询 String paymentChannel = jsonObject.getString("paymentChannel"); int updatePaymentStatus = paymentTransactionMapper.updatePaymentStatus(PayConstant.PAY_STATUS_SUCCESS + "", paymentId, paymentChannel); if (updatePaymentStatus &gt; 0) &#123; basicNack(message, channel); return; &#125; // 继续重试 &#125; catch (Exception e) &#123; e.printStackTrace(); basicNack(message, channel); &#125; &#125; private void basicNack(Message message, Channel channel) throws IOException &#123; channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); &#125;&#125;]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇(五):ConcurrentLinkedDeque]]></title>
    <url>%2F2020%2F05%2F06%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%BA%94-ConcurrentLinkedDeque%2F</url>
    <content type="text"><![CDATA[JUC源码分析-集合篇（五）：ConcurrentLinkedDeque ConcurrentLinkedDeque 是双向链表结构的无界并发队列。从JDK 7开始加入到J.U.C的行列中。使用CAS实现并发安全，与 ConcurrentLinkedQueue 的区别是该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)。适合“多生产，多消费”的场景。内存一致性遵循对 ConcurrentLinkedDeque 的插入操作先行发生于(happen-before)访问或移除操作。相较于 ConcurrentLinkedQueue，ConcurrentLinkedDeque 由于是双端队列，所以在操作和概念上会更加复杂，来一起看下。 概述ConcurrentLinkedDeque（后面称CLD） 的实现方式继承了 ConcurrentLinkedQueue 和 LinkedTransferQueue的思想，在非阻塞算法的实现方面与 ConcurrentLinkedQueue 基本一致。关于 ConcurrentLinkedQueue，请参考笔者的上一篇文章：JUC源码分析-集合篇（三）：ConcurrentLinkedQueue。 数据结构 ConcurrentLinkedDeque 继承关系 重要属性： 12345678//头节点private transient volatile Node&lt;E&gt; head;//尾节点private transient volatile Node&lt;E&gt; tail;//终止节点private static final Node&lt;Object&gt; PREV_TERMINATOR, NEXT_TERMINATOR;//移除节点时更新链表属性的阀值private static final int HOPS = 2; 和ConcurrentLinkedQueue一样，CLD 内部也只维护了head和tail属性，对 head/tail 节点也使用了“不变性”和“可变性”约束，不过跟 ConcurrentLinkedQueue 有些许差异，我们来看一下： head/tail 的不变性： 第一个节点总是能以O(1)的时间复杂度从 head 通过 prev 链接到达； 最后一个节点总是能以O(1)的时间复杂度从 tail 通过 next 链接到达； 所有live节点（item不为null的节点），都能从第一个节点通过调用 succ() 方法遍历可达； 所有live节点（item不为null的节点），都能从最后一个节点通过调用 pred() 方法遍历可达； head/tail 不能为 null； head 节点的 next 域不能引用到自身； head/tail 不会是GC-unlinked节点（但它可能是unlink节点）。 head/tail的可变性： head/tail 节点的 item 域可能为 null，也可能不为 null； head/tail 节点可能从first/last/tail/head 节点访问时不可达； tail 节点的 next 域可以引用到自身。 注：CLD中也对 head/tail 的更新也使用了“松弛阀值”的概念（在 ConcurrentLinkedQueue 一篇中已经分析），除此之外，CLD设定了一个“跳跃阀值”-HOPS（指在查找活动节点时跳过的已删除节点数），在执行出队操作时，跳跃节点数大于2或者操作的节点不是 first/last 节点时才会更新链表（后面源码中详细分析）。 除此之外，再来看看CLD中另外两个属性： PREV_TERMINATOR：prev的终止节点，next指向自身，即PREV_TERMINATOR.next = PREV_TERMINATOR。在 first 节点出列后，会把first.next指向自身(first.next=first)，然后把prev设为PREV_TERMINATOR。 NEXT_TERMINATOR：next的终止节点，prev指向自身，即NEXT_TERMINATOR.pre = NEXT_TERMINATOR。在 last 节点出列后，会把last.prev指向自身(last.prev=last)，然后把next设为NEXT_TERMINATOR。 源码解析在开始源码分析之前，我们先来看一下CLD中对Node的定义： live node：节点的 item!=null 被称为live节点。当节点的 item 被 CAS 改为 null，逻辑上来讲这个节点已经从链表中移除；一个新的元素通过 CAS 添加到一个包含空 prev 或空 next 的 first 或 last 节点，这个元素的节点在这时是 live节点。 first node &amp; last node：首节点(first node)总会有一个空的 prev 引用，终止任何从 live 节点开始的 prev 引用链；同样的最后一个节点(last node)是 next 的终止节点。first/last 节点的 item 可以为 null。并且 first 和 last 节点总是相互可达的。 active node：live节点、first/last 节点也被称为活跃节点(active node)，活跃节点一定是被链接的，如果p节点为active节点，则：p.item != null || (p.prev == null &amp;&amp; p.next != p) || (p.next == null &amp;&amp; p.prev != p) self-node：自链接节点，prev 或 next 指向自身的节点，自链接节点用在解除链接操作中，并且它们都不是active node。 head/tail节点：head/tail 也可能不是 first/last 节点。从 head 节点通过 prev 引用总是可以找到 first 节点，从 tail 节点通过 next 引用总是可以找到 last 节点。允许 head 和 tail 引用已删除的节点，这些节点没有链接，因此可能无法从 live 节点访问到。 节点删除时经历三个阶段：逻辑删除(logical deletion)，未链接( unlinking)，和gc未链接( gc-unlinking)： logical deletion：通过 CAS 修改节点 item 为 null 来完成，表示当前节点可以被解除链接(unlinking)。 unlinking： 这种状态下的节点与其他 active 节点有链接，但是其他 active 节点与之都没有链接，也就是说从这个状态下的节点可以达到 active 节点，但是从 active 节点不可达到这种状态的节点。在任何时候，从 first 通过 next 找到的 live 节点和从 last 通过 prev 找到的节点总是相等的。但是，在节点被逻辑删除时上述结论不成立，这些被逻辑删除的节点也可能只从一端是可达的。 gc-unlinking： GC未链接使已删除节点不可达到 active 节点，使GC更容易回收被删除的节点。通过让节点自链接或链接到终止节点（PREV_TERMINATOR 或 NEXT_TERMINATOR）来实现。 gc-unlinking 节点从 head/tail 访问不可达。这一步是为了使数据结构保持GC健壮性(gc-robust)，防止保守式GC（conservative GC，目前已经很少使用）对这些边界空间的使用。对保守式GC来说，使数据结构保持GC健壮性会消除内存无限滞留的问题，同时也提高了分代收机器的性能。 如果同学们对上述理论还是一头雾水，那么从源码解析中我们就可以直观的看到它们的作用。OK！准备工作已经做完，下面我们正式开始源码解析。 添加（入列）CLD的添加方法包括：offer(E)、add(E)、push(E)、addFirst(E)、addLast(E)、offerFirst(E)、offerLast(E)，所有这些操作都是通过linkFirst(E)或linkLast(E)来实现的。 linkFirst(E) / linkLast(E)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Links e as first element. */private void linkFirst(E e) &#123; checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); restartFromHead: for (;;) //从head节点往前寻找first节点 for (Node&lt;E&gt; h = head, p = h, q;;) &#123; if ((q = p.prev) != null &amp;&amp; (q = (p = q).prev) != null) // Check for head updates every other hop. // If p == q, we are sure to follow head instead. //如果head被修改，返回head重新查找 p = (h != (h = head)) ? h : q; else if (p.next == p) // 自链接节点，重新查找 continue restartFromHead; else &#123; // p is first node newNode.lazySetNext(p); // CAS piggyback if (p.casPrev(null, newNode)) &#123; // Successful CAS is the linearization point // for e to become an element of this deque, // and for newNode to become "live". if (p != h) // hop two nodes at a time 跳两个节点时才修改head casHead(h, newNode); // Failure is OK. return; &#125; // Lost CAS race to another thread; re-read prev &#125; &#125;&#125;/** * Links e as last element. */private void linkLast(E e) &#123; checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); restartFromTail: for (;;) //从tail节点往后寻找last节点 for (Node&lt;E&gt; t = tail, p = t, q;;) &#123; if ((q = p.next) != null &amp;&amp; (q = (p = q).next) != null) // Check for tail updates every other hop. // If p == q, we are sure to follow tail instead. //如果tail被修改，返回tail重新查找 p = (t != (t = tail)) ? t : q; else if (p.prev == p) // 自链接节点，重新查找 continue restartFromTail; else &#123; // p is last node newNode.lazySetPrev(p); // CAS piggyback if (p.casNext(null, newNode)) &#123; // Successful CAS is the linearization point // for e to become an element of this deque, // and for newNode to become "live". if (p != t) // hop two nodes at a time 跳两个节点时才修改tail casTail(t, newNode); // Failure is OK. return; &#125; // Lost CAS race to another thread; re-read next &#125; &#125;&#125; 说明：linkFirst是插入新节点到队列头的主函数，执行流程如下：首先从 head 节点开始向前循环找到 first 节点(p.prev==null&amp;&amp;p.next!=p)；然后通过lazySetNext设置新节点的 next 节点为 first；然后 CAS 修改 first 的 prev 为新节点。注意这里 CAS 指令成功后会判断 first 节点是否已经跳了两个节点，只有在跳了两个节点才会 CAS 更新 head，这也是为了节省 CAS 指令执行开销。linkLast是插入新节点到队列尾，执行流程与linkFirst一致，不多赘述，具体见源码。注：lazySetNext通过 Unsafe 类的putOrderedObject实现，有关这个方法，请参考笔者的另一篇文章：JUC源码分析—CAS和Unsafe。 获取(出列)CLD的获取方法分两种：获取节点：peek、peekFirst 、peekLast、getFirst、getLast，都是通过peekFirst 、peekLast实现。获取并移除节点： poll、pop、remove、pollFirst、pollLast、removeFirst、removeLast，都是通过pollFirst、pollLast实现。 pollFirst、pollLast包括了peekFirst 、peekLast的实现，都是找到并返回 first/last 节点，不同的是，pollFirst、pollLast比peekFirst 、peekLast多了 unlink 这一步。所以这里我们只对pollFirst和pollLast两个方法进行解析。首先来看一下pollFirst() ： pollFirst()1234567891011/**获取并移除队列首节点*/public E pollFirst() &#123; for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) &#123; E item = p.item; if (item != null &amp;&amp; p.casItem(item, null)) &#123; unlink(p); return item; &#125; &#125; return null;&#125; 说明： pollFirst()用于找到链表中首个 item 不为 null 的节点（注意并不是first节点，因为first节点的item可以为null），并返回节点的item。涉及的内部方法较多，不过都很简单，我们通过穿插代码方式分析： 首先通过first()方法找到 first 节点，first 节点必须为 active 节点(p.prev==null&amp;&amp;p.next!=p)。first()源码如下： 123456789101112131415161718192021Node&lt;E&gt; first() &#123; restartFromHead: for (;;) //从head开始往前找 for (Node&lt;E&gt; h = head, p = h, q;;) &#123; if ((q = p.prev) != null &amp;&amp; (q = (p = q).prev) != null) // Check for head updates every other hop. // If p == q, we are sure to follow head instead. //如果head被修改则返回新的head重新查找，否则继续向前(prev)查找 p = (h != (h = head)) ? h : q; else if (p == h // It is possible that p is PREV_TERMINATOR, // but if so, the CAS is guaranteed to fail. //找到的节点不是head节点，CAS修改head || casHead(h, p)) return p; else continue restartFromHead; &#125;&#125; 如果first.item==null（这里是允许的，具体见上面我们对 first/last 节点的介绍），则继续调用succ方法寻找后继节点。succ源码如下： 123456/**返回指定节点的的后继节点，如果指定节点的next指向自己，返回first节点*/final Node&lt;E&gt; succ(Node&lt;E&gt; p) &#123; // TODO: should we skip deleted nodes here? Node&lt;E&gt; q = p.next; return (p == q) ? first() : q;&#125; CAS 修改节点的 item 为 null（即 “逻辑删除-logical deletion”），然后调用unlink(p)方法解除节点链接，最后返回 item。unlink(p)是移除节点的主方法，逻辑较为复杂，后面我们单独分析。 unlink(Node x)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Unlinks non-null node x. */void unlink(Node&lt;E&gt; x) &#123; // assert x != null; // assert x.item == null; // assert x != PREV_TERMINATOR; // assert x != NEXT_TERMINATOR; final Node&lt;E&gt; prev = x.prev; final Node&lt;E&gt; next = x.next; if (prev == null) &#123;//操作节点为first节点 unlinkFirst(x, next); &#125; else if (next == null) &#123;//操作节点为last节点 unlinkLast(x, prev); &#125; else &#123;// common case Node&lt;E&gt; activePred, activeSucc; boolean isFirst, isLast; int hops = 1; // Find active predecessor //从被操作节点的prev节点开始找到前继活动节点 for (Node&lt;E&gt; p = prev; ; ++hops) &#123; if (p.item != null) &#123; activePred = p; isFirst = false; break; &#125; Node&lt;E&gt; q = p.prev; if (q == null) &#123; if (p.next == p) return;//自链接节点 activePred = p; isFirst = true; break; &#125; else if (p == q)//自链接节点 return; else p = q; &#125; // Find active successor for (Node&lt;E&gt; p = next; ; ++hops) &#123; if (p.item != null) &#123; activeSucc = p; isLast = false; break; &#125; Node&lt;E&gt; q = p.next; if (q == null) &#123; if (p.prev == p) return; activeSucc = p; isLast = true; break; &#125; else if (p == q)//自链接节点 return; else p = q; &#125; // TODO: better HOP heuristics //无节点跳跃并且操作节点有first或last节点时不更新链表 if (hops &lt; HOPS // always squeeze out interior deleted nodes &amp;&amp; (isFirst | isLast)) return; // Squeeze out deleted nodes between activePred and // activeSucc, including x. //连接两个活动节点 skipDeletedSuccessors(activePred); skipDeletedPredecessors(activeSucc); // Try to gc-unlink, if possible if ((isFirst | isLast) &amp;&amp; // Recheck expected state of predecessor and successor (activePred.next == activeSucc) &amp;&amp; (activeSucc.prev == activePred) &amp;&amp; (isFirst ? activePred.prev == null : activePred.item != null) &amp;&amp; (isLast ? activeSucc.next == null : activeSucc.item != null)) &#123; updateHead(); // Ensure x is not reachable from head updateTail(); // Ensure x is not reachable from tail // Finally, actually gc-unlink x.lazySetPrev(isFirst ? prevTerminator() : x); x.lazySetNext(isLast ? nextTerminator() : x); &#125; &#125;&#125; 说明：unlink(Node x)方法用于解除已弹出节点的链接，分三种情况： 首先说一下通常的情况（源码中标注 common case 处），这种情况下，入列和出列非同端操作，即操作节点 x 非 first 和 last 节点， 就执行如下流程： 首先找到给定节点 x 的活跃（active）前继和后继节点。然后修整它们之间的链接，让它们指向对方（通过skipDeletedSuccessors和skipDeletedPredecessors方法），留下一个从活跃(active)节点不可达的 x 节点（即“unlinking”）。 如果成功执行，或者 x 节点没有 live 的前继/后继节点，再尝试 gc 解除链接(gc-unlink)，在设置 x 节点的 prev/next 指向它们自己或 TERMINATOR 之前（即“gc-unlink”），需要检查 x 的前继和后继节点的状态未被改变，并保证 x 节点从 head/tail 不可达（通过updateHead()和updateTail()方法）。 如果操作节点为 first 节点（入列和出列都发生在 first 端），则调用unlinkFirst解除已删除节点的链接，并链接 first 节点到下一个 active 节点（注意，在执行完此方法之后 first 节点是没有改变的）。unlinkFirst源码如下： 123456789101112131415161718192021222324252627282930313233343536373839/** * Unlinks non-null first node. */private void unlinkFirst(Node&lt;E&gt; first, Node&lt;E&gt; next) &#123; // assert first != null; // assert next != null; // assert first.item == null; //从next节点开始向后寻找有效节点，o：已删除节点(item为null) for (Node&lt;E&gt; o = null, p = next, q;;) &#123; if (p.item != null || (q = p.next) == null) &#123; //跳过已删除节点，CAS替换first的next节点为一个active节点p if (o != null &amp;&amp; p.prev != p &amp;&amp; first.casNext(next, p)) &#123; //更新p的prev节点 skipDeletedPredecessors(p); if (first.prev == null &amp;&amp; (p.next == null || p.item != null) &amp;&amp; p.prev == first) &#123; //更新head节点，确保已删除节点o从head不可达(unlinking) updateHead(); // Ensure o is not reachable from head //更新tail节点，确保已删除节点o从tail不可达(unlinking) updateTail(); // Ensure o is not reachable from tail // Finally, actually gc-unlink //使unlinking节点next指向自身 o.lazySetNext(o); //设置移除节点的prev为PREV_TERMINATOR o.lazySetPrev(prevTerminator()); &#125; &#125; return; &#125; else if (p == q)//自链接节点 return; else &#123; o = p; p = q; &#125; &#125;&#125; 如果操作节点为 last 节点（入列和出列都发生在 last 端），则调用unlinkLast解除已删除节点的链接，并链接 last 节点到上一个 active 节点。unlinkLast与unlinkFirst方法执行流程一致，只是操作的是 last 端，在此不多赘述。 小结本章与 ConcurrentLinkedQueue 一篇中的非阻塞算法基本一致，只是为双端操作定义了几个可供操作的节点类型。本章重点：理解 ConcurrentLinkedDeque 的非阻塞算法及节点删除的三个状态]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>ConcurrentLinkedDeque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇（四）：ConcurrentLinkedQueue]]></title>
    <url>%2F2020%2F05%2F04%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AConcurrentLinkedQueue%2F</url>
    <content type="text"><![CDATA[JUC源码分析-集合篇（四）：ConcurrentLinkedQueue Queue 是“生产者-消费者”模型的重要实现，在实际应用中，众多消息系统（例如RocketMQ、ActiveMQ等）都是基于Queue的思想来实现。从本篇开始，我们会对JUC中所有的Queue进行逐一讲解。 概述 ConcurrentLinkedQueue 是单向链表结构的无界并发队列。从JDK1.7开始加入到J.U.C的行列中。使用CAS实现并发安全，元素操作按照 FIFO (first-in-first-out 先入先出) 的顺序。适合“单生产，多消费”的场景。内存一致性遵循对ConcurrentLinkedQueue的插入操作先行发生于(happen-before)访问或移除操作。 ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面四点（后面源码解析中都会有详细说明）： 使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。 head/tail 节点都允许滞后，也就是说它们并非总是指向队列的头/尾节点，这是因为并不是每次操作队列都更新 head/tail，和 LinkedTransferQueue 一样，使用了一个“松弛阀值（2）”， 当前指针距离 head/tail 节点大于2时才会更新 head/tail，这也是一种优化方式，减少了CAS指令的执行次数。 由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 对节点使用了“不变性”和“可变性”来约束非阻塞算法的正确性（后面会详细说明）。 使用“自链接”方式管理出队节点，这样一个自链接节点意味着需要从head向后推进。 数据结构 ConcurrentLinkedQueue 继承关系 ConcurrentLinkedQueue 继承了AbstractQueue，使用Node存储数据，Node是一个单向链表，内部存储元素和下一个节点的引用。ConcurrentLinkedQueue 内部只有两个属性：head 和 tail： 12private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail; 首先来看一下上面提到的节点的“不变性”和“可变性”，在 ConcurrentLinkedQueue 中，通过这些性质来约束非阻塞算法的正确性。 基本不变性： 当入队插入新节点之后，队列中有一个 next 域为 null （最后一个）的节点。 从 head 开始遍历队列，可以访问所有 item 域不为 null 的节点。 head / tail 的不变性 所有live节点（指未删除节点），都能从 head 通过调用 succ() 方法遍历可达 通过 tail 调用 succ() 方法，最后节点总是可达的。 head 节点的 next 域不能引用到自身。 head / tail 不能为 null。 head / tail 的可变性： head / tail 节点的 item 域可能为 null，也可能不为 null。 允许 tail 滞后（lag behind）于 head。也就是说，从 head 开始遍历队列，不一定能到达 tail。 tail 节点的 next 域可以引用到自身。 源码解析offer(E e)123456789101112131415161718192021222324252627282930/**添加节点到队列尾*/public boolean offer(E e) &#123; checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); //自旋,t:尾节点 for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; if (q == null) &#123;//p为尾节点 // p is last node if (p.casNext(null, newNode)) &#123;//cas替换p的next节点为新节点 // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become "live". if (p != t) // 跳两个节点以上时才修改tail casTail(t, newNode); // cas替换尾节点 return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) // p节点指向自身，说明p是一个自链节点，此时需要重新获取tail节点， // 如果tail节点被其他线程修改，此时需要从head开始向后遍历，因为 // 从head可以到达所有的live节点。 p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. //继续向后查找，如果tail节点变化，重新获取tail p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; 说明： ConcurrentLinkedQueue 提供了两个添加元素的方法（因为实现了 Queue 和 Collection 接口）：一个是 Queue 的offer方法， 另外一个是 Collection 的add方法，add也是调用offer来实现。新增元素时，把元素放到链表尾部，由于队列是无界的，所以插入时不会返回false或者抛出IllegalStateException。函数逻辑很简单：从tail节点向后自旋查找 next 为 null 的节点，也就是最后一个节点（因为 tail 节点并不是每次都更新，所以我们取到的 tail 节点有可能并不是最后一个节点），然后CAS插入新增节点。上面我们提到过：并不是每次操作都会更新 head/tail 节点，而是使用了一个“松弛阀值”，这个“松弛阀值”就体现在上面源码中if (p != t)这一行，p初始是等于tail的，如果向后查找了一次以上才找到最后一个节点，再加上新增的节点，说明tail已经跳跃了两个（或以上）节点，此时才会CAS更新tail，这里也算是一种编程技巧。 poll()1234567891011121314151617181920212223242526public E poll() &#123; restartFromHead: for (;;) &#123; //从head节点向后查找第一个live节点 for (Node&lt;E&gt; h = head, p = h, q;;) &#123; E item = p.item; if (item != null &amp;&amp; p.casItem(item, null)) &#123;//找到第一个节点，cas修改节点item为null // Successful CAS is the linearization point // for item to be removed from this queue. if (p != h) // 跳两个节点以上时才修改head //cas修改head节点 updateHead(h, ((q = p.next) != null) ? q : p); return item; &#125; else if ((q = p.next) == null) &#123;//队列已空，返回null updateHead(h, p);//cas修改head节点为p return null; &#125; else if (p == q)//p为自链接节点，重新获取head循环 continue restartFromHead;//跳转到restartFromHead重新循环 else p = q;//向后查找 &#125; &#125;&#125; 说明： ConcurrentLinkedQueue 提供了两个获取节点的方法：poll()和peek()，两个方法都返回头节点元素，不同之处在于poll()会移除头节点，而peek()则不会移除。可以说peek()是poll()的一部分，所以这里我们只介绍poll()。函数执行流程如下：从head节点开始向后查找第一个live（item不为空）节点，CAS修改节点的item为null，并返回节点的item。和offer(E e)一样，poll()也使用了“松弛阀值”，跳两个或以上节点时才会更新head。 小结本章重点：理解 ConcurrentLinkedQueue 的非阻塞算法。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇（三）：ConcurrentSkipListMap和ConcurrentSkipListSet]]></title>
    <url>%2F2020%2F05%2F03%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AConcurrentSkipListMap%E5%92%8CConcurrentSkipListSet%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySet]]></title>
    <url>%2F2020%2F05%2F03%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ACopyOnWriteArrayList%E5%92%8CCopyOnWriteArraySet%2F</url>
    <content type="text"><![CDATA[JUC源码分析-集合篇（二）：CopyOnWriteArrayList和CopyOnWriteArraySetCopyOnWriteArrayList 是一个线程安全的 ArrayList，通过内部的 volatile 数组和显式锁 ReentrantLock 来实现线程安全。而 CopyOnWriteArraySet 是线程安全的 Set，它是由 CopyOnWriteArrayList 实现，内部持有一个 CopyOnWriteArrayList 引用，所有的操作都是由 CopyOnWriteArrayList 来实现的，区别就是 CopyOnWriteArraySet 是无序的，并且不允许存放重复值。由于是一个Set，所以也不支持随机索引元素。本章我们重点介绍 CopyOnWriteArrayList。 和 ArrayList 或 Set 相比，CopyOnWriteArrayList / CopyOnWriteArraySet 拥有以下特性： 适合元素比较少，并且读取操作高于更新(add/set/remove)操作的场景 由于每次更新需要复制内部数组，所以更新操作开销比较大 内部的迭代器 iterator 使用了“快照”技术，存储了内部数组快照， 所以它的 iterator 不支持remove、set、add操作，但是通过迭代器进行并发读取时效率很高。 源码解析核心参数12345//锁final transient ReentrantLock lock = new ReentrantLock();//用于存储元素的内部数组private transient volatile Object[] array; CopyOnWriteArrayList 实现非常简单。内部使用了一个 volatile 数组(array)来存储数据，保证了多线程环境下的可见性。在更新数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给 array。正由于这个原因，涉及到数据更新的操作效率很低。 由于 CopyOnWriteArrayList 源码比较简单，内部都是对数组的操作，所以咱们这里以add方法为例，其他方法就不一一分析了。 add(int index, E element)1234567891011121314151617181920212223242526272829303132public void add(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+len); Object[] newElements; //计算偏移量 int numMoved = len - index; if (numMoved == 0) //作为add(E)处理 newElements = Arrays.copyOf(elements, len + 1); else &#123; newElements = new Object[len + 1]; //调用native方法根据index拷贝原数组的前半段 System.arraycopy(elements, 0, newElements, 0, index); //拷贝后半段 System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; newElements[index] = element; setArray(newElements); &#125; finally &#123; lock.unlock(); &#125;&#125;//System中arrayCopy的实现public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 说明： 还是那句话，非常简单，通过add()方法就可以看出整个 CopyOnWriteArrayList 的实现就是操作内部数组。首先通过lock加锁，新建一个原数组长度加1的新数组，将原数组（array）的数据拷贝到新数组中，如果给定索引（index）不是原数组最后一个索引，就分两部分拷贝， 然后将给定元素放到新数组中给定索引处；最后，将新数组赋值给array。 小结在整个java.util.concurrent框架里，这两兄弟可以说是最简单的两个类了。操作直观，没有复杂的运算逻辑。本章重点：CopyOnWriteArrayList 是通过拷贝数组来实现内部元素操作的。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F05%2F02%2Ftest%2F</url>
    <content type="text"><![CDATA[深入理解happens-before规则为什么会有happens-before 规则？因为jvm会对代码进行编译优化，指令会出现重排序的情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。 1234567891011121314public class VolatileExample &#123; int x = 0 ; volatile boolean v = false; public void writer()&#123; x = 42; v = true; &#125; public void reader()&#123; if (v == true)&#123; // 这里x会是多少呢 &#125; &#125;&#125; 抛出问题：假设有两个线程A和B，A执行了writer方法，B执行reader方法，那么B线程中独到的变量x的值会是多少呢？ jdk1.5之前，线程B读到的变量x的值可能是0，也可能是42，jdk1.5之后，变量x的值就是42了。原因是jdk1.5中，对volatile的语义进行了增强。来看一下happens-before规则在这段代码中的体现。 1. 规则一：程序的顺序性规则 一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。 对于这一点，可能会有疑问。顺序性是指，我们可以按照顺序推演程序的执行结果，但是编译器未必一定会按照这个顺序编译，但是编译器保证结果一定==顺序推演的结果。 2. 规则二：volatile规则 对一个volatile变量的写操作，happens-before后续对这个变量的读操作。 3. 规则三：传递性规则 如果A happens-before B，B happens-before C，那么A happens-before C。 jdk1.5的增强就体现在这里。回到上面例子中，线程A中，根据规则一，对变量x的写操作是happens-before对变量v的写操作的，根据规则二，对变量v的写操作是happens-before对变量v的读操作的，最后根据规则三，也就是说，线程A对变量x的写操作，一定happens-before线程B对v的读操作，那么线程B在注释处读到的变量x的值，一定是42. 4.规则四：管程中的锁规则 对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。 这一点不难理解。 5.规则五：线程start()规则 主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。也就是start() happens before 线程B中的操作。 6.规则六：线程join()规则 主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇(九):LinkedBlockingQueue]]></title>
    <url>%2F2020%2F04%2F26%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%B9%9D-LinkedBlockingQueue%2F</url>
    <content type="text"><![CDATA[JUC源码分析-集合篇(九):LinkedBlockingQueue LinkedBlockingQueue 是单向链表结构的自定义容量的阻塞队列，元素操作按照FIFO(first-in-first-out 先入先出)的顺序，使用显式锁 ReentrantLock 和 Condition 来保证线程安全。链表结构的队列通常比基于数组的队列（ArrayBlockingQueue）有更高的吞吐量，但是在并发环境下性能却不如数组队列。因为比较简单，本章本来是不在笔者的写作范围内的，但是在后面的线程池源码中用到了LinkedBlockingQueue，我们我们就来简单看一下，加深一下印象。 本章应该是队列篇的终章了，还有LinkedBlockingDeque、ArrayBlockingQueue这些比较简单的队列就不再讲解了，后面我们会开始线程池相关源码分析。 概述 LinkedBlockingQueue（后称LBQ）队列容量可通过参数来自定义，并且内部是不会自动扩容的。如果未指定容量，将取最大容量Integer.MAX_VALUE。 如果你理解了前几篇我们所讲的队列，那么你会发现 LBQ 非常容易理解，内部没有太多复杂的算法，数据结构也是使用了简单的链表结构。 数据结构 LinkedBlockingQueue 继承关系 标准的队列继承关系，不多赘述。 重要属性1234567891011121314151617181920212223//容量private final int capacity;//元素个数private final AtomicInteger count = new AtomicInteger();//链表头transient Node&lt;E&gt; head;//链表尾private transient Node&lt;E&gt; last;//出列锁private final ReentrantLock takeLock = new ReentrantLock();//等待获取(出队)条件private final Condition notEmpty = takeLock.newCondition();//入列锁private final ReentrantLock putLock = new ReentrantLock();//等待插入(入列)条件private final Condition notFull = putLock.newCondition(); LBQ 在实现多线程对竞争资源的互斥访问时，对于入列和出列操作分别使用了不同的锁。对于入列操作，通过putLock进行同步；对于出列操作，通过takeLock进行同步。此外，插入锁putLock和出列条件notFull相关联，出列锁takeLock和出列条件notEmpty相关联。通过notFull和notEmpty更细腻的控制锁。 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒notEmpty上的等待线程。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒notFull上的等待线程。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。 源码解析put(E e)LBQ 的添加元素的方法有offer()、put()，put是在队列已满的情况下等待，而offer则直接返回结果，它们内部操作都一致。所这里我们只对put进行解析 123456789101112131415161718192021222324//尾部插入节点,队列满时会一直等待可用,响应中断public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock;//获取入列锁 final AtomicInteger count = this.count;//获取元素数 putLock.lockInterruptibly();//响应中断式加锁 try &#123; while (count.get() == capacity) &#123; notFull.await();//队列已满，等待 &#125; enqueue(node);//节点添加到队列尾 c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();&#125; 说明：看源码吧。 poll()LBQ 的获取元素的方法有poll()、take()、peek()，take在队列为空的情况下会一直等待，poll不等待直接返回结果，peek是获取但不移除头结点元素，内部操作都差不多。这里我们只对take进行解析： 12345678910111213141516171819202122/**获取并消除头节点,会一直等待队列可用,响应中断*/public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock;//获取出列锁 takeLock.lockInterruptibly();//响应中断式加锁 try &#123; while (count.get() == 0) &#123; notEmpty.await();//队列为空，等待 &#125; x = dequeue();//首节点出列 c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125; 小结本章比较简单，只是为了加深同学们的印象，为之后线程池源码解析做准备，随便看看就行了。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇(二):CopyOnWriteArrayList和CopyOnWriteArraySet]]></title>
    <url>%2F2020%2F04%2F26%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%BA%8C-CopyOnWriteArrayList%E5%92%8CCopyOnWriteArraySet%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇(一):ConcurrentHashMap]]></title>
    <url>%2F2020%2F04%2F26%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E4%B8%80-ConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap 是一个支持并发检索和并发更新的线程安全的HashMap（但不允许空key或value）。不管是在实际工作或者是面试中，ConcurrentHashMap 都是在整个JUC集合框架里出现频率最高的一个类，所以，对ConcurrentHashMap有一个深入的认识对我们自身还是非常重要的。本章我们来从源码层面详细分析 ConcurrentHashMap 的实现（基于JDK 8），希望对大家有所帮助。 1. 概述 ConcurrentHashMap 在JDK 7之前是通过Lock和Segment（分段锁）实现并发安全，JDK 8之后改为CAS+synchronized来保证并发安全（为了序列化兼容，JDK 8的代码中还是保留了Segment的部分代码）。由于笔者没有过多研究过JDK 7的源码，所以我们后面的分析主要针对JDK 8。 首先来看一下ConcurrentHashMap、HashMap和HashTable的区别： HashMap 是非线程安全的哈希表，常用于单线程程序中。 Hashtable 是线程安全的哈希表，由于是通过内置锁 synchronized 来保证线程安全，在资源争用比较高的环境下，Hashtable 的效率比较低。 ConcurrentHashMap 是一个支持并发操作的线程安全的HashMap，但是他不允许存储空key或value。使用CAS+synchronized来保证并发安全，在并发访问时不需要阻塞线程，所以效率是比Hashtable 要高的。 2. 数据结构 ConcurrentHashMap数据结构 ConcurrentHashMap 是通过Node来存储K-V的，从上图可以看出，它的内部有很多Node节点（在内部封装了一个Node数组-table），不同的节点有不同的作用。下面我们来详细看一下这几个Node节点类： Node Node： 保存k-v、k的hash值和链表的 next 节点引用，其中 V 和 next 用volatile修饰，保证多线程环境下的可见性。 TreeNode： 红黑树节点类,当链表长度&gt;=8且数组长度&gt;=64时，Node 会转为 TreeNode，但它不是直接转为红黑树，而是把这些 TreeNode 节点放入TreeBin 对象中，由 TreeBin 完成红黑树的封装。 TreeBin： 封装了 TreeNode，红黑树的根节点，也就是说在 ConcurrentHashMap 中红黑树存储的是 TreeBin 对象。 ForwardingNode： 在节点转移时用于连接两个 table（table和nextTable）的节点类。包含一个 nextTable 指针，用于指向下一个table。而且这个节点的 k-v 和 next 指针全部为 null，hash 值为-1。只有在扩容时发挥作用，作为一个占位节点放在 table 中表示当前节点已经被移动。 ReservationNode： 在computeIfAbsent和compute方法计算时当做一个占位节点，表示当前节点已经被占用，在compute或computeIfAbsent的 function 计算完成后插入元素。hash值为-3。 2.1 核心参数12345678910111213141516171819202122232425262728293031323334353637383940//最大容量private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//初始容量private static final int DEFAULT_CAPACITY = 16;//数组最大容量static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//默认并发度，兼容1.7及之前版本private static final int DEFAULT_CONCURRENCY_LEVEL = 16;//加载/扩容因子，实际使用n - (n &gt;&gt;&gt; 2)private static final float LOAD_FACTOR = 0.75f;//链表转红黑树的节点数阀值static final int TREEIFY_THRESHOLD = 8;//红黑树转链表的节点数阀值static final int UNTREEIFY_THRESHOLD = 6;//当数组长度还未超过64,优先数组的扩容,否则将链表转为红黑树static final int MIN_TREEIFY_CAPACITY = 64;//扩容时任务的最小转移节点数private static final int MIN_TRANSFER_STRIDE = 16;//sizeCtl中记录stamp的位数private static int RESIZE_STAMP_BITS = 16;//帮助扩容的最大线程数private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;//size在sizeCtl中的偏移量private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;//存放Node元素的数组,在第一次插入数据时初始化transient volatile Node&lt;K,V&gt;[] table;//一个过渡的table表,只有在扩容的时候才会使用private transient volatile Node&lt;K,V&gt;[] nextTable;//基础计数器值(size = baseCount + CounterCell[i].value)private transient volatile long baseCount;//控制table初始化和扩容操作private transient volatile int sizeCtl;//节点转移时下一个需要转移的table索引private transient volatile int transferIndex;//元素变化时用于控制自旋private transient volatile int cellsBusy;// 保存table中的每个节点的元素个数 2的幂次方// size = baseCount + CounterCell[i].valueprivate transient volatile CounterCell[] counterCells; table：Node数组，在第一次插入元素的时候初始化，默认初始大小为16，用来存储Node节点数据，扩容时大小总是2的幂次方。 nextTable：默认为null，扩容时生成的新的数组，其大小为原数组的两倍。 sizeCtl ：默认为0，用来控制table的初始化和扩容操作，在不同的情况下有不同的涵义： -1 代表table正在初始化 -N 表示有N-1个线程正在进行扩容操作 初始化数组或扩容完成后,将sizeCtl的值设为0.75*n 在扩容操作在进行节点转移前，sizeCtl改为(hash &lt;&lt; RESIZE_STAMP_SHIFT) + 2，这个值为负数，并且每有一个线程参与扩容操作sizeCtl就加1 transferIndex：扩容时用到，初始时为table.length，表示从索引 0 到transferIndex的节点还未转移 。 counterCells： ConcurrentHashMap的特定计数器，实现方法跟LongAdder类似。这个计数器的机制避免了在更新时的资源争用，但是如果并发读取太频繁会导致缓存超负荷，为了避免读取太频繁，只有在添加了两个以上节点时才可以尝试扩容操作。在统一hash分配的前提下，发生这种情况的概率在13%左右，也就是说只有大约1/8的put操作才会检查扩容（并且在扩容后会更少）。 hash计算公式：hash = (key.hashCode ^ (key.hashCode &gt;&gt;&gt; 16)) &amp; HASH_BITS 索引计算公式：(table.length-1)&amp;hash 3. 源码解析3.1 put(K, V)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public V put(K key, V value) &#123; return putVal(key, value, false);&#125;/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); //计算hash值 int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123;//自旋 //f:索引节点; n:tab.length; i:新节点索引 (n - 1) &amp; hash; fh:f.hash Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //初始化 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;//索引i节点为空，直接插入 //cas插入节点,成功则跳出循环 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; //当前节点处于移动状态-其他线程正在进行节点转移操作 else if ((fh = f.hash) == MOVED) //帮助转移 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123;//check stable //f.hash&gt;=0,说明f是链表的头结点 if (fh &gt;= 0) &#123; binCount = 1;//记录链表节点数，用于后面是否转换为红黑树做判断 for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //key相同 修改 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; //到这里说明已经是链表尾，把当前值作为新的节点插入到队尾 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //红黑树节点操作 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; //更新新元素个数 addCount(1L, binCount); return null;&#125; 说明：在 ConcurrentHashMap 中，put 方法几乎涵盖了所有内部的函数操作。所以，我们将从put函数开始逐步向下分析。 首先说一下put的流程，后面再详细分析每一个流程的具体实现（阅读时请结合源码）： 计算当前key的hash值，根据hash值计算索引 i （i=(table.length - 1) &amp; hash）； 如果当前table为null，说明是第一次进行put操作，调用initTable()初始化table； 如果索引 i 位置的节点 f 为空，则直接把当前值作为新的节点直接插入到索引 i 位置； 如果节点 f 的hash为-1（f.hash == MOVED(-1)），说明当前节点处于移动状态（或者说是其他线程正在对 f 节点进行转移/扩容操作），此时调用helpTransfer(tab, f)帮助转移/扩容； 如果不属于上述条件，说明已经有元素存储到索引 i 处，此时需要对索引 i 处的节点 f 进行 put or update 操作，首先使用内置锁 synchronized 对节点 f 进行加锁： 如果f.hash&gt;=0，说明 i 位置是一个链表，并且节点 f 是这个链表的头节点，则对 f 节点进行遍历，此时分两种情况： –如果链表中某个节点e的hash与当前key的hash相同，则对这个节点e的value进行修改操作。 –如果遍历到链表尾都没有找到与当前key的hash相同的节点，则把当前K-V作为一个新的节点插入到这个链表尾部。 如果节点 f 是TreeBin节点(f instanceof TreeBin)，说明索引 i 位置的节点是一个红黑树，则调用putTreeVal方法找到一个已存在的节点进行修改，或者是把当前K-V放入一个新的节点（put or update）。 完成插入后，如果索引 i 处是一个链表，并且在插入新的节点后节点数&gt;8，则调用treeifyBin把链表转换为红黑树。 最后，调用addCount更新元素数量 3.1.1 initTable()12345678910111213141516171819202122232425/** * Initializes table, using the size recorded in sizeCtl. */private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; if ((sc = sizeCtl) &lt; 0)//其他线程正在进行初始化或转移操作，让出CPU执行时间片，继续自旋 Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;//CAS设置sizectl为-1 表示当前线程正在进行初始化 try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2);//0.75*n 设置扩容阈值 &#125; &#125; finally &#123; sizeCtl = sc;//初始化sizeCtl=0.75*n &#125; break; &#125; &#125; return tab;&#125; 说明：初始化操作，ConcurrentHashMap的初始化在第一次插入数据的时候(判断table是否为null)，注意初始化操作为单线程操作（如果有其他线程正在进行初始化，则调用Thread.yield()让出CPU时间片，自旋等待table初始完成）。 3.1.2 helpTransfer(Node&lt;K,V&gt;[], Node&lt;K,V&gt;)123456789101112131415161718192021//帮助其他线程进行转移操作final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; //计算操作栈校验码 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)//不需要帮助转移，跳出 break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;//CAS更新帮助转移的线程数 transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table;&#125; 说明： 如果索引到的节点的 hash 为-1，说明当前节点处于移动状态（或者说是其他线程正在对 f 节点进行转移操作。这里主要是靠 ForwardingNode 节点来检测，在transfer方法中，被转移后的节点会改为ForwardingNode，它是一个占位节点，并且hash=MOVED（-1），也就是说，我们可以通过判断hash是否为MOVED来确定当前节点的状态），此时调用helpTransfer(tab, f)帮助转移，主要操作就是更新帮助转移的线程数（sizeCtl+1），然后调用transfer方法进行转移操作，transfer后面我们会详细分析。 3.1.3 treeifyBin(Node&lt;K,V&gt;[] , index)1234567891011121314151617181920212223242526272829private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; //当数组长度还未超过64,优先数组的扩容,否则将链表转为红黑树 if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //两倍扩容 tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; if (tabAt(tab, index) == b) &#123;//check stable //hd：节点头 TreeNode&lt;K,V&gt; hd = null, tl = null; //遍历转换节点 for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; &#125; setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); &#125; &#125; &#125; &#125; &#125; 说明： 在put操作完成后，如果当前节点为一个链表，并且链表长度&gt;=TREEIFY_THRESHOLD(8)，此时就需要调用treeifyBin方法来把当前链表转为一个红黑树。treeifyBin主要进行两步操作： 如果当前table长度还未超过MIN_TREEIFY_CAPACITY(64)，则优先对数组进行扩容操作，容量为原来的2倍(n&lt;&lt;1)。 否则就对当前节点进行转换操作（注意这个操作是单线程完成的）。遍历链表节点，把Node转换为TreeNode，然后在通过TreeBin来构造红黑树（红黑树的构造这里就不在详细介绍了）。 3.1.4 tryPresize(int size)12345678910111213141516171819202122232425262728293031323334353637383940414243private final void tryPresize(int size) &#123; int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);//计算一个近似size的2的幂次方数 int sc; while ((sc = sizeCtl) &gt;= 0) &#123; Node&lt;K,V&gt;[] tab = table; int n; //未初始化 if (tab == null || (n = tab.length) == 0) &#123; n = (sc &gt; c) ? sc : c; if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if (table == tab) &#123; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; &#125; &#125; //已达到最大容量 else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) break; else if (tab == table) &#123; int rs = resizeStamp(n); //正在进行扩容操作 if (sc &lt; 0) &#123; Node&lt;K,V&gt;[] nt; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); &#125; &#125;&#125; 说明： 当table容量不足时，需要对其进行两倍扩容。tryPresize方法很简单，主要就是用来检查扩容前的必要条件（比如是否超过最大容量），真正的扩容其实也可以叫“节点转移”，主要是通过transfer方法完成。 3.1.5 transfer(Node&lt;K,V&gt; tab, Node&lt;K,V&gt; nextTab)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171//转移或复制节点到新的tableprivate final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; //转移幅度( tab.length/(NCPU*8) )，最小为16 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) &#123; // initiating try &#123; //根据当前数组长度,新建一个两倍长度的数组nextTab @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n;//初始为table的最后一个索引 &#125; int nextn = nextTab.length; //初始化ForwardingNode节点,持有nextTab的引用,在处理完每个节点之后当做占位节点，表示该槽位已经处理过了 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true;//节点是否已经处理 boolean finishing = false; // to ensure sweep before committing nextTab //自旋移动每个节点，从transferIndex开始移动stride个节点到新的table。 //i：当前处理的Node索引；bound：需要处理节点的索引边界 for (int i = 0, bound = 0;;) &#123; //f:当前处理i位置的node; fh:f.hash Node&lt;K,V&gt; f; int fh; //通过while循环获取本次需要移动的节点索引i while (advance) &#123; //nextIndex:下一个要处理的节点索引; nextBound:下一个需要处理的节点的索引边界 int nextIndex, nextBound; if (--i &gt;= bound || finishing)//通过--i控制下一个需要移动的节点 advance = false; //节点已全部转移 else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; //transferIndex（初值为最后一个节点的索引），表示从transferIndex开始后面所有的节点都已分配， //每次线程领取扩容任务后，需要更新transferIndex的值(transferIndex-stride)。 //CAS修改transferIndex，并更新索引边界 else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; if (finishing) &#123;//已完成转移，更新相关属性 nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);//1.5*n 扩容阈值设置为原来容量的1.5倍 依然相当于现在容量的0.75倍 return; &#125; //当前线程已经完成转移，但可能还有其他线程正在进行转移操作 //每个线程完成自己的扩容操作后就对sizeCtl-1 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; //判断是否全部任务已经完成,sizeCtl初始值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) //这里判断如果还有其他线程正在操作，直接返回，否则的话重新初始化i对原tab进行一遍检查然后再提交 if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit &#125; &#125; else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd);//i位置节点为空，替换为ForwardingNode节点，用于通知其他线程该位置已经处理 else if ((fh = f.hash) == MOVED)//节点已经被其他线程处理过，继续处理下一个节点 advance = true; // already processed else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123;//check stable //处理当前拿到的节点,构建两个node:ln/hn。ln:原位置; hn:i+n位置 Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123;//当前为链表节点（fh&gt;=0） //使用fn&amp;n把原链表中的元素分成两份（fn&amp;n = n or 0） //在表扩容2倍后，索引i可能发生改变，如果原table长度n=2^x，如果hash的x位为1，此时需要加上x位的值，也就是i+n； //如果x位为0，索引i不变 int runBit = fh &amp; n; // n or 0 //最后一个与头节点f索引不同的节点 Node&lt;K,V&gt; lastRun = f; //从索引i的节点开始向后查找最后一个有效节点 for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n;//n or 0 if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; //把f链表分解为两个链表 for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; //在原位置 if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); //i+n位置 else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; //nextTab的i位置插入一个链表 setTabAt(nextTab, i, ln); //nextTab的i+n位置插入一个链表 setTabAt(nextTab, i + n, hn); //在table的i位置上插入forwardNode节点 表示已经处理过该节点 setTabAt(tab, i, fwd); advance = true; &#125; /** * 如果该节点是红黑树结构，则构造树节点lo和hi，遍历红黑树中的节点，同样是根据hash&amp;tab.length算法， * 把节点分为两类，分别插入索引i和(i+n)位置。 */ else if (f instanceof TreeBin) &#123; //转为根结点 TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null;//低位(i)节点和低位尾节点 TreeNode&lt;K,V&gt; hi = null, hiTail = null;//高位(i+n)节点和高位尾节点 int lc = 0, hc = 0; //从首个节点向后遍历 for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; //构建树节点 TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); //原位置 if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; //i+n位置 else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; //如果扩容后已经不再需要tree的结构 反向转换为链表结构 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125;&#125; 说明： transfer方法是table扩容的核心实现。由于 ConcurrentHashMap 的扩容是新建一个table，所以主要问题就是如何把旧table的元素转移到新的table上。所以，扩容问题就演变成了“节点转移”问题。首先总结一下需要转移节点（调用transfer）的几个条件： 对table进行扩容时 在更新元素数目时(addCount方法)，元素总数&gt;=sizeCtl（sizeCtl=0.75n，达到扩容阀值），此时也需要扩容 在put操作时，发现索引节点正在转移(hash==MOVED)，此时需要帮助转移 在进行节点转移之前，首先要做的就是重新初始化sizeCtl的值（sizeCtl = (hash &lt;&lt; RESIZE_STAMP_SHIFT) + 2），这个值是一个负值，用于标识当前table正在进行转移操作，并且每有一个线程参与转移，sizeCtl就加1。transfer执行步骤如下（请结合源码注释阅读）： 计算转移幅度stride（或者说是当前线程需要转移的节点数），最小为16； 创建一个相当于当前 table 两倍容量的 Node 数组，转移完成后用作新的 table； 从transferIndex（初始为table.length，也就是 table 的最后一个节点）开始，依次向前处理stride个节点。前面介绍过，table 的每个节点都可能是一个链表结构，因为在 put 的时候是根据(table.length-1)&amp;hash计算出的索引，当插入新值时，如果通过 key 计算出的索引已经存在节点，那么这个新值就放在这个索引位节点的尾部(Node.next)。所以，在进行节点转移后，由于 table.length 变为原来的两倍，所以相应的索引也会改变，这时候就需要对链表进行分割，我们来看一下这个分割算法： 假设当前处理的节点 table[i]=f，并且它是一个链表结构，原table容量为 n=2x，索引计算公式为i=(n - 1)&amp;hash。在表扩张后，由于容量 n 变为 2x+1 = 2*2x，所以索引计算就变为i=(2n - 1)&amp;hash。如果 hash 的 x 位为0，则 hash&amp;(2x-1)=hash，此时 hash&amp;(2x-1) == hash&amp;(2x+1-1)，索引位 i 不变；如果 hash 的 x 位为1，则 hash&amp;2x=2x == n，在扩容后 x 变为 x+1，此时的索引需要加上 x 位的值，即 _i=hash&amp;(2x-1) + hash&amp;2x，也就是 i+n。举个栗子：设 n=100000 (25)，x=5，hash 为100101（x位是1）。n-1=011111，那么i=hash&amp;(n-1)=000101；扩容后容量变为m=1000000(26)，m-1=0111111，那么 i 就变成了 hash&amp;(m-1)=100101，也就是说新的索引位_i = i+n。 如果当前节点为红黑树结构，也是利用这个算法进行分割，不同的是，在分割完成之后，如果这两个新的树节点&lt;=6，则调用untreeify方法把树结构转为链表结构。 最后把操作过的节点都设为 ForwardingNode 节点（hash= MOVED，这样别的线程就可以检测到）。 transfer操作完成后，table的结构变化如下： 扩容之后的table变化 3.1.6 addCount(long,int)123456789101112131415161718192021222324252627282930313233343536373839private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;//counterCells为null，CAS更新baseCount CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; fullAddCount(x, uncontended);//在线程争用资源时，使用fullAddCount计算更新元素数 return; &#125; if (check &lt;= 1) return; s = sumCount();//计算元素总数，用于后面的扩容操作 &#125; if (check &gt;= 0) &#123; //检查扩容 Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); //其他线程在进行扩容操作 if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125;&#125; 说明： put操作全部完成后，别忘了更新元素数量。addCount用来更新 ConcurrentHashMap 的元素数，根据所传参数check决定是否检查扩容，如果需要，调用transfer方法进行扩容/节点转移。这里面有一个看起来比较复杂的方法fullAddCount，作用是在线程争用资源时，使用它来计算更新元素数。这个方法的实现类似于LongAdder的add（LongAdder在上面有简单介绍），源码在此就不再详细分析了，有兴趣的同学可以研究下。 4. 总结到此，ConcurrentHashMap的分析就告一段落了。总的来说源码比较复杂，真正理解它还是需要一些耐心的。重点是它的数据结构和扩容的实现。 ConcurrentHashMap 源码分析到此结束，希望对大家有所帮助，如您发现文章中有不妥的地方，请留言指正，谢谢]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-集合篇:集合框架]]></title>
    <url>%2F2020%2F04%2F26%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E5%90%88%E7%AF%87-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[从JDK1.5开始，Java针对集合类提供了线程安全版本的实现，接下来我们将逐个分析JUC集合类的具体实现，本篇首先介绍一下整个JUC集合类的框架。 1. List和Set java.util.concurrent：List和Set CopyOnWriteArrayList：相当于线程安全的ArrayList，通过显式锁 ReentrantLock 实现线程安全。允许存储null值。 CopyOnWriteArraySet：相当于线程安全的HashSet，内部使用 CopyOnWriteArrayList 实现。允许存储null值。 ConcurrentSkipListSet在Map中说明 2. Map java.util.concurrent：Map ConcurrentHashMap：线程安全的HashMap（但不允许空key或value），ConcurrentHashMap在JDK1.7之前是通过Lock和segment（分段锁）实现，1.8之后改为CAS+synchronized来保证并发安全。 ConcurrentSkipListMap：跳表结构的并发有序哈希表。不允许存储null值。 ConcurrentSkipListSet：跳表结构的并发有序集合。内部使用 ConcurrentSkipListMap 实现。不允许存储null值。 3. Queue java.util.concurrent：Queue ArrayBlockingQueue：数组实现的线程安全的有界的阻塞队列，使用Lock机制实现并发访问，队列元素使用 FIFO（先进先出）方式。 LinkedBlockingQueue：单向链表实现的（指定大小）阻塞队列，使用Lock机制实现并发访问，队列元素使用 FIFO（先进先出）方式。 LinkedBlockingDeque：双向链表实现的（指定大小）双向并发阻塞队列，使用Lock机制实现并发访问，该阻塞队列同时支持FIFO和FILO两种操作方式。 ConcurrentLinkedQueue：单向链表实现的无界并发队列，通过CAS实现并发访问，队列元素使用 FIFO（先进先出）方式。 ConcurrentLinkedDeque：双向链表实现的无界并发队列，通过CAS实现并发访问，该队列同时支持FIFO和FILO两种操作方式。 DelayQueue：延时无界阻塞队列，使用Lock机制实现并发访问。队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。 PriorityBlockingQueue：无界优先级阻塞队列，使用Lock机制实现并发访问。priorityQueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。 SynchronousQueue：没有容量的同步队列，通过CAS实现并发访问，支持FIFO和FILO。 LinkedTransferQueue：1.7新增，单向链表实现的无界阻塞队列，通过CAS实现并发访问，队列元素使用 FIFO（先进先出）方式。LinkedTransferQueue可以说是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集, 它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析-数据结构(一)：HashMap]]></title>
    <url>%2F2020%2F04%2F23%2FJDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80-%EF%BC%9AHashMap%2F</url>
    <content type="text"><![CDATA[前言本文将对HashMap（基于JDK1.8）的源码进行具体分析，包括构造方法以及增、删、改、查等基本操作。 源码分析需要先了解的知识将会用到的实例常量1234 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //默认初始容量，为2^4 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量，为2^30 static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认加载因子static final int TREEIFY_THRESHOLD = 8; //树化阀值 将会用到的实例变量123456789 final float loadFactor; //加载因子 int threshold; //扩容的阀值，当键值对的数量超过这个阀值就扩容/* * table（一般称为哈希桶）在首次使用时初始化，并根据需要调整大小。 * 分配时，长度始终是2的幂（某些情况下可以为0）。 */ transient Node&lt;K,V&gt;[] table; transient int modCount; //HashMap被结构修改的次数 transient int size; //当前的键值对数量 Node（存储键值对的节点）123456789101112131415161718192021222324252627282930313233343536373839404142static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; //每个节点的hashCode是将key和value的hashCode进行异或操作后得到的 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; //设置新的value，返回旧的value public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //只有当两节点的key和value通过equals方法比较后都返回true时，equals方法才返回true public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 构造方法HashMap的构造方法有4种。 默认的构造方法1234public HashMap() &#123; //加载因子设置为默认的0.75f this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 带一个Map类型参数的构造方法1234public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; //加载因子设置为默认的0.75f putMapEntries(m, false);&#125; 该构造方法的作用是深拷贝一个HashMap 带一个int参数的构造方法123public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; 该构造方法直接调用另一构造方法，其参数的作用是指定初始化容量 带两个int参数的构造方法12345678910111213141516/* * @param initialCapacity 指定的初始容量 * @param loadFactor 指定的加载因子 */public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //初始化容量不能大于2^30 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) //加载因子必须大于0 throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; //指定加载因子 this.threshold = tableSizeFor(initialCapacity); //根据指定初始容量获取扩容的阀值&#125; 下面来看下是如何通过初始容量来获取扩容阀值的 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 最终返回的结果是一个大于或等于初始化容量的2^n，例如输入6，则返回8；输入16，则返回16。 put方法（增）123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; put方法又调用了putVal方法，先看一下hash方法 12345static final int hash(Object key) &#123; int h; //h保存key的hashCode，最终返回的hash值是h和h无符号右移16位后的数进行异或操作 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 为什么要计算一个hash值，而不是直接用hashCode呢？ 因为哈希桶容量通常是很小的，而hashCode是32位。所以在进行(n - 1) &amp; hashCode这个运算时，通常只能用上低16位。这可能会导致键值对在哈希桶中的分布不均匀，一些桶的链表过长。所以无符号右移16位就相当于把高16位推到了低16位，再与低16位进行异或操作，并把结果作为hash值，就间接地利用了高16位，从而可以在一定程度上使得键值对分布更加均匀，降低hash冲突的概率。 putIfAbsentput方法插入元素时，如果该元素已存在，会将旧的value替换为新的value（实现改的效果），如果不希望旧的value被替换，可以使用putIfAbsent方法。 1234@Overridepublic V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true);&#125; 可以看出，该方法同样是调用了putVal方法。在看putVal方法之前，需要先了解resize方法。 resize方法（扩容）该方法的作用是初始化或加倍哈希桶的容量，并返回新的哈希桶。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //旧的哈希桶 int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧桶的容量 int oldThr = threshold; //旧的扩容阀值 int newCap, newThr = 0; //新桶容量和新的扩容阀值初始化为0 if (oldCap &gt; 0) &#123; //如果旧桶容量大于0 //如果旧桶容量已经大于等于最大容量，则扩容阀值设置为最大值，并返回旧桶 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //新桶的容量设置为旧桶容量的两倍 //如果新桶容量小于最大容量，并且旧桶容量大于默认初始容量，则将新的扩容阀值设置为旧扩容阀值的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) &#123; //如果旧桶容量为0，但旧的扩容阀值大于0，那么将新桶容量设置为该扩容阀值 newCap = oldThr; &#125; else &#123; //如果旧的桶容量和扩容阀值都为0 newCap = DEFAULT_INITIAL_CAPACITY; //新桶容量设置为默认初始容量 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); //新的扩容阀值设置为：默认初始容量*默认加载因子 &#125; //如果此时新的扩容阀值为0，对应情况为：旧桶容量为0但旧的扩容阀值大于0 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; //ft为新桶容量*加载因子 //当新桶容量和ft都小于最大容量时，新的扩容阀值为ft，否则为最大值 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //更新扩容阀值 threshold = newThr; //创建新的哈希桶 @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //更新哈希桶 table = newTab; //如果旧哈希桶不为空，需要将旧哈希桶中的所有节点移动到新哈希桶 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; //e用于保存旧的节点 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //将旧节点置空 if (e.next == null) &#123; //如果该节点后面没有节点（说明没有发生哈希冲突） /* * 将当前节点放到新哈希桶的相应位置 * * 注意：由于newCap的值为2^n，所以(newCap-1)与e.hash作与运算其实是一个 * 取模运算（e.hash对newCap取模），但这样写效率更高。 */ newTab[e.hash &amp; (newCap - 1)] = e; &#125; else if (e instanceof TreeNode) &#123; //如果当前节点是一棵红黑树 //需要先将树拆分，然后再移动到新哈希桶中 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); &#125; else &#123; //如果当前节点是一个节点数小于8的链表 //将原链表拆分为两个链表（low链表和high链表） Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; //当e不为null时执行该循环 next = e.next; //将当前节点的hash值与oldCap作与运算（有两种结果，0或oldCap，而且这两种结果出现的概率各占50%） if ((e.hash &amp; oldCap) == 0) &#123; //结果为0，加入low链表 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; //结果为oldCap，加入high链表 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //将low链表存在原索引上 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //将high链表存在原索引加上旧桶容量上 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; //返回新的哈希桶 return newTab;&#125; 总共包含以下几个步骤： 获取新哈希桶的容量，更新扩容阀值 创建新哈希桶，并更新哈希桶 将旧哈希桶中的所以节点移动到新哈希桶上 返回新的哈希桶 putVal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //当哈希桶为空或其长度为0时 if ((tab = table) == null || (n = tab.length) == 0) &#123; //在resize方法中初始化哈希桶，并且将其长度赋给n n = (tab = resize()).length; &#125; //i为新节点的索引，如果该索引对应的节点为空，说明没有哈希冲突，直接创建一个新节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) &#123; tab[i] = newNode(hash, key, value, null); &#125; else &#123; //发生哈希冲突 Node&lt;K,V&gt; e; //e用于存储已存在的节点 K k; //p为新节点索引对应的原节点，k为p的key if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; /* * 如果p的哈希值和新节点相等，并且p的key和新节点的key通过equals方法比较后返回true， * 说明新节点已存在。 */ e = p; &#125; else if (p instanceof TreeNode) &#123; //如果p节点为红黑树 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); &#125; else &#123; //此时p节点为链表，将新节点放到链表的末尾 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //当链表的长度大于等于树化阀值（8）时，将链表转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; //说明新节点已存在 break; &#125; p = e; &#125; &#125; //如果e不为空，说明新节点已存在 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) &#123; //如果onlyIfAbsent为false或者旧的value为null，更新节点的value e.value = value; &#125; afterNodeAccess(e); return oldValue; //返回旧值 &#125; &#125; ++modCount; //结构修改次数加一 if (++size &gt; threshold) &#123; //当前键值对数量大于扩容阀值的时候 //进行扩容操作 resize(); &#125; afterNodeInsertion(evict); return null; //新加入的节点不重复时返回null&#125; putVal方法的执行步骤如下： 先判断哈希桶是否有初始化，没有初始化的话先初始化（所以哈希桶的初始化是发生在第一次添加元素的时候，之所以不在HashMap初始化的时候为哈希桶分配空间，是为了防止只创建集合而不添加元素时造成的空间浪费） 根据插入元素的hash值寻找相应的位置，判断该位置是否为空，为空则直接创建节点并插入，不为空时： 判断是否存在相等的key 判断该位置存储的是红黑树还是链表，根据不同情况有不同的插入 插入完成后，如果key相等，则判断是否要替换value，并返回旧的value。 更新修改次数、当前键值对数量。如果当前键值对数量超过了扩容阀值，则进行扩容操作。 能够执行到最后，说明插入的键值对是新的，没有旧value，所以返回null。 remove方法（删）remove有两个重载方法： 删除指定key的remove方法，如果删除成功，返回删除键值对的value，否则返回null。 12345public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; 删除指定键值对的remove，如果删除成功，返回true，否则返回false。 1234@Overridepublic boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null;&#125; 这两个方法都是调用了removeNode方法 removeNode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Implements Map.remove and related methods * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //tab用于存储哈希桶，n存储哈希桶的容量,index存储hash值对应的哈希桶索引,p存储hash值所对应的头节点 //如果哈希桶不为空且长度大于0，并且该key存在对应的节点，才会执行删除操作，否则直接返回null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; //node存储要删除结点 K k; V v; //k存储p节点对应的key if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; //如果要删除的节点的hash值和key都与p节点相等 node = p; &#125; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) //如果p节点是红黑树 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; //p节点是单链表 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; //p记录要删除节点的上一节点 &#125; while ((e = e.next) != null); &#125; &#125; //如果找到了要删除的节点（如果还指明了要删除的value的话，还要比较value是否一致） if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) &#123; //删除红黑树中的节点 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); &#125; else if (node == p) &#123; //要删除节点是链表的头结点 tab[index] = node.next; &#125; else &#123; //要删除节点不是链表的头结点 p.next = node.next; &#125; ++modCount; //增加修改次数 --size; //减少哈希桶的容量 afterNodeRemoval(node); return node; //返回删除节点 &#125; &#125; return null;&#125; 删除节点的步骤如下： 先要确保哈希桶不为空且长度大于0，并且要删除的key在哈希桶中有对应节点。如果不满足这些条件，直接返回null。 如果对应节点就是要删除的节点，那么直接记录下该节点。如果不是的话，还要判断对应节点是红黑树还是单链表，分情况找到要删除的节点。 如果最终没有找到要删除的节点，返回null。如果找到了要删除的节点，就把该节点从红黑树或链表中删除，并返回该节点。 replace方法（改）replace有两个重载方法 带三个参数的重载方法传入要修改的键值对的key和value，以及要更新后的value。如果找到该键值对并修改成功，返回true，否则返回false。 12345678910111213@Overridepublic boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; //e存储要修改的节点，v存储修改节点的旧value //如果找到要修改的节点并且该节点的value和oldValue一致，执行修改操作，否则直接返回false if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; e.value = newValue; //更新该节点的value afterNodeAccess(e); return true; &#125; return false;&#125; 带两个参数的重载方法传入要修改的键值对的key以及更新后的value。如果修改成功，返回旧的value，否则返回null。 123456789101112@Overridepublic V replace(K key, V value) &#123; Node&lt;K,V&gt; e; //如果找到要修改的节点，执行修改操作，否则直接返回null if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; //更新该节点的value afterNodeAccess(e); return oldValue; //返回该节点的旧value &#125; return null;&#125; 这两个重载方法都调用了getNode方法 getNodegetNode方法的作用是根据传入的hash值和key值，找到对应的节点并返回，若没有找到则返回null。 12345678910111213141516171819202122232425262728293031323334/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; //tab存储哈希桶，first存储hash值所对应的头节点 int n; K k; //n存储哈希桶容量 /* * 当哈希桶不为空并且其长度大于0，同时存在要查找的hash值所对应的头节点时， * 才执行相关查找操作，否则直接返回null。 */ if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; //先检查该头节点是否就是要查找的节点 return first; &#125; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) &#123; //该节点是红黑树 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); &#125; do &#123; //该节点是单链表 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; get方法（查）12345public V get(Object key) &#123; Node&lt;K,V&gt; e; //如果找到对应节点，则返回该节点的value，否则返回null。 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 可以看到，get方法也是通过getNode方法来查找节点。在分析replace方法时已经分析过该方法，这里不再多说。 小结本文对HashMap的构造方法以及增删改查等基本操作进行了源码分析，分析过后，对于HashMap有了更深的认识，在这里小结一下： HashMap有4种构造方法，除了默认的方法外，我们还可以通过其他的构造方法初始化HashMap的元素，或者根据需要设置哈希桶的初始化容量和加载因子。 哈希桶的初始化不是发生在创建HashMap的时候，而是发生在第一次插入元素的时候，通过扩容操作初始化。 哈希桶在扩容时，如果旧桶容量大于0并且小于最大容量（2^30），那么新桶容量是旧桶容量的两倍。旧桶中的链表会被拆分为两个链表存到新桶中。 哈希桶的数据结构是数组，在处理哈希冲突时，如果发生冲突的元素小于8个的时候，是用单链表存起来的。一旦冲突的元素个数大于等于8个，那么单链表将转化为红黑树。 作者：MrFengZH链接：https://www.jianshu.com/p/5c1ffa06aec7来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-JUC锁（三）：CountDownLatch]]></title>
    <url>%2F2020%2F04%2F23%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JUC%E9%94%81%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ACountDownLatch%2F</url>
    <content type="text"><![CDATA[JUC源码分析-JUC锁（三）：CountDownLatch1. 概述 CountDownLatch是一个同步辅助类，通过AQS实现的一个闭锁。在其他线程完成它们的操作之前，允许一个多个线程等待。简单来说，CountDownLatch中有一个锁计数，在计数到达0之前，线程会一直等待。 CountDownLatch运行机制 2. 数据结构和核心参数 CountDownLatch继承关系 从锁类别来说，CountDownLatch是一个“共享锁”，内部定义了自己的同步器Sync，Sync继承自AQS，实现了tryAcquireShared和tryReleaseShared两个方法。需要注意的是，CountDownLatch中的锁是响应中断的，如果线程在对锁进行操作期间发生中断，会直接抛出InterruptedException。 3. 源码解析123456789//构造函数public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count);&#125;//CountDownLatch中的计数其实就是AQS的stateSync(int count) &#123; setState(count);&#125; 说明：从构造函数中可以看出，CountDownLatch的“锁计数”本质上就是AQS的资源数state。下面我们将通过await()和countDown()两个方法来分析CountDownLatch的“latch”实现。 3.1 await()1234567891011121314151617public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;//AQS中acquireSharedInterruptibly(1)的实现public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125;//tryAcquireShared在CountDownLatch中的实现protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; 说明:await()的实现非常简单，就是通过对资源state剩余量（state==0 ? 1 : -1）来判断是否获取到锁。在《AQS》篇中我们讲到过，tryAcquireShared函数规定了它的返回值类型：成功获取并且还有可用资源返回正数；成功获取但是没有可用资源时返回0；获取资源失败返回一个负数。 也就是说，只要state!=0，线程就进入等待队列阻塞。 3.2 countDown()12345678910111213141516171819202122232425public void countDown() &#123; sync.releaseShared(1);&#125;//AQS中releaseShared(1)的实现public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared();//唤醒后续节点 return true; &#125; return false;&#125;//tryReleaseShared在CountDownLatch中的实现protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 说明：如果释放资源后state==0,说明已经到达latch，此时就可以调用doReleaseShared唤醒等待的线程。 小结相对其他同步类来说，CountDownLatch可以说是最简单的同步类实现了。它完全依赖了AQS，只要理解了AQS，那么理解它就不成问题了。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析-JUC锁（四）：CyclicBarrier]]></title>
    <url>%2F2020%2F04%2F23%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JUC%E9%94%81%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ACyclicBarrier%2F</url>
    <content type="text"><![CDATA[1.概述 CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。如果一个程序中有固定的线程数，并且线程之间需要相互等待，这时候CyclicBarrier是一个很好的选择。之所以叫它cyclic，是因为在释放等待线程之后，它可以被重用。 CyclicBarrier运行机制 CountDownLatch和CyclicBarrier的区别： CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 2. 函数列表和核心参数1234567891011121314151617181920212223242526272829303132333435//-------------------------核心参数------------------------------// 内部类private static class Generation &#123; boolean broken = false;&#125;/** 守护barrier入口的锁 */private final ReentrantLock lock = new ReentrantLock();/** 等待条件，直到所有线程到达barrier */private final Condition trip = lock.newCondition();/** 要屏障的线程数 */private final int parties;/* 当线程都到达barrier，运行的 barrierCommand*/private final Runnable barrierCommand;/** The current generation */private Generation generation = new Generation();//等待到达barrier的参与线程数量，count=0 -&gt; trippedprivate int count;//-------------------------函数列表------------------------------//构造函数，指定参与线程数public CyclicBarrier(int parties)//构造函数，指定参与线程数，并在所有线程到达barrier之后执行给定的barrierAction逻辑public CyclicBarrier(int parties, Runnable barrierAction);//等待所有的参与者到达barrierpublic int await();//等待所有的参与者到达barrier，或等待给定的时间public int await(long timeout, TimeUnit unit);//获取参与等待到达barrier的线程数public int getParties();//查询barrier是否处于broken状态public boolean isBroken();//重置barrier为初始状态public void reset();//返回等待barrier的线程数量public int getNumberWaiting(); Generation：每个使用中的barrier都表示为一个generation实例。当barrier触发trip条件或重置时generation随之改变。使用barrier时有很多generation与线程关联，由于不确定性的方式，锁可能分配给等待的线程。但是在同一时间只有一个是活跃的generation(通过count变量确定)，并且其余的要么被销毁，要么被trip条件等待。如果有一个中断，但没有随后的重置，就不需要有活跃的generation。CyclicBarrier的可重用特性就是通过Generation来实现，每一次触发tripped都会new一个新的Generation。 barrierCommand：CyclicBarrier的另一个特性是在所有参与线程到达barrier触发一个自定义函数，这个函数就是barrierCommand，在CyclicBarrier的构造函数中初始化。 3. 源码解析3.1 构造方法12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障位置，线程被阻塞。 另外一个构造方法CyclicBarrier(int parties, Runnable barrierAction)，其中barrierAction任务会在所有线程到达屏障后执行。 3.2 await()最主要的方法就是await()方法，调用await()的线程会等待直到有足够数量的线程调用await——也就是开闸状态。 1234567891011121314public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125;public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout));&#125; await()和await(long, TimeUnit)都是调用dowait方法，区别就是参数不同，我们来看看dowait方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final Generation g = generation; if (g.broken) // 如果当前Generation是处于打破状态则传播这个BrokenBarrierExcption throw new BrokenBarrierException(); if (Thread.interrupted()) &#123; // 如果当前线程被中断则使得当前generation处于打破状态，重置剩余count。 // 并且唤醒状态变量。这时候其他线程会传播BrokenBarrierException。 breakBarrier(); throw new InterruptedException(); &#125; int index = --count; // 尝试降低当前count /** * 如果当前状态将为0，则Generation处于开闸状态。运行可能存在的command， * 设置下一个Generation。相当于每次开闸之后都进行了一次reset。 */ if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) // 如果运行command失败也会导致当前屏障被打破。 breakBarrier(); &#125; &#125; // loop until tripped, broken, interrupted, or timed out for (;;) &#123; try &#123; if (!timed) // 阻塞在当前的状态变量。 trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; // 如果当前线程被中断了则使得屏障被打破。并抛出异常。 breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; // 从阻塞恢复之后，需要重新判断当前的状态。 if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 说明：dowait()是await()的实现函数，它的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，当前线程才继续执行。当所有parties到达barrier（count=0），如果barrierCommand不为空，则执行barrierCommand。然后调用nextGeneration()进行换代操作。 在for(;;)自旋中。timed是用来表示当前是不是“超时等待”线程。如果不是，则通过trip.await()进行等待；否则，调用awaitNanos()进行超时等待。 此外再看下两个小过程： 这两个小过程当然是需要锁的，但是由于这两个方法只是通过其他方法调用，所以依然是在持有锁的范围内运行的。这两个方法都是对域进行操作。 nextGeneration实际上在屏障开闸之后重置状态。以待下一次调用。 breakBarrier实际上是在屏障打破之后设定打破状态，以唤醒其他线程并通知。 1234567891011private void nextGeneration() &#123; trip.signalAll(); count = parties; generation = new Generation();&#125;private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll();&#125; 3.4、resetreset方法比较简单。但是这里还是要注意一下要先打破当前屏蔽，然后再重建一个新的屏蔽。否则的话可能会导致信号丢失。 12345678910public void reset() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; breakBarrier(); // break the current generation nextGeneration(); // start a new generation &#125; finally &#123; lock.unlock(); &#125;&#125; 小结CyclicBarrier主要通过独占锁ReentrantLock和Condition配合实现。类本身实现很简单，重点是分清CyclicBarrier和CountDownLatch的用法及区别，还有在jdk1.7新增的另外一个与它们相似的同步锁Phaser，在后面文章中会详细讲解。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令基础]]></title>
    <url>%2F2020%2F02%2F19%2FLinux%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[2. 文件及目录管理目录 文件及目录管理 创建和删除 目录切换 列出目录项 查找目录及文件 find/locate 查看文件内容 查找文件内容 文件与目录权限修改 给文件增加别名 管道和重定向 设置环境变量 Bash快捷输入或删除 综合应用 总结 文件管理主要有文件或目录的创建、删除、查询、移动，文件查询是重点，用find来进行查询；find的参数丰富，也非常强大； 查看文件内容是个大的话题，文本的处理有太多的工具供我们使用，在本章中只是点到即止，后面会有专门的一章来介绍文本的处理工具； 有时候，需要给文件创建一个别名，我们需要用到ln，使用这个别名和使用原文件是相同的效果； 2.1 创建和删除 创建：mkdir 删除：rm 删除非空目录：rm -rf file目录 删除日志 rm log (等价: $find ./ -name “log” -exec rm {} ;) 移动：mv 复制：cp (复制目录：cp -r ) 查看当前目录下文件个数: 1$find ./ | wc -l 复制目录: 1cp -r source_dir dest_dir 2.2. 目录切换 找到文件/目录位置：cd 切换到上一个工作目录： cd - 切换到home目录： cd or cd ~ 显示当前路径: pwd 更改当前工作路径为path: $cd path 2.3. 列出目录项 显示当前目录下的文件 ls 按时间排序，以列表的方式显示目录项 ls -lrt 以上这个命令用到的频率如此之高，以至于我们需要为它建立一个快捷命令方式: 在.bashrc 中设置命令别名: 12alias lsl=&apos;ls -lrt&apos;alias lm=&apos;ls -al|more&apos; 这样，使用lsl，就可以显示目录中的文件按照修改时间排序；以列表方式显示； 给每项文件前面增加一个id编号(看上去更加整洁): 1&gt;ls | cat -n 1 a 2 a.out 3 app 4 b 5 bin 6 config 注：.bashrc 在/home/你的用户名/ 文件夹下，以隐藏文件的方式存储；可使用 ls -a 查看； 2.4. 查找目录及文件 find/locate搜寻文件或目录: 1$find ./ -name &quot;core*&quot; | xargs file 查找目标文件夹中是否有obj文件: 1$find ./ -name &apos;*.o&apos; 递归当前目录及子目录删除所有.o文件: 1$find ./ -name &quot;*.o&quot; -exec rm &#123;&#125; \; find是实时查找，如果需要更快的查询，可试试locate；locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库: 1$locate string 寻找包含有string的路径: 1$updatedb 与find不同，locate并不是实时查找。你需要更新数据库，以获得最新的文件索引信息。 2.5. 查看文件内容查看文件：cat vi head tail more 显示时同时显示行号: 1$cat -n 按页显示列表内容: 1$ls -al | more 只看前10行: 1$head - 10 ** 显示文件第一行: 1$head -1 filename 显示文件倒数第五行: 1$tail -5 filename 查看两个文件间的差别: 1$diff file1 file2 动态显示文本最新信息: 1$tail -f crawler.log 2.6. 查找文件内容使用egrep查询文件内容: 12egrep &apos;03.1\/CO\/AE&apos; TSF_STAT_111130.log.012egrep &apos;A_LMCA777:C&apos; TSF_STAT_111130.log.035 &gt; co.out2 2.7. 文件与目录权限修改 改变文件的拥有者 chown 改变文件读、写、执行等属性 chmod 递归子目录修改： chown -R tuxapp source/ 增加脚本可执行权限： chmod a+x myscript 2.8. 给文件增加别名创建符号链接/硬链接: 12ln cc ccAgain :硬连接；删除一个，将仍能找到；ln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件） 2.9. 管道和重定向 批处理命令连接执行，使用 | 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行:&amp;&amp; 前面失败，则后一条执行: || 1ls /proc &amp;&amp; echo suss! || echo failed. 能够提示命名是否执行成功or失败； 与上述相同效果的是: 1if ls /proc; then echo suss; else echo fail; fi 重定向: 1ls proc/*.c &gt; list 2&gt; &amp;l 将标准输出和标准错误重定向到同一文件； 等价的是: 1ls proc/*.c &amp;&gt; list 清空文件: 1:&gt; a.txt 重定向: 1echo aa &gt;&gt; a.txt 2.10. 设置环境变量启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量； 安装的软件路径一般需要加入到path中: 1PATH=$APPDIR:/opt/app/soft/bin:$PATH:/usr/local/bin:$TUXDIR/bin:$ORACLE_HOME/bin;export PATH 2.11. Bash快捷输入或删除快捷键: 1234Ctl-U 删除光标到行首的所有字符,在某些设置下,删除全行Ctl-W 删除当前光标到前边的最近一个空格之间的字符Ctl-H backspace,删除光标前边的字符Ctl-R 匹配最相近的一个文件，然后输出 2.12. 综合应用查找record.log中包含AAA，但不包含BBB的记录的总数: 1cat -v record.log | grep AAA | grep -v BBB | wc -l 2.13. 总结文件管理，目录的创建、删除、查询、管理: mkdir rm mv 文件的查询和检索: find locate 查看文件内容：cat vi tail more 管道和重定向: ; | &amp;&amp; &gt;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>目录管理</tag>
        <tag>文本处理</tag>
        <tag>磁盘管理</tag>
        <tag>性能监控</tag>
        <tag>网络工具</tag>
        <tag>用户管理</tag>
        <tag>系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode10正则表达式匹配]]></title>
    <url>%2F2020%2F01%2F20%2FLeetcode10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[问题描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 算法思想 状态首先状态 dp 一定能自己想出来。dp[i][j] 表示 s 的前 ii 个是否能被 p 的前 jj 个匹配 转移方程怎么想转移方程？首先想的时候从已经求出了 dp[i-1][j-1] 入手，再加上已知 s[i]、p[j]，要想的问题就是怎么去求 dp[i][j]。 已知 dp[i-1][j-1] 意思就是前面子串都匹配上了，不知道新的一位的情况。那就分情况考虑，所以对于新的一位 p[j] s[i] 的值不同，要分情况讨论： 考虑最简单的 p[j] == s[i] : dp[i][j] = dp[i-1][j-1]然后从 p[j] 可能的情况来考虑，让 p[j]=各种能等于的东西。 p[j] == “.” : dp[i][j] = dp[i-1][j-1] p[j] ==” * “: 第一个难想出来的点：怎么区分 ∗ 的两种讨论情况首先给了 ，明白 的含义是 匹配零个或多个前面的那一个元素，所以要考虑他前面的元素 p[j-1]。 跟着他前一个字符走，前一个能匹配上 s[i]， 才能有用，前一个都不能匹配上 s[i]， 也无能为力，只能让前一个字符消失，也就是匹配 00 次前一个字符。所以按照 p[j-1] 和 s[i] 是否相等，我们分为两种情况： 3.1 p[j-1] != s[i] : dp[i][j] = dp[i][j-2]这就是刚才说的那种前一个字符匹配不上的情况。比如(ab, abc )。遇到 往前看两个，发现前面 s[i] 的 ab 对 p[j-2] 的 ab 能匹配，虽然后面是 c，但是可以看做匹配 00 次 c，相当于直接去掉 c ，所以也是 True。注意 (ab, abc**) 是 False。3.2 p[j-1] == s[i] or p[j-1] == “.”： 前面那个字符，能匹配 s[i]，或者 前面那个字符是万能的 .因为 . 就相当于 . .，那就只要看前面可不可以匹配就行。比如 (##b , ###b )，或者 ( ##b , ### . ) 只看 ### 后面一定是能够匹配上的。所以要看 b 和 b 前面那部分 ## 的地方匹不匹配。第二个难想出来的点：怎么判断前面是否匹配dp[i][j] = dp[i-1][j] // 多个字符匹配的情况or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况or dp[i][j] = dp[i][j-2] // 没有匹配的情况看 ### 匹不匹配，不是直接只看 ### 匹不匹配，要综合后面的 b b 来分析这三种情况是 oror 的关系，满足任意一种都可以匹配上，同时是最难以理解的地方： dp[i-1][j] 就是看 s 里 b 多不多， ### 和 ###b 是否匹配，一旦匹配，s 后面再添个 b 也不影响，因为有 在，也就是 ###b 和 ###b *也会匹配。 dp[i][j-1] 就是去掉 * 的那部分，###b 和 ###b 是否匹配，比如 qqb qqb dp[i][j-2] 就是 去掉多余的 b ，p 本身之前的能否匹配，###b 和 ### 是否匹配，比如 qqb qqbb 之前的 qqb qqb 就可以匹配，那多了的 b 也无所谓，因为 b 可以是匹配 00 次 b，相当于 b * 可以直接去掉了。 三种满足一种就能匹配上。 为什么没有 dp[i-1][j-2] 的情况？ 就是 ### 和 ### 是否匹配？因为这种情况已经是 dp[i][j-1] 的子问题。也就是 s[i]==p[j-1]，则 dp[i-1][j-2]=dp[i][j-1]。 最后来个归纳：如果 p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]；如果 p.charAt(j) == ‘.’ : dp[i][j] = dp[i-1][j-1]；如果 p.charAt(j) == ‘‘：如果 p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a only counts as empty如果 p.charAt(j-1) == s.charAt(i) or p.charAt(i-1) == ‘.’：dp[i][j] = dp[i-1][j] //in this case, a counts as multiple aor dp[i][j] = dp[i][j-1] // in this case, a counts as single aor dp[i][j] = dp[i][j-2] // in this case, a* counts as empty 代码实现12345678910111213141516171819202122class Solution &#123; public boolean isMatch(String s, String p) &#123; return isMatchHelper(s, 0, p, 0, new byte[(s.length() + 1) * (p.length() + 1)]); &#125; private boolean isMatchHelper(String s, int sIndex, String p, int pIndex, byte[] dp)&#123; if(dp[sIndex * p.length() + pIndex] != 0)&#123; return dp[sIndex * p.length() + pIndex] == 1; &#125; if(pIndex == p.length())&#123; return sIndex == s.length(); &#125; boolean match; boolean firstMatch = sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex)); if(pIndex + 1 &lt; p.length() &amp;&amp; p.charAt(pIndex + 1) == '*')&#123; match = isMatchHelper(s, sIndex, p, pIndex + 2, dp) || (firstMatch &amp;&amp; isMatchHelper(s, sIndex + 1, p, pIndex, dp)); &#125;else&#123; match = firstMatch &amp;&amp; isMatchHelper(s, sIndex + 1, p, pIndex + 1, dp); &#125; dp[sIndex * p.length() + pIndex] = (byte) (match ? 1 : 2); return match; &#125;&#125; 复杂度分析时间复杂度：因为while循环遍历的次数是线性的，假设L1与L2的最大长度为 r , 则时间复杂度为O(r) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 92% Solutionjava执行用时: 31ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode04-寻找两个有序数组的中位数]]></title>
    <url>%2F2019%2F11%2F07%2FLeetcode04-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 算法思想为了解决这个问题，我们需要理解 “中位数的作用是什么”。在统计中，中位数被用来： 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 如果理解了中位数的划分作用，我们就很接近答案了。 首先，让我们在任一位置 iii 将 A\text{A}A 划分成两个部分： left_A | right_A A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 由于 A 中有 m 个元素， 所以我们有 m+1种划分的方法（i=0∼m）。 我们知道： len(left_A) = i, len(right_A) = m−i 注意：当 i=0 时，left_A 为空集， 而当 i=m 时, right_A 为空集。 采用同样的方式，我们在任一位置 j将 B 划分成两个部分： left_B | right_B B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 将 left_A 和 left_B放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part： left_part | right_part A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们可以确认： len(left_part) = len(right_part) max⁡(left_part)≤min⁡(right_part) 那么，我们已经将 {A,B}中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么： $$median=\frac{max(left_part)+min(right_part)}{2}$$要确保这两个条件，我们只需要保证： $$i+j=m−i+n−j（或：m - i + n - j + 1 )$$ $$如果 n≥m，只需要使 i = 0 ~ m,\ j = \frac{m + n + 1}{2} - i$$ $$\text{B}[j-1] \leq \text{A}[i] 和 \text{A}[i-1] \leq \text{B}[j]$$ ps.1 为了简化分析，我假设 A[i−1],B[j−1],A[i],B[j]总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。我将在最后讨论如何处理这些临界值。 ps.2 为什么 n≥m？由于0≤i≤m 且$$j= \frac{m + n + 1}{2} - i$$ 我必须确保 j 不是负数。如果 n&lt;m，那么 j 将可能是负数，而这会造成错误的答案。 所以，我们需要做的是： 在 [0，m]中搜索并找到目标对象 i，以使： $$B[j−1]≤A[i] 且 \text{A}[i-1] \leq \text{B}[j], 其中 j = \frac{m + n + 1}{2} - i$$ 接着，我们可以按照以下步骤来进行二叉树搜索： 设 imin=0，imax=m, 然后开始在 [imin,imax]中进行搜索。 令$$ i = \frac{\text{imin} + \text{imax}}{2}, j = \frac{m + n + 1}{2} - i $$ 现在我们有 len(left_part)=len(right_part)。 而且我们只会遇到三种情况： B[j−1]≤A[i] 且 A[i−1]≤B[j]：这意味着我们找到了目标对象 i，所以可以停止搜索。 B[j−1]&gt;A[i]：这意味着 A[i]太小，我们必须调整 i 以使 B[j−1]≤A[i]。我们可以增大 i 吗？ 是的，因为当 i 被增大的时候，j 就会被减小。 因此 B\[j−1] 会减小，而 A\[i] 会增大，那么 B\[j−1\]≤A\[i]就可能被满足。 我们可以减小 i吗？ 不行，因为当 i 被减小的时候，j就会被增大。 因此 B\[j−1] 会增大，而 A\[i]会减小，那么 B\[j−1\]≤A\[i]就可能不满足。 所以我们必须增大 i。也就是说，我们必须将搜索范围调整为 [i+1,imax]。因此，设 imin=i+1，并转到步骤 2。 A[i−1]>B[j]：这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1]≤B[j]。也就是说，我们必须将搜索范围调整为 [imin,i−1]。因此，设 imax=i−1，并转到步骤 2。 当找到目标对象 i 时，中位数为： max⁡(A[i−1],B[j−1]), 当 m+n为奇数时 $$\frac{max(A[i−1],B[j−1])+min(A[i],B[j])}{2} , 当m+n为偶数时$$ 现在，让我们来考虑这些临界值 i = 0,i = m, j = 0, j = n，此时A[i − 1], B[j − 1], A[i], B[j] 可能不存在。其实这种情况⽐你想象的要容易得多。其实这种情况比你想象的要容易得多。 我们需要做的是确保 max(left_part)≤min(right_part)。 因此，如果i 和 j 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j]全部存在）, 那么我们必须同时检查 B[j−1]≤A[i]以及 A[i−1]≤B[j]是否成立。但是如果 A[i−1],B[j−1],A[i],B[j]中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。举个例子，如果 i=0，那么 A[i−1] 不存在，我们就不需要检查 A[i−1]≤B[j]是否成立。所以，我们需要做的是： 在 [0，m]中搜索并找到目标对象 i，以使： (j =0 or i =m or B[j−1]≤A[i]) 或是(i =0 or j =n or A[i−1]≤B[j]), 其中$$j = \frac{m + n + 1}{2} - i$$ 在循环搜索中，我们只会遇到三种情况： (j =0 or i =m or B[j−1]≤A[i]) 或是 (i =0 or j =n or A[i−1]≤B[j])，这意味着 i 是完美的，我们可以停止搜索。 j>0 and iA[i] 这意味着 i 太小，我们必须增大它。 i>0 and jB[j] 这意味着 i 太大，我们必须减小它。 i&lt;m⟹ j>0 以及 i>0 ⟹ j&lt;n 始终成立，这是因为： $$m≤n, i&lt;m⟹j= \frac{m+n+1}{2} - i &gt; \frac{m+n+1}{2} - m ≥ \frac{2m+1}{2} - m ≥ 0$$ $$m≤n, i&gt;0⟹j= \frac{m+n+1}{2} - i &lt;\frac{m+n+1}{2} ≤ \frac{2n+1}{2} ≤ n$$ 所以，在情况 2 和 3中，我们不需要检查 j>0 或是 j&lt;n 是否成立。 代码实现12345678910111213141516171819202122232425262728293031323334public double findMedianSortedArrays_P(int[] A, int[] B) &#123; int m = A.length; int n = B.length; if (m &gt; n) &#123; // to ensure m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i])&#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = B[j-1]; &#125; else if (j == 0) &#123; maxLeft = A[i-1]; &#125; else &#123; maxLeft = Math.max(A[i-1], B[j-1]); &#125; if ( (m + n) % 2 == 1 ) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = B[j]; &#125; else if (j == n) &#123; minRight = A[i]; &#125; else &#123; minRight = Math.min(B[j], A[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125; 复杂度分析 时间复杂度：O(log⁡(min(m,n)))，首先，查找的区间是 [0,m]。而该区间的长度在每次循环之后都会减少为原来的一半。所以，我们只需要执行 log⁡(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log⁡(m))。由于 m≤n ，所以时间复杂度是 O(log⁡(min(m,n)))。 空间复杂度：O(1 ，我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1) 。 leetcode 99% Solution执行用时 :3 ms, 在所有 java 提交中击败了99.23%的用户 内存消耗 :47 MB, 在所有 java 提交中击败了94.74%的用户 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode257-二叉树的所有路径]]></title>
    <url>%2F2019%2F09%2F04%2FLeetcode275-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Description 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \2 3 \ 5 输出: [“1-&gt;2-&gt;5”, “1-&gt;3”] 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 Method 如果二叉树为空,返回空的list 深度遍历二叉树,如果左右孩子节点为空 则为叶子节点 字符串拼接 s += root.val + “-&gt;”; 拼接每一次的值 如果左子树不为空 深度搜索 如果右子树不为空 深度搜索 12345678910111213141516171819public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; dfs(root, list, ""); return list; &#125; private void dfs(TreeNode root, List&lt;String&gt; list, String s)&#123; if (root.left == null &amp;&amp; root.right == null)&#123; list.add(s + root.val); return; &#125; s += root.val + "-&gt;"; if (root.left != null) dfs(root.left, list, s); if (root.right != null) dfs(root.right, list, s); &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(1). AcceptedRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths. Memory Usage: 36.4 MB, less than 100.00% of Java online submissions for Binary Tree Paths. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略-深入理解JVM]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%2F</url>
    <content type="text"><![CDATA[​ 最近在看周志明老师的《深入理解Java虚拟机》，准备留下一些学习笔记，供以后复习用。以下内容主要来自于《深入理解Java虚拟机》第三章–垃圾收集器与内存分配策略。 一 学习目标 对象存活判断算法 GC（garbage collection）算法学习 垃圾回收器 内存分配与回收策略 对于GC学习,我们主要考虑三个问题：哪些内存需要回收 -&gt; 什么时候回收 -&gt; 如何回收 二 那些内存需要回收 内存运行时，程序计数器、本地方法栈和虚拟机栈是随着线程的产生而产生，随着线程的消亡而消亡的，这几部分的内存分配和回收是确定好了的，随方法结束或线程结束时，内存就紧跟着回收了。而Java堆和方法区不一样。一个接口中多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在运行期间才知道会创建哪些对象，故内存回收与分配重点关注的是堆内存和方法区内存。 三.什么时候回收（判断对象的存活）对于方法区，永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 对于堆，其中存放的是对象实例，对于对象实例的回收，我们首先要判断哪些对象是“存活的”，对于那部分“死亡的”对象，就是我们要回收的。判断对象的存活有两种方法： 引用计数算法 可达性分析算法 引用计数算法给对象添加一个引用计数器, 每当有一个地方引用它时, 计数器值+1, 引用失效, -1, 为0的对象不能被使用。 优势：实现简单，效率高。 缺点：无法解决对象相互引用的问题——会导致对象的引用虽然存在，但是已经不可能再被使用，却无法被回收。 可达性分析算法通过一系列的称为“GC Roots”的对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链(Reference Chain), 当一个对象到GC Roots不可达(也就是不存在引用链)的时候, 证明对象是不可用的。如下图: Object5、6、7 虽然互有关联, 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。（注意：不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记） 在Java, 可作为GC Roots的对象包括： 方法区: 类静态属性引用的对象; 方法区: 常量引用的对象; 虚拟机栈(本地变量表)中引用的对象. 本地方法栈JNI(Native方法)中引用的对象。 四 如何回收-垃圾收集算法1.标记清除算法 分为标记和清除两个阶段，先标记出需要回收的对象（可达性分析算法或者引用计数算法），在标记完成后统一回收所有被标记的对象。 不足之处：效率问题，标记和清除效率都不高。空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。 2.复制算法 将可用内存划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还存活的复制到另一块上，然后将这一块一次性清除。商业虚拟机都是采用该方法来回收新生代，新生代98%都是朝生夕死的。将内存分为较大Eden和两个较小的survivor空间。每次使用其中一块Eden和survivor，回收时将存活的对象一次性地复制到另一块survivor中，再清理掉之前的。HotSpot虚拟机Eden与Survivor默认的大小比例为8:1:1。survivor空间不够时，需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。 3.标记整理算法 复制在对象存活率较高时效率很低。根据老年代的特点提出该算法。标记过程同标记清除一样，但不是直接对可回收对象进行清理，而是让存活对象朝着一端移动，然后直接清理掉端边界外的内存。 4.分代收集算法 根据各年代特点分别采用最适当的GC算法。在新生代:中每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。在老年代: 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。即： 新生代：存活率低，使用复制算法 老年代：存活率高，使用“标记-整理”或“标记-清除”算法 五 Hotspot算法实现及准确式GC 上面讲到了Java虚拟机是如何利用可达性算法判断对象是否需要回收的，由于在GC进行时，必须暂停所有的Java执行线程（Sun称之为“Stop The World”），所以，虚拟机必须尽量的优化GC过程的效率，减少暂停的时间。那么对于GC Roots，HotSpot是如何快速确定的呢？ 对象的创建首先，我们需要知道在JVM中，对象是如何被创建的。 而对象的创建通常是通过new一个对象而已，当虚拟机接收到一个new指令时，它会做如下的操作: 1 判断对象对应的类是否加载、链接、初始化虚拟机接收到一条new指令时，首先会去检查这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被类加载器加载、链接和初始化过。如果没有则先执行相应的类加载过程。关于类加载器我们在前一篇文章中已经提到过，这里不再赘述。 2为对象分配内存类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式： 指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。 空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。 3处理并发安全问题创建对象是一个非常频繁的操作，所以需要解决并发的问题，有两种方式： 对分配内存空间的动作进行同步处理，比如在虚拟机采用CAS算法并配上失败重试的方式保证更新操作的原子性。 每个线程在Java堆中预先分配一小块内存，这块内存称为本地线程分配缓冲（Thread Local Allocation Buffer）简写为TLAB，线程需要分配内存时，就在对应线程的TLAB上分配内存，当线程中的TLAB用完并且被分配到了新的TLAB时，这时候才需要同步锁定。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。 4初始化分配到的内存空间将分配到的内存，除了对象头都初始化为零值。 5设置对象的对象头将对象的所属类、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中。 6执行init方法进行初始化执行init方法，初始化对象的成员变量、调用类的构造方法，这样一个对象就被创建了出来。 对象的堆内存布局在HotSpot虚拟机中，对象在堆内存的布局分为三个区域，分别是对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。 对象头：对象头包括两部分信息分别是Mark World和元数据指针，Mark World用于存储对象运行时的数据，比如HashCode、锁状态标志、GC分代年龄等。而元数据指针用于指向方法区的中目标类的类型信息，通过元数据指针可以确定对象的具体类型。 实例数据：用于存储对象中的各种类型的字段信息（包括从父类继承来的）。 对齐填充：对齐填充不一定存在，起到了占位符的作用，没有特别的含义。 对象分配如下图所示： HotSpot的对象模型HotSpot中采用了OOP-Klass模型，它是用来描述Java对象实例的一种模型，OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 HotSpot中，用instanceOopDesc 和 arrayOopDesc 来描述对象头，其中arrayOopDesc对象用于描述数组类型。 通过OOP-Klass模型，我们就知道了Java虚拟机是如何通过栈帧中的对象引用找到对应的对象实例，如下图所示： 从图中可以看出，通过栈帧中的对象引用找到Java堆中的instanceOopDesc对象，再通过instanceOopDesc中的元数据指针来找到方法区中的instanceKlass，从而确定该对象的具体类型。 HotSpot的准确式GCHotSpot采用了准确式GC以提升GC roots的枚举速度。所谓准确式GC，就是让JVM知道内存中某位置数据的类型什么。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。 HotSpot是利用OopMap来实现准确式GC的。当类加载完成后，HotSpot 就将对象内存布局之中什么偏移量上数值是一个什么样的类型的数据这些信息存放到 OopMap 中；在 HotSpot 的 JIT 编译过程中，同样会插入相关指令来标明哪些位置存放的是对象引用等，这样在 GC 发生时，HotSpot 就可以直接扫描 OopMap 来获取对象引用的存储位置，从而进行 GC Roots 枚举。 HotSpot安全点通过OopMap，HotSpot可以很快完成GC Roots的查找，但是，如果在每一行代码都有可能发生GC，那么也就意味着得为每一行代码的指令都生成OopMap，这样将占用大量的空间。实际上，HotSpot也不会这么做。 HotSpot只在特定的位置记录了OopMap，这些位置就叫做安全点（Safepoint），也就是说，程序并不能在任意地方都可以停下来进行GC，只有到达安全点时才能暂停进行GC。 在安全点中，HotSpot也会开始记录虚拟机的相关信息，如OopMap信息的录入。安全点的选择不能太少，否则GC等待时间太长；也不能太多，否则会增大运行负荷，其选择的原则为“是否具有让程序长时间执行的特征”，如方法调用，循环等等。具体安全点有下面几个： (1) 循环的末尾 (防止大循环的时候一直不进入Safepoint，而其他线程在等待它进入Safepoint)(2) 方法返回前(3) 调用方法的call之后(4) 抛出异常的位置 而安全点暂停线程运行的手段有两种：抢先式中断和主动式中断。 抢先式中断不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上再暂停。不过现在的虚拟机几乎没有采用此算法的。 主动式中断GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时去主动轮询查询此标志，发现中断标志为真时就中断自己挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 HotSpot安全区域产生原因安全点机制保证了程序执行时进入GC的问题。但是对于非执行态下，如线程Sleep或者Block下，由于此时程序（线程）无法响应JVM的中断请求，JVM也不太可能一直等待线程重新获取时间片，此时就需要安全区域(Safe Region)了。安全区域是指在一段代码片段内，引用关系不会发生变化，在这段区域内，任意地方开始GC都是安全的。 运行机理在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了；当线程要离开Safe Region时，如果整个GC完成，那线程可继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止。 六 七种垃圾收集器重点笔记： 并行（Parallel）：多条垃圾收集线程 并发（Concurrent）：用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户线程在继续运行，而垃圾收集程序运行于另外一个CPU上。 新生代：Serial收集器 ParNew收集器 Parallel Scavenge收集器 老年代：Serial Old收集器 Parallel Old收集器 CMS收集器 新生代垃圾收集器1.Serial收集器 最悠久，最基本的收集器；单线程收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，且在收集时，必须暂停其他所有的工作线程，直到收集结束。新生代采取复制算法。老年代采取标记整理算法。在进行垃圾收集时必须暂停其他所有的工作线程，即“Stop The World”。依然是虚拟机运行在Client模式下的默认新生代收集器。Serial一般在单核的机器上使用，是Java 5非服务端JVM的默认收集器。 新生代：单线程复制收集算法； 老年代：单线程标记整理算法。 参数-XX:UseSerialGC设置使用 优势：对于单CPU环境来说，Serial收集器没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集。Serial收集器对于在Client模式下的虚拟机是一个很好的选择。 2.ParNew收集器 Serial收集器的多线程版。多条线程进行垃圾收集，采用复制算法。其余和Serial收集器一样。目前唯一能与CMS收集器配合工作。ParNew收集器在单CPU环境中不比Serial效果好，甚至可能更差，两个CPU也不一定跑的过，但随着CPU数量的增加，性能会逐步增加。默认开启的收集线程数与CPU数量相同。在CPU数量很多的情况下，可以使用-XX:ParallelGCThreads参数来限制线程数。 新生代并行，老年代串行 新生代复制算法、老年代标记-整理 参数控制：-XX:+UseConcMarkSweepGC”：指定使用CMS后，会默认使用ParNew作为新生代收集器；-XX:+UseParNewGC”：强制指定使用ParNew；-XX:ParallelGCThreads”：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同； 优势：ParNew收集器是许多运行在server模式下的虚拟机中首选的新生代收集器，一个重要的原因是，只有ParNew和Serial收集器能和CMS收集器共同工作。无法与JDK1.4中存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew和Serial。 3.Parallel Scavenge收集器 新生代收集器，多线程并行、使用复制算法。 CMS的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而PS收集器的目的则是达到一个可控制的吞吐量。吞吐量即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间））。 使用-XX:MaxGCPauseMillus参数控制垃圾停顿时间 使用-XX:GCTimeRatio参数控制吞吐量。 Parallel Scavenge收集器设置-XX:UseAdaptiveSizePolicy参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量（GC自使用的调节策略）。自适应调节策略也是Parallel Scavenge收集器和ParNew收集器一个重要的区别。 老年代垃圾收集器4.Serial Old收集器 Serial Old同样是单线程收集器,使用“标记-整理”算法。可以与JDK1.5及之前的Parallel Scavenge搭配使用；也可以作为CMS收集器的后备预案，在并发收集发生Concureent Mode Failure时使用。 5.Parallel Old收集器 Parallel Old收集器是多线程，使用“标记-整理”算法。 JDK1.6前，Parallel Scavenge只能与老年代收集器Serial Old（PS MarkSweep）组合，由于Serial Old无法充分利用服务器多CPU的处理能力，会拖累整体性能。 JDK1.6后，Parallel Scavenge可与Parallel Old组合，达到名副其实的“吞吐量优先”，在注重吞吐量以及CPU资源敏感的场合可以优先考虑这个组合。 6.CMS收集器 基于“标记—清除”算法，低停顿，并发收集。以获取最短回收停顿时间、低延迟为目标，适用于重视服务响应速度的应用。 主要过程为一下四步： 初始标记；Stop the World，仅标记GCRoots能关联的对象，速度很快。 并发标记；进行GCRootsTracing的过程。 重新标记；修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比1长但远比2短。 并发清除；并发清除与并发标记耗时最长。收集器线程都可以与用户线程一起工作。并发清理以后重置线程。 CMS收集器的内存回收过程是与用户线程一起并发执行的 主要缺点： CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是因为占用了一部分CPU资源而导致应用程序变慢，总吞吐量就会降低。CMS默认启动的回收线程数为(CPU数量+3)/4。当CPU的个数少于2个的时候，CMS对用户程序的影响可能会变得很大。 CMS收集器无法处理浮动垃圾（floating garbage），可能会出现concurrent mode failure导致另一次full gc的产生。在CMS的并发清理阶段，由于程序还在运行，垃圾还会不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留到下一次GC再处理。这种垃圾称为浮动垃圾。同样由于CMS GC阶段用户线程还需要运行，即还需要预留足够的内存空间供用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被灌满了再进行收集而需要预留一部分空间提供并发收集时的程序运作使用。默认设置下 CMS收集器在老年代使用了68%的空间后就会被激活。这个值可以用-XX:CMSInitiatingOccupancyFraction来设置。要是CMS运行期间预留的内存无法满足程序需要，就会出现concurrent mode failure，这时候就会启用Serial Old收集器作为备用进行老年代的垃圾收集。 空间碎片过多（标记-清除算法的弊端），CMS是基于标记-清除算法来实现的回收器，提供-XX:+UseCMSCompactAtFullCollection参数，应用于在FULL GC后再进行一个碎片整理过程。-XX:CMSFullGCsBeforeCompaction,多少次不压缩的full gc后来一次带压缩的。 整堆收集器7.G1收集器 G1收集器（Garbage-First）：是当今收集器技术发展的最前沿的成果之一，G1是一款面向服务器端应用的垃圾收集器。 使用G1收集器时，java堆的内存布局就与其他收集器有很大差别，它将真个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代与老年代的概念，但新生代与老年代不再试物理隔离的了，他们都是一部分Region（不需要连续）的集合。G1具备如下特点： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能够独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记–整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这个特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前出发下一次GC。 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时java（RTSJ）的垃圾收集器的特性了。 初始标记（Initial Marking）：标记GC Roots能够直接关联到的对象，并且修改TAMS的值，能在正确可用的Region中创建对象，这阶段需要停顿线程，而且耗时很短。并发标记（Concurrent Marking）：从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这个时间耗时比较长，但可与用户程序并行执行。 最终标记（Final Marking）：为了修正和正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分没有标记记录，虚拟机将这一段对象变法记录在线程Rememberred Set logs里面，最终标记阶段需要把Remembered Set logs 的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并发执行。 筛选回收（Live Data Counting and Evacuation）：对各个Region的回收截止和成本进行排序，根据用户期望的GC停顿时间来制定回收计划，这阶段可以做到和用户程序一起并发执行，但是因为值回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高手机效率。 内存分配与回收策略重点笔记： 新生代GC（Minor GC）：发生在新生代的垃圾收集动作，非常频繁，一般回收速度也比较快。 老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作，一般会伴随Minor GC 速度一般比Minor GC慢上10倍以上。 优先在Eden区分配（如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）如果Eden区满，则触发一次Minor GC 大对象直接进入老年代；大对象，即大量连续内存空间的Java对象，最典型的是那种很长的字符串及数组。 长期存活的对象将进入老年代；设置对象年龄计数器。对象在Eden出生并经过第一次MinorGC后仍存活，年龄+1，移入Survivor区。以后每经过一次MinorGC年龄加一，当达到15时（默认的）就进入老年代 动态对象年龄判定，并不是对象年龄必须达到最大阈值才会进入老年代。如果survivor空间中相同年龄所有对象大小总和大于其空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到阈值时才进入。 空间分配担保；发生minorGC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立，MinorGC可以确保是安全的。不成立，则检查HandlePromotionFailure设置值是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。大于将尝试MinorGC，小于或者不允许冒险，也要进行一次FullGC。老年代分配担保，将survivor无法容纳的对象直接进入老年代。依然担保失败，则只好在失败后重新发起一次Full GC。 参考链接： 1234https://blog.csdn.net/u013667756/article/details/82948012https://www.jianshu.com/p/9d09f93001e4https://blog.csdn.net/u012998254/article/details/81635902https://blog.csdn.net/u012998254/article/details/81635902]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
        <tag>内存分配策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的文件权限与目录配置]]></title>
    <url>%2F2019%2F08%2F29%2FLinux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、Linux 文件属性1.1、用户和组Linux 系统中的目录和文件的访问身份分为 user，group， others 分别简写为 u， g ， o 。 user：文件的所有者 group：文件所有者所在组 others ：不在所有者的所在组的其他用户 all：代表所有用户， 简写为 a 每个身份对文件的权限又分为 : read ， write ， execute， 分别简写为 : r，w ，x， 数字表示分别为 : 4， 2， 1。 1.2、文件详细信息Linux 文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。 ls -al 查看文件详细信息： drwxr-xr-x 5 root root 4096 Apr 23 14:49 . drwxr-xr-x 18 root root 4096 Apr 28 16:36 .. drwxr-xr-x 4 root root 4096 Apr 23 14:49 master drwxr-xr-x 3 root root 4096 Apr 23 14:49 spark1 drwxr-xr-x 3 root root 4096 Apr 23 14:49 spark2 1.2.1、第一栏：类型与权限 第一个字符代表这个文件的类型(如目录、文件或链接文件等等)： 当为[ d ]则是目录 当为[ - ]则是文件 若是[ l ]则表示为链接文件(link file) 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合： [ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute) ，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 第一组为『文件拥有者的权限，第二组为『同群组的权限』，第三组为『其他非本群组的权限』。 1.2.2、第二栏：多少档名连结到此节点(i-node)每个文件都会将他的权限与属性记录到文件系统的 i-node 中，不过，我们使用的目录树却是使用文件名来记录， 因此每个文件名就会链接到一个 i-node。这个属性记录的，就是有多少不同的文件名链接到相同的一个 i-node 号码。 1.2.3、第三栏：文件(或目录)的拥有者1.2.4、第四栏：文件的所属群组1.2.5、第五栏：文件的容量大小(默认单位为 bytes )1.2.6、第六栏：文件的建档日期或者是最近的修改日期1.2.7、第七栏：文件的全路径及其文件名这个字段就是档名。 比较特殊的是：如果档名之前多一个“.” ，则代表这个文件为隐藏档。 二、修改文件属性和权限2.1、chgrp ：改变文件所属群组12345678chgrp [-R] dirname/filename ...选项与参数：-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。范例：chgrp users initial-setup-ks.cfg 2.2、chown ：改变文件拥有者1234567chown [-R] 帐号名称 文件或目录选项与参数：-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都变更范例：将 initial-setup-ks.cfg 的拥有者改为bin这个帐号：chown bin initial-setup-ks.cfg 2.3、chmod ：改变文件的权限权限的设置方法有两种， 分别可以使用数字或者是符号来进行权限的变更。 2.3.1、数字类型改变文件权限Linux文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己的 read/write/execute 权限。 各权限的分数对照表如下： r:4 &gt; w:2 &gt; x:1 每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 &gt; group = rwx = 4+2+1 = 7 &gt; others= — = 0+0+0 = 0 变更权限的指令 chmo的语法是这样的： 12345chmod [-R] xyz 文件或目录选项与参数：xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都会变更 2.3.2、符号类型改变文件权限基本上就九个权限分别是（1）user （2）group （3）others 三种身份。那么就可以借由 u， g， o 来代表三种身份的权限！此外， a 则代表 all 亦即全部的身份！ 可以使用下面的方式来看： | chmod | u g o a | +（加入） -（除去） =（设置） | r w x | 文件或目录 | 123chmod u=rwx,go=rx .bashrc那个 u=rwx,go=rx 是连在一起的，中间并没有任何空白字符！ 如果是要将权限去掉而不更动其他已存在的权限，例如要拿掉全部人的可执行权 限，则： 1chmod a-x .bashrc 2.3.3 目录与文件的权限意义 能不能进入某一个目录，只与该目录的x权限有关。如果在某目录的下不具有x权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何命令，即使你具有该目录下的r权限。但是不能随便给w权限。 三、Linux 文件种类与扩展名3.1、文件种类3.1.1、正规文件（regular file ）ls -al 所显示出来的属性方面，第一个字符为 [ - ]。 可以分为： 纯文本文件（ASCII）：这是 Linux 系统中最多的一种文件类型， 称为纯文本文件，内容为我们人类可以直接读到的数据，例如数字、字母等等。 二进制档（binary）：Linux当中的可执行文件。 数据格式文件（data）：有些程序在运行的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 （data file）。举例来说，Linux 在使用者登陆时，都会将登录的数据记录在 /var/log/wtmp 那个文件内，该文件是一个 data file，他能够通过 last 这个指令读出来！ 但是使用cat时，会读出乱码。 3.1.2、目录（directory）目录，第一个属性为 [ d ]。 3.1.3、链接文件（link）第一个属性为 [ l ]。 就是类似 Windows 系统下面的快捷方式！ 3.1.4、设备与设备文件（device）与系统周边及储存等相关的一些文件， 通常都集中在 /dev 这个目录之下！通常又分为两种： 区块（block）设备文件 ：就是一些储存数据， 以提供系统随机存取的周边设备，举例来说，硬盘与软盘等就是。第一个属性为[ b ]。 字符（character）设备文件：亦即是一些序列埠的周边设备， 例如键盘、鼠标等等！这些设备的特色就是“一次性读取”的，不能够截断输出。 第一个属性为 [ c ]。 3.1.5、数据接口文件（sockets）第一个属性为 [ s ]。 这种类型的文件通常被用在网络上的数据承接。可以启动一个程序来监听用户端的要求， 而用户端就可以通过这个 socket 来进行数据的沟通了。 最常在 /run 或 /tmp 这些个目录中看到这种文件类型了。 3.1.6、数据输送档（FIFO, pipe）第一个属性为[p] FIFO也是一种特殊的文件类型，主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO 是 first-in-first-out 的缩写。 四、Linux 目录配置根据 FHS（Filesystem Hierarchy Standard ）的标准文件指出每个特定的目录下应该要放置什么样子的数据。 FHS 依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态： 可分享的：可以分享给其他系统挂载使用的目录，所以包括可执行文件与使用者的邮件等数据， 是能够分享给网络上其他主机挂载用的目录。 不可分享的：自己机器上面运行的设备文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函数库、文件说明文档、系统管理员所管理的主机服务配置文件等等。 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻群组等。 事实上，FHS 针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义： / （root, 根目录）：与开机系统有关 /usr （unix software resource）：与软件安装/执行有关 /var （variable）：与系统运行过程有关 4.1、根目录 （/） 的意义与内容根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函数库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区内， 因为越大的分区你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。 FHS 标准建议：根目录（/）所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但性能较佳，根目录所在的文件系统也较不容易发生问题。 鉴于上述的说明，因此 FHS 定义出根目录(/)底下应该要有底下这些次目录的存在才好： 目录 应放置文件内容 /bin 系统有很多放置执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot 这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机选单与开机所需配置文件等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub这个开机管理程序， 则还会存在/boot/grub/这个目录喔！ /dev 在Linux系统上，任何装置与接口设备都是以文件的型态存在于这个目录当中的。 你只要透过存取这个目录底下的某个文件，就等于存取某个装置啰～ 比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/lp, /dev/hd, /dev/sd*等等 /etc 系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中喔。比较重要的文件有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等。另外，其下重要的目录有： /etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话：『 /etc/init.d/iptables start』、『/etc/init.d/iptables stop』 /etc/xinetd.d/：这就是所谓的super daemon管理的各项服务的配置文件目录。 /etc/X11/：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。 /home 这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时， 默认的用户家目录都会规范到这里来。比较重要的是，家目录有两种代号喔： ~：代表目前这个用户的家目录，而 ~dmtsai ：则代表 dmtsai 的家目录！ /lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库， 以及在/bin或/sbin底下的指令会呼叫的函式库而已。 什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。 尤其重要的是/lib/modules/这个目录， 因为该目录会放置核心相关的模块(驱动程序)喔！ /media media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软盘、光盘、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 /opt 这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软件(非原本的distribution提供的)，那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ /root 系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。 /sbin Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srv srv可以视为『service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！ 底下是几个在 Linux 当中也是非常重要的目录： 目录 应放置文件内容 /lost+found 这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在， 例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』 /proc 这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中， 例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。 /sys 这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量喔！ 根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分割槽则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分割槽去！那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件 这五个目录千万不可与根目录分开在不同的分割槽！ 4.2、/usr 的意义与内容/usr 里面放置的数据属于可分享的与不可变动的(shareable, static)，/usr 可以分享给区域网络内的其他主机来使用。 usr 是 Unix Software Resource 的缩写， 也就是『Unix操作系统软件资源』。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。 因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似 Windows 系统的『C:\Windows\ + C:\Program files\』这两个目录的综合体。 /usr的次目录建议有底下这些： 目录 应放置文件内容 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里！请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档喔！ /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生喔！ /usr/local/ 系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！ /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)啰！ /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛！在此目录下常见的还有这些次目录： /usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 4.3、/var 的意义与内容/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有： 目录 应放置文件内容 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档； /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！ /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。 /var/log/ 重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！ /var/run/ 某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！ 至于PID的意义我们会在后续章节提到的。 /var/spool/ 这个目录通常放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux文件权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码阅读之ReentrantLock]]></title>
    <url>%2F2019%2F07%2F16%2FJDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BReentrantLock%2F</url>
    <content type="text"><![CDATA[概述 ReentrantLock是一个可重入的互斥锁，也被称为“独占锁”。在上一篇讲解AQS的时候已经提到，“独占锁”在同一个时间点只能被一个线程持有；而可重入的意思是，ReentrantLock可以被单个线程多次获取。 ReentrantLock又分为“公平锁(fair lock)”和“非公平锁(non-fair lock)”。它们的区别体现在获取锁的机制上：在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”机制下，如果锁是可获取状态，不管自己是不是在队列的head节点都会去尝试获取锁。reentrantLock默认是非公平锁 数据结构与核心参数 ​ ReetrantLock继承关系 可以看到ReetrantLock继承自AQS，并实现了Lock接口。Lock源码如下： 1234567891011121314public interface Lock &#123; //获取锁，如果锁不可用则线程一直等待 void lock(); //获取锁，响应中断，如果锁不可用则线程一直等待 void lockInterruptibly() throws InterruptedException; //获取锁，获取失败直接返回 boolean tryLock(); //获取锁，等待给定时间后如果获取失败直接返回 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //释放锁 void unlock(); //创建一个新的等待条件 Condition newCondition();&#125; 在Lock提供的获取锁方法中，有lock()、lockInterruptibly()、tryLock()和tryLock(long time, TimeUnit unit)四种方式，他们的区别如下： lock() 获取失败后，线程进入等待队列自旋或休眠，直到锁可用，并且忽略中断的影响 lockInterruptibly() 线程进入等待队列park后，如果线程被中断，则直接响应中断（抛出InterruptedException） tryLock() 获取锁失败后直接返回，不进入等待队列 tryLock(long time, TimeUnit unit) 获取锁失败等待给定的时间后返回获取结果 ReetrantLock通过AQS实现了自己的同步器Sync，分为公平锁FairSync和非公平锁NonfairSync。在构造时，通过所传参数boolean fair来确定使用那种类型的锁。 本篇会以对比的方式分析两种锁的源码实现方式。 源码解析lock()lock()方法用于获取锁，两种类型的锁源码实现如下： 1234567891011121314151617//获取锁，一直等待锁可用public void lock() &#123; sync.lock();&#125;//公平锁获取final void lock() &#123; acquire(1);&#125;//非公平锁获取final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 说明：公平锁的lock方法调用了AQS的acquire(1)；而非公平锁则直接通过CAS修改state值来获取锁，当获取失败时才会调用acquire(1)来获取锁。 关于acquire()方法，在上篇介绍AQS的时候已经讲过，印象不深的同学可以翻回去看一下，这里主要来看一下tryAcquire在ReetrantLock中的实现。 公平锁tryAcquire： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState();//获取锁状态state if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; //判断当前线程是否还有前节点 compareAndSetState(0, acquires)) &#123;//CAS修改state //获取锁成功，设置锁的持有线程为当前线程 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123;//当前线程已经持有锁 int nextc = c + acquires;//重入 if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc);//更新state状态 return true; &#125; return false;&#125; 说明：公平锁模式下的tryAcquire，执行流程如下： 如果当前锁状态state为0，说明锁处于闲置状态可以被获取，首先调用hasQueuedPredecessors方法判断当前线程是否还有前节点(prev node)在等待获取锁。如果有，则直接返回false；如果没有，通过调用compareAndSetState（CAS）修改state值来标记自己已经拿到锁，CAS执行成功后调用setExclusiveOwnerThread设置锁的持有者为当前线程。程序执行到现在说明锁获取成功，返回true； 如果当前锁状态state不为0，但当前线程已经持有锁（current == getExclusiveOwnerThread()），由于锁是可重入（多次获取）的，则更新重入后的锁状态state += acquires 。锁获取成功返回true。 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; hasQueuedPredecessors源码如上，如果在该队列中还有Node结点（即还有等待的线程），那么就返回true，否则返回false。 非公平锁tryAcquire 12345678910111213141516171819202122//非公平锁获取protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123;//CAS修改state setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires;//计算重入后的state if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 说明：通过对比公平锁和非公平锁tryAcquire的代码可以看到，非公平锁的获取略去了!hasQueuedPredecessors()这一操作，也就是说它不会判断当前线程是否还有前节点(prev node)在等待获取锁，而是直接去进行锁获取操作。 unlock()1234//释放锁public void unlock() &#123; sync.release(1);&#125; 说明：关于release()方法，在上篇介绍AQS的时候已经讲过，印象不深的同学可以翻回去看一下，这里主要来看一下tryRelease在ReetrantLock中的实现： 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases;//计算释放后的state值 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true;//锁全部释放，可以唤醒下一个等待线程 setExclusiveOwnerThread(null);//设置锁持有线程为null &#125; setState(c); return free;&#125; 说明：tryRelease用于释放给定量的资源。在ReetrantLock中每次释放量为1，也就是说，在可重入锁中，获取锁的次数必须要等于释放锁的次数，这样才算是真正释放了锁。在锁全部释放后（state==0）才可以唤醒下一个等待线程。 等待条件Condition 在上篇介绍AQS中提到过，在AQS中不光有等待队列，还有一个条件队列，这个条件队列就是我们接下来要讲的Condition。 Condition的作用是对锁进行更精确的控制。Condition中的await()、signal()、signalAll()方法相当于Object的wait()、notify()、notifyAll()方法。不同的是，Object中的wait()、notify()、notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与Lock捆绑使用的。 Condition函数列表 1234567891011121314151617181920//使当前线程在被唤醒或被中断之前一直处于等待状态。void await()//使当前线程在被唤醒、被中断或到达指定等待时间之前一直处于等待状态。boolean await(long time, TimeUnit unit)//使当前线程在被唤醒、被中断或到达指定等待时间之前一直处于等待状态。long awaitNanos(long nanosTimeout)//使当前线程在被唤醒之前一直处于等待状态。void awaitUninterruptibly()//使当前线程在被唤醒、被中断或到达指定最后期限之前一直处于等待状态。boolean awaitUntil(Date deadline)//唤醒一个等待线程。void signal()//唤醒所有等待线程。void signalAll() 下面我们来看一下Condition在AQS中的实现 await()123456789101112131415161718192021//使当前线程在被唤醒或被中断之前一直处于等待状态。public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter();//添加并返回一个新的条件节点 int savedState = fullyRelease(node);//释放全部资源 int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //当前线程不在等待队列，park阻塞 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) //线程被中断，跳出循环 break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters();//解除条件队列中已经取消的等待节点的链接 if (interruptMode != 0) reportInterruptAfterWait(interruptMode);//等待结束后处理中断&#125; 说明： await()方法相当于Object的wait()。把当前线程添加到条件队列中调用LockSupport.park()阻塞，直到被唤醒或中断。函数流程如下： 首先判断线程是否被中断，如果是，直接抛出InterruptedException，否则进入下一步； 添加当前线程到条件队列中，然后释放全部资源/锁; 如果当前节点不在等待队列中，调用LockSupport.park()阻塞当前线程，直到被unpark或被中断。这里先简单说一下signal方法，在线程接收到signal信号后，unpark当前线程，并把当前线程转移到等待队列中（sync queue）。所以，在当前方法中，如果线程被解除阻塞（unpark），也就是说当前线程被转移到等待队列中，就会跳出while循环，进入下一步； 线程进入等待队列后，调用acquireQueued方法获取锁； 调用unlinkCancelledWaiters方法检查条件队列中已经取消的节点，并解除它们的链接（这些取消的节点在随后的垃圾收集中被回收掉）； 逻辑处理结束，最后处理中断（抛出InterruptedException或把忽略的中断补上）。 signal()1234567891011121314151617181920212223242526272829303132333435//唤醒线程public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);//唤醒条件队列的首节点线程&#125;//从条件队列中移除给定节点，并把它转移到等待队列private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; //解除首节点链接 &#125; while (!transferForSignal(first) &amp;&amp; //接收到signal信号后，把节点转入等待队列 (first = firstWaiter) != null);&#125;//接收到signal信号后，把节点转入等待队列final boolean transferForSignal(Node node) &#123; /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) //CAS修改状态失败，说明节点被取消，直接返回false return false; Node p = enq(node);//添加节点到等待队列，并返回节点的前继节点(prev) int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) //如果前节点被取消，说明当前为最后一个等待线程，unpark唤醒当前线程 LockSupport.unpark(node.thread); return true;&#125; 说明：signal方法用于发送唤醒信号。在不考虑线程争用的情况下，执行流程如下： 获取条件队列的首节点，解除首节点的链接（first.nextWaiter = null;）； 调用transferForSignal把条件队列的首节点转移到等待队列的尾部。在transferForSignal中，转移节点后，转移的节点没有前继节点，说明当前最后一个等待线程，直接调用unpark()唤醒当前线程。 Condition的其他例如awaitNanos(long nanosTimeout)、signalAll()等方法这里这里就不多赘述了，执行流程都差不多，同学们可以参考上述分析阅读。 synchronized和ReentrantLock的选择 ReentrantLock在加锁和内存上提供的语义与内置锁synchronized相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。从性能方面来说，在JDK5的早期版本中，ReentrantLock的性能远远好于synchronized，但是从JDK6开始，JDK在synchronized上做了大量优化，使得两者的性能差距不大。synchronized的优点就是简洁。 所以说，两者之间的选择还是要看具体的需求，ReentrantLock可以作为一种高级工具，当需要一些高级功能时可以使用它。]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>ReentrantLock</tag>
        <tag>JUC</tag>
        <tag>可重入锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析之AQS]]></title>
    <url>%2F2019%2F07%2F06%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BAQS%2F</url>
    <content type="text"><![CDATA[AQS概述 AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。 AQS解决了子实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。 AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 AQS支持独占锁（Exclusive）和共享锁（Share）两种模式： 独占锁：只能被一个线程获取到(ReentrantLock)； 共享锁：可以被多个线程同时获取(CountDownLatch、ReadWriteLock的读锁)。 不管是独占锁还是共享锁，本质上都是对AQS内部的一个变量state的获取，state是一个原子性的int变量，可用来表示锁状态、资源数等，如下图。 1234/** * The synchronization state. */ private volatile int state; AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。变量使用volatile修饰，表示每一次更新都会及时的刷到主存中。 数据结构与结构参数AQS的内部实现了两个队列，一个同步队列和一个条件队列 条件队列是为Lock实现的一个基础同步器，并且一个线程可能会有多个条件队列，只有在使用了Condition才会存在条件队列。 同步队列的作用是，在线程获取资源失败后，进入同步队列队尾保持自旋等待状态， 在同步队列中的线程在自旋时会判断其前节点是否为head节点，如果为head节点则不断尝试获取资源/锁，获取成功则退出同步队列。当线程执行完逻辑后，会释放资源/锁，释放后唤醒其后继节点。同步队列与条件队列的关系 首先展示同步队列与条件队列的结构图，如下： 同步队列节点来源： 同步队列依赖一个双向链表来完成同步状态的管理，当前线程获取同步状态失败 后，同步器会将线程构建成一个节点，并将其加入同步队列中。 通过signal或signalAll将条件队列中的节点转移到同步队列。（由条件队列转化为同步队列） 条件队列节点来源： 调用await方法阻塞线程； 当前线程存在于同步队列的头结点，调用await方法进行阻塞（从同步队列转化到条件队列） 可总结为： 同步队列与条件队列节点可相互转化 一个线程只能存在于两个队列中的一个 实例说明 假设初始状态如下，节点A、节点B在同步队列中。 节点A的线程获取锁权限，此时调用await方法。节点A从同步队列移除， 并加入条件队列中。 调用 signal方法，从条件队列中取出第一个节点，并加入同步队列中，等待获取资源 以上三个说明实例用图片形式解释了同步队列与条件队列节点可相互转化 。需要注意的是同步队列中，头结点head与尾节点tail被放在一个同步器中，也就是Node节点。不管是同步队列还是条件队列，其内部都是由节点Node组成，首先介绍下AQS的内部类Node，主要源码如下： 12345678910111213141516171819202122232425262728static final class Node &#123; /** * Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** * Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; //取消 static final int CANCELLED = 1; //等待触发 static final int SIGNAL = -1; //等待条件 static final int CONDITION = -2; //状态需要向后传播 static final int PROPAGATE = -3;/** 等待状态 */ volatile int waitStatus; /** 前驱节点 */ volatile Node prev; /** 后继节点 */ volatile Node next; /** 获取同步状态的线程 */ volatile Thread thread; Node nextWaiter;&#125; 说明：Node的实现很简单，就是一个普通双向链表的实现，这里主要说明一下内部的几个等待状态： CANCELLED：值为1，当前节点由于超时或中断被取消。 SIGNAL：值为-1，表示当前节点的前节点被阻塞，当前节点在release或cancel时需要执行unpark来唤醒后继节点。 CONDITION：值为-2，当前节点正在等待Condition，这个状态在同步队列里不会被用到。 PROPAGATE：值为-3，(针对共享锁) releaseShared()操作需要被传递到其他节点，这个状态在doReleaseShared中被设置，用来保证后续节点可以获取共享资源。 0：初始状态，当前节点在sync queue中，等待获取锁。 AQS主要提供了如下一些方法： getState()：返回同步状态的当前值； setState(int newState)：设置当前同步状态； compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性； tryAcquire(int arg)：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态； tryRelease(int arg)：独占式释放同步状态； tryAcquireShared(int arg)：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败； tryReleaseShared(int arg)：共享式释放同步状态； isHeldExclusively()：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占； acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法； acquireInterruptibly(int arg)：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回； tryAcquireNanos(int arg,long nanos)：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true； acquireShared(int arg)：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态； acquireSharedInterruptibly(int arg)：共享式获取同步状态，响应中断； tryAcquireSharedNanos(int arg, long nanosTimeout)：共享式获取同步状态，增加超时限制； release(int arg)：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒； releaseShared(int arg)：共享式释放同步状态； 源码分析acquire(int)123456//独占模式获取资源public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 说明：独占模式下获取资源/锁，忽略中断的影响。内部主要调用了三个方法，其中tryAcquire需要自定义实现。后面会对各个方法进行详细分析。acquire方法流程如下： tryAcquire() 尝试直接获取资源，如果成功则直接返回，失败进入第二步； addWaiter() 获取资源失败后，将当前线程加入等待队列的尾部，并标记为独占模式； acquireQueued() 使线程在等待队列中自旋等待获取资源，一直获取到资源后才返回。如果在等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断(interrupt)是不响应的，在获取资源成功之后根据返回的中断状态调用selfInterrupt()方法再把中断状态补上。 tryAcquire(int)123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：尝试获取资源，成功返回true。具体资源获取/释放方式交由自定义同步器实现。ReentrantLock中公平锁和非公平锁的实现如下: 123456789101112131415161718192021222324252627282930313233343536373839//公平锁protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125;//非公平锁final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 3.1.2 addWaiter(Node)1234567891011121314151617181920212223242526272829303132//添加等待节点到尾部private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure //尝试快速入队 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125;//插入给定节点到队尾private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 说明：获取独占锁失败后，将当前线程加入等待队列的尾部，并标记为独占模式。返回插入的等待节点。 3.1.3 acquireQueued(Node,int)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//自旋等待获取资源final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor();//获取前继节点 //前继节点为head，说明可以尝试获取资源 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node);//获取成功，更新head节点 p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //检查是否可以park parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;//获取资源失败后，检查并更新等待状态private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ //如果前节点取消了，那就一直往前找到一个等待状态的节点，并排在它的后边 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ //此时前节点状态为0或PROPAGATE，表示我们需要一个唤醒信号，但是不立即park,在park前调用者需要重试来确认它不能获取资源。 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;//阻塞当前线程，返回中断状态private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 说明：线程进入等待队列后，在等待队列中自旋等待获取资源。如果在整个等待过程中被中断过，则返回true，否则返回false。具体流程如下： 获取当前等待节点的前继节点，如果前继节点为head，说明可以尝试获取锁； 调用tryAcquire获取锁，成功后更新head为当前节点； 获取资源失败，调用shouldParkAfterFailedAcquire方法检查并更新等待状态。如果前继节点状态为SIGNAL，说明当前节点可以进入waiting状态等待唤醒；被唤醒后，继续自旋重复上述步骤。 获取资源成功后返回中断状态。 当前线程通过parkAndCheckInterrupt()阻塞之后进入waiting状态，此状态下可以通过下面两种途径唤醒线程： 前继节点释放资源后，通过unparkSuccessor()方法unpark当前线程； 当前线程被中断。 3.2 release(int)12345678910/**独占模式释放资源*/public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123;//尝试释放资源 Node h = head;//头结点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);//唤醒head的下一个节点 return true; &#125; return false;&#125; 说明：独占模式下释放指定量的资源，成功释放后调用unparkSuccessor唤醒head的下一个节点。 3.2.1 tryRelease(int)123protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：和tryAcquire()一样，这个方法也需要自定义同步器去实现。一般来说，释放资源直接拿state减去给定的参数arg，释放后state==0说明释放成功。在ReentrantLock中实现如下： 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null);//设置独占锁持有线程为null &#125; setState(c); return free;&#125; 3.2.2 unparkSuccessor(Node)12345678910111213141516private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0)//当前节点没有被取消,更新waitStatus为0。 compareAndSetWaitStatus(node, ws, 0); Node s = node.next;//找到下一个需要唤醒的结点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; //next节点为空，从tail节点开始向前查找有效节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 说明：成功获取到资源后，调用此方法唤醒head的下一个节点。因为当前节点已经释放掉资源，下一个等待的线程可以被唤醒继续获取资源。 3.3 acquireShared(int)1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 说明：共享模式下获取资源/锁，忽略中断的影响。内部主要调用了两个个方法，其中tryAcquireShared需要自定义同步器实现。后面会对各个方法进行详细分析。acquireShared方法流程如下： tryAcquireShared(arg) 尝试获取共享资源。成功获取并且还有可用资源返回正数；成功获取但是没有可用资源时返回0；获取资源失败返回一个负数。 获取资源失败后调用doAcquireShared方法进入等待队列，获取资源后返回。 3.3.1 tryAcquireShared(int arg)1234/**共享模式下获取资源*/protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：尝试获取共享资源，需同步器自定义实现。有三个类型的返回值： 正数：成功获取资源，并且还有剩余可用资源，可以唤醒下一个等待线程； 负数：获取资源失败，准备进入等待队列； 0：获取资源成功，但没有剩余可用资源。 3.3.2 doAcquireShared(int)1234567891011121314151617181920212223242526272829//获取共享锁private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED);//添加一个共享模式Node到队列尾 boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor();//获取前节点 if (p == head) &#123; int r = tryAcquireShared(arg);//前节点为head，尝试获取资源 if (r &gt;= 0) &#123; //获取资源成功，设置head为自己，如果有剩余资源可以在唤醒之后的线程 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //检查获取失败后是否可以阻塞 parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：在tryAcquireShared中获取资源失败后，将当前线程加入等待队列尾部等待唤醒，成功获取资源后返回。在阻塞结束后成功获取到资源时，如果还有剩余资源，就调用setHeadAndPropagate方法继续唤醒之后的线程，源码如下： 123456789101112131415//设置head，如果有剩余资源可以再唤醒之后的线程private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); /* * 如果满足下列条件可以尝试唤醒下一个节点： * 调用者指定参数(propagate&gt;0)，并且后继节点正在等待或后继节点为空 */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 3.4 releaseShared(int)12345678/**共享模式释放资源*/public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared();//释放锁，并唤醒后继节点 return true; &#125; return false;&#125; 说明：共享模式下释放给定量的资源，如果成功释放，唤醒等待队列的后继节点。tryReleaseShared需要自定义同步器去实现。方法执行流程：tryReleaseShared(int)尝试释放给定量的资源，成功释放后调用doReleaseShared()唤醒后继线程。 3.4.1 tryReleaseShared(int)1234/**共享模式释放资源*/protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：释放给定量的资源，需自定义同步器实现。释放后如果允许后继等待线程获取资源返回true。 3.4.2 doReleaseShared(int)1234567891011121314151617181920//释放共享资源-唤醒后继线程并保证后继节点的资源传播private void doReleaseShared() &#123; //自旋，确保释放后唤醒后继节点 for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h);//唤醒后继节点 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) //waitStatus为0，CAS修改为PROPAGATE continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 说明：在tryReleaseShared成功释放资源后，调用此方法唤醒后继线程并保证后继节点的release传播（通过设置head节点的waitStatus为PROPAGATE）。 小结自此，AQS的主要方法就讲完了，有几个没有讲到的方法如tryAcquireNanos、tryAcquireSharedNanos，都是带等待时间的资源获取方法，还有acquireInterruptibly acquireSharedInterruptibly,响应中断式资源获取方法。都比较简单，同学们可以参考本篇源码阅读。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC源码分析之CAS和Unsafe]]></title>
    <url>%2F2019%2F07%2F06%2FJUC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BCAS%E5%92%8CUnsafe%2F</url>
    <content type="text"><![CDATA[初识CAS 在对J.U.C包的源码分析之前，首先介绍下一个比较重要的概念-CAS（Compare-and-Swap）。在J.U.C包中大量使用了CAS，涉及并发或资源争用的地方都使用了sun.misc.Unsafe类的方法进行CAS操作。在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁 锁机制存在以下问题： （1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。 （2）一个线程持有锁会导致其它所有需要此锁的线程挂起。 （3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。 独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。 什么是CAS ?CAS,即compare and swap比较并替换。 CAS有三个参数：需要读写的内存位值（V）、进行比较的预期原值（A）和拟写入的新值(B)。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。以多线程并发为例，简单来说，CAS的含义是：“两个进程都在操作V, 我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少, 显然在这个过程中, V的值可能会被其他线程修改，所以若是V值与预期原值A不相等, 则V值被修改”。CAS是一项乐观的技术，它希望能成功地执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么CAS能检测到这个错误。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败。但是，失败的线程并不会被挂起（这就是与获取锁的机制不同之处），而是被告知在这次竞争中失败，并可以多次尝试。这种灵活性就大大减少了与锁相关的活跃性风险。 以AtomicInteger为例，内部的CAS实现如下： 1234567891011121314151617181920212223242526272829303132333435public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); //value的偏移地址 private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev; &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125;&#125; 说明： 可以看到AtomicInteger内部都是使用了Unsafe类来进行CAS操作，valueOffset表示的是value值的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的原值的, 偏移量可以简单理解为指针指向该变量的内存地址。 value使用volatile修饰，直接从共享内存中操作变量，保证多线程之间看到的value值是同一份。 以方法getAndUpdate()为例，执行步骤如下： 从内存中读取修改前的值prev，并执行给定函数式计算修改后的值next； 调用compareAndSet修改value值（内部是调用了unsafe的compareAndSwapInt方法）。如果此时有其他线程也在修改这个value值，那么CAS操作就会失败，继续进入do循环重新获取新值. 由while循环判断知compareAndSet(prev, next)返回false，即没有更新成功时，就会一直循环下去，直到更新成功. 下面通熟易懂的上一个Demo: 12345public static void main(String[] args)&#123; AtomicInteger atomicInteger = new AtomicInteger(10); System.out.println(atomicInteger.compareAndSet(10,666)); System.out.println(atomicInteger.compareAndSet(10,888));&#125; AtomicInteger有一个compareAndSet方法，有两个操作数，第一个是期望值，第二个是希望修改成的值。首先初始值是10，也是内存中的值，第一次调用compareAndSet方法的时候，会将10拷贝回自己的工作空间，然后改成666，写回到主内存中的时候，它期望主内存中的值是10，而这时确实也是10，所以可以修改成功，主内存中的值也变成了666，输出true。第二次调用compareAndSet的时候，在自己的工作内存将值修改成888，写回去的时候，希望主内存中的值是10，但是此时是666，所以set失败，输出false。这就是比较并交换，也即CAS。当然实际过程中是不会这样顺序执行，而是并发执行，多个线程都在修改值，而当其中一个线程修改成功时，这意味着在这一轮中，其他线程都更新失败，进行下一次更新。 CAS的工作原理简而言之，CAS工作原理就是UnSafe类和自旋锁。 1、UnSafe类： UnSafe类在jdk的rt.jar下面的一个类，全包名是sun.misc.UnSafe。这个类大多数方法都是native方法。由于Java不能操作计算机系统，所以设计之初就留了一个UnSafe类。通过UnSafe类，Java就可以操作指定内存地址的数据。调用UnSafe类的CAS，JVM会帮我们实现出汇编指令，从而实现原子操作。现在就来分析一下AtomicInteger的getAndIncrement方法是怎么工作的。看下面的代码： 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; 这个方法调用的是unsafe类的getAndAddInt方法，有三个参数。第一个表示当前对象，也就是你new 的那个AtomicInteger对象；第二个表示内存地址；第三个表示自增步伐。然后再点进去看看这个getAndAddInt方法。 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; 这里的val1就是当前对象，val2是内存地址，val4是1，也就是自增步伐。首先把当前对象主内存中的值赋给val5，然后进入while循环。判断当前对象此刻主内存中的值是否等于val5，如果是，就自增，否则继续循环，重新获取val5的值。这里的compareAndSwapInt方法就是一个native方法，这个方法汇编之后是CPU原语指令，原语指令是连续执行不会被打断的，所以可以保证原子性。 2、自旋锁： 所谓的自旋，其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时，就重新获取主内存中的值，这就是自旋。 CAS存在的问题CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。 循环时间长，开销大。synchronized是加锁，同一时间只能一个线程访问，并发性不好。而CAS并发性提高了，但是由于CAS存在自旋操作，即do while循环，如果CAS失败，会一直进行尝试。如果CAS长时间不成功，会给CPU带来很大的开销。 只能保证一个共享变量的原子性。上面也看到了，getAndAddInt方法的val1是代表当前对象，所以它也就是能保证这一个共享变量的原子性。如果要保证多个，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量z=1, k = a，合并一下zk = 1a，然后用CAS来操作zk。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 引来的ABA问题。 什么是ABA问题？ 假设现在主内存中的值是A，现有t1和t2两个线程去对其进行操作。t1和t2先将A拷贝回自己的工作内存。这个时候t2线程将A改成B，刷回到主内存。此刻主内存和t2的工作内存中的值都是B。接下来还是t2线程抢到执行权，t2又把B改回A，并刷回到主内存。这时t1终于抢到执行权了，自己工作内存中的值的A，主内存也是A，因此它认为没人修改过，就在工作内存中把A改成了X，然后刷回主内存。也就是说，在t1线程执行前，t2将主内存中的值由A改成B再改回A。这便是ABA问题。看下面的代码演示(代码涉及到原子引用，请参考下面的原子引用的介绍)： 123456789101112131415161718class ABADemo &#123; static AtomicReference&lt;String&gt; atomicReference = new AtomicReference&lt;&gt;("A"); public static void main(String[] args)&#123; new Thread(() -&gt; &#123; atomicReference.compareAndSet("A","B"); atomicReference.compareAndSet("B","A"); &#125;,"t2").start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicReference.compareAndSet("A","C") + "\t" + atomicReference.get()); &#125;,"t1").start(); &#125;&#125; 这段代码执行结果是”true C”，这就证明了ABA问题的存在。如果一个业务只管开头和结果，不管这个A中间是否变过，那么出现了ABA问题也没事。如果需要A还是最开始的那个A，中间不许别人动手脚，那么就要规避ABA问题。要解决ABA问题，先看下面的原子引用的介绍。 原子引用： JUC包下给我们提供了原子包装类，像AtomicInteger。如果我不仅仅想要原子包装类，我自己定义的User类也想具有原子操作，怎么办呢？JUC为我们提供了AtomicReference，即原子引用。看下面的代码： 1234567891011@AllArgsConstructorclass User &#123; int age; String name; public static void main(String[] args)&#123; User user = new User(20,"张三"); AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;(); atomicReference.set(user); &#125;&#125; 像这样，就把User类变成了原子User类了。 解决ABA问题思路： 我们可以这个共享变量带上一个版本号。比如现在主内存中的是A，版本号是1，然后t1和t2线程拷贝一份到自己工作内存。t2将A改为B，刷回主内存。此时主内存中的是B，版本号为2。然后再t2再改回A，此时主内存中的是A，版本号为3。这个时候t1线程终于来了，自己工作内存是A，版本号是1，主内存中是A，但是版本号为3，它就知道已经有人动过手脚了。那么这个版本号从何而来，这就要说说AtomicStampedReference这个类了。 带时间戳的原子引用(AtomicStampedReference)：这个时间戳就理解为版本号就行了。看如下代码： 1234567891011121314151617181920212223class ABADemo &#123; static AtomicStampedReference&lt;String&gt; atomicReference = new AtomicStampedReference&lt;&gt;("A", 1); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(1);// 睡一秒，让t1线程拿到最初的版本号 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; atomicReference.compareAndSet("A", "B", atomicReference.getStamp(), atomicReference.getStamp() + 1); atomicReference.compareAndSet("B", "A", atomicReference.getStamp(), atomicReference.getStamp() + 1); &#125;, "t2").start(); new Thread(() -&gt; &#123; int stamp = atomicReference.getStamp();//拿到最开始的版本号 try &#123; TimeUnit.SECONDS.sleep(3);// 睡3秒，让t2线程的ABA操作执行完 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicReference.compareAndSet("A", "C", stamp, stamp + 1)); &#125;, "t1").start(); &#125;&#125; 初始版本号为1，t2线程每执行一次版本号加。等t1线程执行的时候，发现当前版本号不是自己一开始拿到的1了，所以set失败，输出false。这就解决了ABA问题。 Unsafe Unsafe是实现CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。Unsafe类提供了硬件级别的原子操作。 Unsafe函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293///--------------------- peek and poke 指令--------------//获取对象o中给定偏移地址(offset)的值。以下相关get方法作用相同public native int getInt(Object o, long offset);//在对象o的给定偏移地址存储数值x。以下set方法作用相同public native void putInt(Object o, long offset, int x);public native Object getObject(Object o, long offset);public native void putObject(Object o, long offset, Object x);/**篇幅原因，省略其他类型方法 *///从给定内存地址获取一个byte。下同public native byte getByte(long address);//在给定内存地址放置一个x。下同public native void putByte(long address, byte x);/**篇幅原因，省略其他类型方法*///获取给定内存地址的一个本地指针public native long getAddress(long address);//在给定的内存地址处存放一个本地指针xpublic native void putAddress(long address, long x);///------------------内存操作----------------------//在本地内存分配一块指定大小的新内存，内存的内容未初始化;它们通常被当做垃圾回收。public native long allocateMemory(long bytes);//重新分配给定内存地址的本地内存public native long reallocateMemory(long address, long bytes);//将给定内存块中的所有字节设置为固定值（通常是0）public native void setMemory(Object o, long offset, long bytes, byte value);//复制一块内存，double-register模型public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);//复制一块内存，single-register模型public void copyMemory(long srcAddress, long destAddress, long bytes) &#123; copyMemory(null, srcAddress, null, destAddress, bytes);&#125;//释放给定地址的内存public native void freeMemory(long address);//获取给定对象的偏移地址public native long staticFieldOffset(Field f);public native long objectFieldOffset(Field f);//------------------数组操作---------------------------------//获取给定数组的第一个元素的偏移地址public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);//获取给定数组的元素增量地址，也就是说每个元素的占位数public native int arrayIndexScale(Class&lt;?&gt; arrayClass);//------------------------------------------------------------//告诉虚拟机去定义一个类。默认情况下，类加载器和保护域都来自这个方法public native Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);//定义匿名内部类public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);//定位一个实例，但不运行构造函数public native Object allocateInstance(Class&lt;?&gt; cls) throws InstantiationException;///--------------------锁指令（synchronized）-------------------------------//对象加锁public native void monitorEnter(Object o);//对象解锁public native void monitorExit(Object o);public native boolean tryMonitorEnter(Object o);//解除给定线程的阻塞public native void unpark(Object thread);//阻塞当前线程public native void park(boolean isAbsolute, long time);// CASpublic final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);//获取对象o的给定偏移地址的引用值（volatile方式）public native Object getObjectVolatile(Object o, long offset);public native void putObjectVolatile(Object o, long offset, Object x);/** 省略其他类型方法 *///用于lazySet，适用于低延迟代码。public native void putOrderedObject(Object o, long offset, Object x);/** 省略其他类型方法 *///获取并加上给定delta，返回加之前的值public final int getAndAddInt(Object o, long offset, int delta)/** 省略其他类型方法 *///为给定偏移地址设置一个新的值，返回设置之前的值public final int getAndSetInt(Object o, long offset, int newValue)/** 省略其他类型方法 *////--------------------1.8新增指令-----------------------// loadFence() 表示该方法之前的所有load操作在内存屏障之前完成public native void loadFence();//表示该方法之前的所有store操作在内存屏障之前完成public native void storeFence();//表示该方法之前的所有load、store操作在内存屏障之前完成，这个相当于上面两个的合体功能public native void fullFence(); Unsafe的方法比较简单，直接看方法字面意思就大概知道方法的作用。 在Unsafe里有两个方法模型： double-register模型：给定对象，给定偏移地址offset。从给定对象的偏移地址取值。如getInt(Object o, long offset)； single-register模型：给定内存地址，直接从给定内存地址取值，如getInt(long)。 这里介绍一下几个比较重要的方法，在之后的源码阅读里会用到。 arrayBaseOffset：操作数组，用于获取数组的第一个元素的偏移地址 arrayIndexScale：操作数组，用于获取数组元素的增量地址，也就是说每个元素的占位数。打个栗子：如果有一个数组{1,2,3,4,5,6}，它第一个元素的偏移地址为16，每个元素的占位是4，如果我们要获取数组中“5”这个数字，那么它的偏移地址就是16+4*4。 putOrderedObject：putOrderedObject 是 lazySet 的实现，适用于低延迟代码。它能够实现非堵塞写入，避免指令重排序，这样它使用快速的存储-存储(store-store) barrier,而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上。这种性能提升是有代价的，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到。类似的方法还有putOrderedInt、putOrderedLong。 loadFence、storeFence、fullFence：这三个方法是1.8新增，主要针对内存屏障定义，也是为了避免重排序： loadFence() 表示该方法之前的所有load操作在内存屏障之前完成。 storeFence()表示该方法之前的所有store操作在内存屏障之前完成。 fullFence()表示该方法之前的所有load、store操作在内存屏障之前完成。 总结：1.什么是CAS? —— 比较并交换，主内存值和工作内存值相同，就set为更新值。 2.CAS原理是什么？ —— UnSafe类和自旋锁。理解那个do while循环。 3.CAS缺点是什么？ —— 循环时间长会消耗大量CPU资源；只能保证一个共享变量的原子性操作；造成ABA问题。 4.什么是ABA问题？ —— t2线程先将A改成B，再改回A，此时t1线程以为没人修改过。 5.如何解决ABA问题？—— 使用带时间戳的原子引用。 参考引用链接：https://www.jianshu.com/p/8e74009684c7 ​ https://www.jianshu.com/p/a897c4b8929f]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>源码分析</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码阅读之ConcurrentHashMap]]></title>
    <url>%2F2019%2F06%2F27%2FJDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BConcurrentHashMap%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JDK源码阅读之String类]]></title>
    <url>%2F2019%2F05%2F25%2FJDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BString%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[String类简介String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 String类的类图 该类实现了序列化接口，说明该类可以被序列化和反序列化（反序列化是构建对象的一种方式） 该类实现了比较器的接口，说明该类实现了默认的比较方式，在集合中的排序会根据这个比较的方式来进行排序。 该类实现了CharSequence 接口，CharSequence 是 char 值的一个可读序列。此接口对许多不同种类的 char 序列提供统一的只读访问 String类的重要方法源码解读String类域123456789101112131415161718/** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; /** * Class String is special cased within the Serialization Stream Protocol. * * A String instance is written into an ObjectOutputStream according to * &lt;a href="&#123;@docRoot&#125;/../platform/serialization/spec/output.html"&gt; * Object Serialization Specification, Section 6.2, "Stream Elements"&lt;/a&gt; */ private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; 主要注意value和hash这两个域，String内部也是使用数组进行存储数据的，hash是这个字符串对应的哈希码，因为String是不可变的，当String的内容发生变化之后，虚拟机会生成一个新的字符串，并将String的引用只想这个字符串，这样如果String经常发生变化时，字符串常量表里面会有大量的字符串，会浪费内存，为了节约内存空间，一个方法是使用StringBuilder，StringBuilder是可变的，另一个方法就是为每一个不可变的字符串生成一个哈希码，这样如果字符串常量表中有现成的字符串时，就不需要再生成了，直接引用就行了.为了验证常量字符串的缓存。12345678public class TestDemo1 implements Cloneable &#123; public static void main(String[] args) throws Exception &#123; String a = "abc"; String b = "abc"; System.out.println(aString == bString); &#125;&#125; 上面程序的最终结果为true.这也证明了a和b指向的是同一个对象，即常量池只有一个”abc”字符串。当然，上面成立的前提是直接将字符串常量赋值给String引用才有效，如果使用new的话，就会在堆中生成对象，即使使用一样的字符串初始化，引用也不会相等。 采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在”abc”这个对象，如果不存在，则在字符串常量池中创建”abc”这个对象，然后将池中”abc”这个对象的引用地址返回给”abc”对象的引用s1，这样s1会指向字符串常量池中”abc”这个字符串对象；如果存在，则不创建任何对象，直接将池中”abc”这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的”abc”对象，所以结果为true。 123String s3 = new String("xyz");String s4 = new String("xyz");System.out.println(s3==s4); 结果是 false 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”xyz”这个字符串对象，如果有，则不在池中再去创建”xyz”这个对象了，直接在堆中创建一个”xyz”字符串对象，然后将堆中的这个”xyz”对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个”xyz”字符串对象；如果没有，则首先在字符串池中创建一个”xyz”字符串对象，然后再在堆中创建一个”xyz”字符串对象，然后将堆中这个”xyz”字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个”xyz”字符串对象。s4则指向了堆中创建的另一个”xyz”字符串对象。s3 、s4是两个指向不同对象的引用，指向的都是堆中的地址，结果当然是false。 构造函数 不带参数的构造函数，实际上就是空，源码如下。 123public String() &#123; this.value = "".value; &#125; 从上面的属性变量可以知道，我们这个类中主要有char数组和hash值。那么理所当然的，构造方法就是围绕着两个变量在展开的。将全部的构造方法阅读一遍之后，发现除了参数检验(下标越界)之外的操作，主要是： Arrays.copyOf() 和 Arrays.copyOfRange() 两个方法（如果涉及了编码问题会调用StringCoding.decode() 方法），将要组成String的值放入到char数组中。最后这两个方法都会调用System.arraycopy(), 然后就会发现这个方法调用系统方法(native 方法)。 1234567891011121314151617//通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。 public String(char value[], int offset, int count) &#123; //检验offset 初始偏移量 的值，不能小于0 if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; //检验 count 裁剪的数量 不能小于0 if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. //检验范围 if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count); &#125; 12345678910111213141516//通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 Stringpublic String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException("charset"); //检验参数，如上 checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length); &#125;private static void checkBounds(byte[] bytes, int offset, int length) &#123; if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset &gt; bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length); &#125; 常用方法String 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。大小写映射基于 Character 类指定的 Unicode 标准版。 字符串判断相关方法 public boolean equals(Object anObject) 123456789101112131415161718192021222324// 比较两个字符串是否想等。public boolean equals(Object anObject) &#123; //首先判断两个对象是不是同一个对象，如果是那么一定是true,否则则进行第二道判断 if (this == anObject) &#123; return true; &#125; //首先判断对象是否是String类型对象，在底层就是将两个数组一个一个的对比 if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; public boolean equalsIgnoreCase(String anotherString) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 忽略大小写比较两个字符串是否相等public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length); &#125;//测试两个字符串区域是否相等。/**将此 String 对象的子字符串与参数 other 的子字符串进行比较。如果这两个子字符串表示相同的字符序列，则结果为 true，当且仅当 ignoreCase 为 true 时忽略大小写。要比较的此 String 对象的子字符串从索引 toffset 处开始，长度为 len。要比较的 other 的子字符串从索引 ooffset 处开始，长度为 len。当且仅当下列至少一项为 true 时，结果才为 false：**/ public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true; &#125; 忽略大小写的方法就是在比较的时候，在加上比较将两个字符同时转换成大写，小写的比较。至于为什么转成大写了之后，还要转换成小写的在比较一次，我也不是很清楚。官方的解释是：如果只比较大写的话，有些情况是不能得到我们想要的答案的。 public boolean startsWith(String prefix, int toffset) 12345678910111213141516171819202122232425//测试此字符串从指定索引开始的子字符串是否以指定前缀开始。public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true; &#125; public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0); &#125;public boolean endsWith(String suffix) &#123; return startsWith(suffix, value.length - suffix.value.length); &#125; startsWith函数用于检测字符串是否以prefix为前缀开始，是返回true。第一个是指定开始的下标索引，第二个则是从开始位置，endWith则是表示以suffix结尾, 底层还是通过调用startsWith, 计算出开始索引。 public int compareTo(String anotherString) 123456789101112131415161718public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2; &#125; String类实现了Comparable接口，所以说String是可比较的，compareTo的返回值是这样的，从两者的第一个字母比较过去，如果有一个字母不相等，则返回大的字母减去小的字母的int值，如果比较完了，则返回两者String的长度之差。符合compareTo方法的返回值要求，即：如果a小于b返回负数，如果a大于b，返回正数，否则返回0. 获取字符串的方法 public char charAt(int index) 123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index]; &#125; 获取某一个索引的字符，因为String是字符数组实现，所以直接返回value[index]即可 public int indexOf(String str) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int indexOf(String str) &#123; return indexOf(str, 0); &#125;public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ // 寻找第一个字符相同的地方 if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ // 继续对比接下来的字符 if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125; 原来判断字符串1是不是字符串2的子串，java的源码是使用暴力循环，并没有使用其他的算法。 public String substring(int beginIndex, int endIndex) 1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); &#125; 返回一个新的String对象, 截取字符串方法，包括beginIndex索引，不包括endIndex索引 另一个方法substring(int beginIndex)是截取从索引 beginIndex 到结尾。 字符串转换的方法 public char[] toCharArray() 123456public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; 第一眼看到这个方法，结合String以字符数组实现，我以为会直接返回对象数组，现在看了代码之后发现不是，后来想一想发现，数组是引用类型，如果将数组的引用放出去，那么String的值也会相应的改变。如果发生这个，那么就会产生很大的灾难。 public String toLowerCase() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public String toLowerCase() &#123; return toLowerCase(Locale.getDefault()); &#125; // 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 public String toLowerCase(Locale locale) &#123; if (locale == null) &#123; throw new NullPointerException(); &#125; int firstUpper; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: &#123; for (firstUpper = 0 ; firstUpper &lt; len; ) &#123; char c = value[firstUpper]; if ((c &gt;= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123; int supplChar = codePointAt(firstUpper); if (supplChar != Character.toLowerCase(supplChar)) &#123; break scan; &#125; firstUpper += Character.charCount(supplChar); &#125; else &#123; if (c != Character.toLowerCase(c)) &#123; break scan; &#125; firstUpper++; &#125; &#125; return this; &#125; char[] result = new char[len]; int resultOffset = 0; /* result may grow, so i+resultOffset * is the write location in result */ /* Just copy the first few lowerCase characters. */ System.arraycopy(value, 0, result, 0, firstUpper); String lang = locale.getLanguage(); boolean localeDependent = (lang == "tr" || lang == "az" || lang == "lt"); char[] lowerCharArray; int lowerChar; int srcChar; int srcCount; for (int i = firstUpper; i &lt; len; i += srcCount) &#123; srcChar = (int)value[i]; if ((char)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123; srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); &#125; else &#123; srcCount = 1; &#125; if (localeDependent || srcChar == '\u03A3') &#123; // GREEK CAPITAL LETTER SIGMA lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale); &#125; else if (srcChar == '\u0130') &#123; // LATIN CAPITAL LETTER I DOT lowerChar = Character.ERROR; &#125; else &#123; lowerChar = Character.toLowerCase(srcChar); &#125; if ((lowerChar == Character.ERROR) || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123; if (lowerChar == Character.ERROR) &#123; if (!localeDependent &amp;&amp; srcChar == '\u0130') &#123; lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, Locale.ENGLISH); &#125; else &#123; lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale); &#125; &#125; else if (srcCount == 2) &#123; resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount; continue; &#125; else &#123; lowerCharArray = Character.toChars(lowerChar); &#125; /* Grow result if needed */ int mapLen = lowerCharArray.length; if (mapLen &gt; srcCount) &#123; char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; &#125; for (int x = 0; x &lt; mapLen; ++x) &#123; result[i + resultOffset + x] = lowerCharArray[x]; &#125; resultOffset += (mapLen - srcCount); &#125; else &#123; result[i + resultOffset] = (char)lowerChar; &#125; &#125; return new String(result, 0, len + resultOffset); &#125; 其他方法 public String trim()1234567891011121314// 返回字符串的副本，忽略前导空白和尾部空白。 public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; &#125; 将字符串前导空白和尾部空白忽略。 public String[] split(String regex, int limit) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public String[] split(String regex, int limit) &#123; /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters ".$|()[&#123;^?*+\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) resultSize--; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit); &#125; 内部使用arrayList集合来收集被分割的子串，子串是通过substring（）方法来得到的，参数是通过indexof方法来获取的。 public String concat(String str) 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); &#125; intern方法1public native String intern(); intern方法是一个本地方法，调用该方法，会判断是否常量池中有一个与该String对象相等的对象（也就是equals返回0），如果有返回常量池中的对象，否则，将该String对象添加到常量池中再返回常量池中的对象。 String类涉及的设计模式享元模式模式解释一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素 String类的体现因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。 阅读String类的感想String类是我们最常使用的一个类，我们也都知道String类是不可改变的，每当改变一个变量的值时候，地址也会随之改变。基于这种不变的特性，出现了享元模式，让系统中的多个相同的String共享一个地址，避免了开销。 String类的底层是char数组，所以我们看到String的方法（对字符串的操作）底层都是操作数组。其实我们看到方法之后，了解底层是数组，对方法的一些大概操作是可以预知的，在读完源码之后，会更加清晰明了。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode17-电话号码的字母组合]]></title>
    <url>%2F2019%2F05%2F25%2FLeetcode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[Description 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 123&gt; 输入：&quot;23&quot;&gt; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].&gt; 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 Method 使用字符串数组map存储电话号码的字母映射 使用深度遍历方法DFS , 依次遍历digits的数字，再字典map中查找，组合可能 如果拼接的字符串长度等于数字字符长度，则添加该字符串 返回结果 123456789101112131415161718private String[] map = &#123;"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (digits != null &amp;&amp; digits.length() &gt; 0) dfs(ans, "", digits); return ans; &#125; public void dfs(List&lt;String&gt; ans, String cur, String digits) &#123; if (cur.length() == digits.length()) &#123; ans.add(cur); return; &#125; int index = digits.charAt(cur.length()) - '0'; for (int i = 0; i &lt; map[index].length(); i++) &#123; dfs(ans, cur + map[index].charAt(i), digits); &#125; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Letter Combinations of a Phone Number. Memory Usage: 35.2 MB, less than 98.30% of Java online submissions for Letter Combinations of a Phone Number. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode300-最长上升子序列]]></title>
    <url>%2F2019%2F05%2F25%2FLeetcode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Description 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 1234&gt; 输入: [10,9,2,5,3,7,101,18]&gt; 输出: 4 &gt; 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。&gt; 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? Method One 如果长度小于等于1,直接返回nunms.length max 记录当前遍历i 情况下的最长子串长度, dp[i] 存放最长子串的最后一个元素值（最大值） 如果当前元素比最大的那个子串的最后一个元素还要大，那就直接长度加一，新子串的最后一个元素为当前元素 如果当前元素比最大的那个子串的最后一个元素要小，那就要更新dp数组，保证每一个子串都是最优解 12345678910111213141516171819202122232425262728public int lengthOfLIS(int[] nums) &#123; if(nums.length &lt;= 1)&#123; return nums.length; &#125; //最大长度 int max = 1; //dp[i]表示第i长的子序列，最后的元素 int[] dp = new int[nums.length + 1]; dp[1] = nums[0]; for(int i = 1;i &lt; nums.length;i++)&#123; //如果当前元素比最大的那个子串的最后一个元素还要大 //那就直接长度加一，新子串的最后一个元素为当前元素 if(nums[i] &gt; dp[max])&#123; dp[++max] = nums[i]; &#125;else if(nums[i] &lt; dp[max])&#123; //如果当前元素比最大的那个子串的最后一个元素要小 //那就要更新dp数组，保证每一个子串都是最优解 for(int j = 1 ;j &lt;= max; j++)&#123; //因为是递增，所以是&lt;=,在将等于的时候直接终止循环 if(nums[i] &lt;= dp[j])&#123; dp[j] = nums[i]; break; &#125; &#125; &#125; &#125; return max; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence. Memory Usage: 36.3 MB, less than 57.53% of Java online submissions for Longest Increasing Subsequence. Method Two 如果长度小于等于1,直接返回nunms.length max 记录当前遍历i 情况下的最长子串长度, dp[i] 存放最长子串的最后一个元素值（最大值） 如果当前元素比最大的那个子串的最后一个元素还要大，那就直接长度加一，新子串的最后一个元素为当前元素 如果当前元素比最大的那个子串的最后一个元素要小，那就要更新dp数组，保证每一个子串都是最优解，采用二分查找法，因为dp是严格递增的数组 123456789101112131415161718192021222324252627282930public int lengthOfLIS(int[] nums) &#123; int len = nums.length; if(len &lt;= 1)&#123; return len; &#125; int maxL = 0; //dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数 int[] dp = new int[nums.length]; dp[0] = nums[0]; for(int i = 1; i &lt; len; i++)&#123; if(nums[i] &gt; dp[maxL])&#123; dp[++maxL]= nums[i]; &#125;else&#123; int left = 0, right = maxL; while(left &lt; right)&#123; int mid = left + (right-left)/2; if(dp[mid] == nums[i])&#123; left = mid; break; &#125;else if(dp[mid] &lt; nums[i])&#123; left = left + 1; &#125;else&#123; right = mid; &#125; &#125; dp[left] = nums[i]; &#125; &#125; return ++maxL; &#125; Complexity Analysis Time complexity : O(n log n). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence. Memory Usage: 36.3 MB, less than 57.53% of Java online submissions for Longest Increasing Subsequence. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode120-三角形最小路径和]]></title>
    <url>%2F2019%2F05%2F07%2FLeetcode120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Description 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 1234567&gt; [&gt; [2],&gt; [3,4],&gt; [6,5,7],&gt; [4,1,8,3]&gt; ]&gt; 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 Method 动态规划题型，已知最佳路径，则最佳路径必定经过上一层的两个值中较小值 从倒数第二层开始遍历，用长度为n的整形数组a 统计当前层的每一列的最优长度 对当前层，对上一层每相邻的两个数据进行比对大小，将较小值加到a[j] 上，记录每一列的最优值 最后到第０层，取第一层中较小值加到a[0]上 返回最小值a[0] 123456789101112131415161718// 动态规划 // 状态定义 dp[i][j] 包含 dp[i][j]的最小值 // 地推方程 dp[i][j] = min&#123;dp[i + 1][j], dp[i + 1][j + 1] &#125; + nums[i][j] public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null || triangle.get(0) == null) return 0; int m = triangle.size(), n = triangle.size(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = triangle.get(n - 1).get(i); for (int i = n - 2; i &gt;= 0; i--) &#123; List&lt;Integer&gt; cur = triangle.get(i); for(int j = 0; j &lt; i + 1; j++) &#123; a[j] = a[j] &lt; a[j + 1] ? a[j] : a[j + 1]; a[j] += cur.get(j); &#125; &#125; return a[0]; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 99.94% of Java online submissions for Triangle. Memory Usage: 37.9 MB, less than 77.62% of Java online submissions for Triangle. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode55-跳跃游戏]]></title>
    <url>%2F2019%2F05%2F07%2FLeetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Description 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 1234&gt; 输入: [2,3,1,1,4]&gt; 输出: true&gt; 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。&gt; 示例 2: 1234&gt; 输入: [3,2,1,0,4]&gt; 输出: false&gt; 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。&gt; Method 从后向前遍历，从倒数第二个点判断能否到达最后一个点 分两种情况，若可以，即nums[i] 大于i到终点距离(minEnd - i), 这时，将终点修改为当前点，因为当前点可达 若不可以，继续向前遍历，终点minEnd不变，继续寻找，最后若minEnd为起点0,则说明从起点到终点可达 返回 minEnd 等于0是否为真 123456789public boolean canJump(int[] nums) &#123; int length = nums.length, minEnd = length - 1; for (int i = minEnd; i &gt;= 0; i--) &#123; if (nums[i] &gt;= (minEnd - i)) &#123; minEnd = i; &#125; &#125; return minEnd == 0; &#125; Complexity Analysis Time complexity : O( n). Space complexity : O(1). AcceptedRuntime: 1 ms, faster than 99.93% of Java online submissions for Jump Game. Memory Usage: 41.4 MB, less than 16.44% of Java online submissions for Jump Game. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode51-N皇后问题2]]></title>
    <url>%2F2019%2F05%2F07%2FLeetcode51-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%982%2F</url>
    <content type="text"><![CDATA[Description n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例: 123456789101112131415&gt; 输入: 4&gt; 输出: 2&gt; 解释: 4 皇后问题存在如下两个不同的解法。&gt; [&gt; [&quot;.Q..&quot;, // 解法 1&gt; &quot;...Q&quot;,&gt; &quot;Q...&quot;,&gt; &quot;..Q.&quot;],&gt; &gt; [&quot;..Q.&quot;, // 解法 2&gt; &quot;Q...&quot;,&gt; &quot;...Q&quot;,&gt; &quot;.Q..&quot;]&gt; ]&gt; Method N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到 采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放 利用checkPerRow函数，检测摆放皇后是否满足条件 若发现摆放的皇后不满足要求，则回退, list删除刚摆放的不满足的皇后 若满足条件，则递归，将层数加一，若层数等于N,则将结果加一，即total++ 返回全局变量total 1234567891011121314151617181920212223242526272829private int total = 0; public int totalNQueens(int n) &#123; int[] rows = new int[n]; perRowQueen(0, rows, n); return total; &#125; private void perRowQueen(int row, int[] rows, int n) &#123; if (row &gt;= n) &#123; total++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; rows[row] = i; if (checkPerRow(row, rows)) &#123; perRowQueen(row + 1, rows, n); &#125; &#125; &#125; private boolean checkPerRow(int row, int[] rows) &#123; for (int i = 0; i &lt; row; i++) &#123; if (rows[row] == rows[i] || Math.abs(row - i) == Math.abs(rows[row] - rows[i])) &#123; return false; &#125; &#125; return true; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 97.11% of Java online submissions for N-Queens 2. Memory Usage: 31.7 MB, less than 100.00% of Java online submissions for N-Queens 2. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode52-N皇后问题2]]></title>
    <url>%2F2019%2F05%2F07%2FLeetcode52-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%982%2F</url>
    <content type="text"><![CDATA[Description n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例: 123456789101112131415&gt; 输入: 4&gt; 输出: 2&gt; 解释: 4 皇后问题存在如下两个不同的解法。&gt; [&gt; [&quot;.Q..&quot;, // 解法 1&gt; &quot;...Q&quot;,&gt; &quot;Q...&quot;,&gt; &quot;..Q.&quot;],&gt; &gt; [&quot;..Q.&quot;, // 解法 2&gt; &quot;Q...&quot;,&gt; &quot;...Q&quot;,&gt; &quot;.Q..&quot;]&gt; ]&gt; Method N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到 采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放 利用checkPerRow函数，检测摆放皇后是否满足条件 若发现摆放的皇后不满足要求，则回退, list删除刚摆放的不满足的皇后 若满足条件，则递归，将层数加一，若层数等于N,则将结果加一，即total++ 返回全局变量total 1234567891011121314151617181920212223242526272829private int total = 0; public int totalNQueens(int n) &#123; int[] rows = new int[n]; perRowQueen(0, rows, n); return total; &#125; private void perRowQueen(int row, int[] rows, int n) &#123; if (row &gt;= n) &#123; total++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; rows[row] = i; if (checkPerRow(row, rows)) &#123; perRowQueen(row + 1, rows, n); &#125; &#125; &#125; private boolean checkPerRow(int row, int[] rows) &#123; for (int i = 0; i &lt; row; i++) &#123; if (rows[row] == rows[i] || Math.abs(row - i) == Math.abs(rows[row] - rows[i])) &#123; return false; &#125; &#125; return true; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 97.11% of Java online submissions for N-Queens 2. Memory Usage: 31.7 MB, less than 100.00% of Java online submissions for N-Queens 2. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode51-N皇后问题]]></title>
    <url>%2F2019%2F05%2F07%2FLeetcode51-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Description n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例: 1234567891011121314&gt; 输入: 4&gt; 输出: [&gt; [&quot;.Q..&quot;, // 解法 1&gt; &quot;...Q&quot;,&gt; &quot;Q...&quot;,&gt; &quot;..Q.&quot;],&gt; &gt; [&quot;..Q.&quot;, // 解法 2&gt; &quot;Q...&quot;,&gt; &quot;...Q&quot;,&gt; &quot;.Q..&quot;]&gt; ]&gt; 解释: 4 皇后问题存在两个不同的解法。&gt; Method N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到 采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放 利用三个boolean数组分别对当前皇后的列，左上，右上进行判断（右上则横纵坐标和相等） 若发现摆放的皇后不满足要求，则回退，将boolean数组值复位（false）,list删除刚摆放的不满足的皇后 返回res 1234567891011121314151617181920212223242526272829private List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; helper(0, n, new boolean[n], new boolean[2*n-1], new boolean[2*n-1], new ArrayList&lt;&gt;()); return res; &#125; private void helper(int row, int n, boolean[] cols, boolean[] d1, boolean[] d2, List&lt;String&gt; list)&#123; if(row == n)&#123; res.add(new ArrayList&lt;&gt;(list)); return; &#125; for(int col = 0; col &lt; n; col++)&#123; int d1Num = col + row; int d2Num = col - row + n - 1; if(!cols[col] &amp;&amp; !d1[d1Num] &amp;&amp;!d2[d2Num])&#123; char[] temp = new char[n]; Arrays.fill(temp,'.'); temp[col] = 'Q'; cols[col] = true; d1[d1Num] = true; d2[d2Num] = true; list.add(new String(temp)); helper(row + 1, n, cols, d1, d2, list); cols[col] = false; d1[d1Num] = false; d2[d2Num] = false; list.remove(list.size() - 1); &#125; &#125; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 2 ms, faster than 97.49% of Java online submissions for N-Queens. Memory Usage: 38.8 MB, less than 62.86% of Java online submissions for N-Queens. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-表、栈和队列]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[表、栈和队列本章重点 介绍抽象数据类型的概念 阐述如何有效的执行表的操作 介绍栈ADT及其在实现递归方面的应用 介绍队列ADT及其在操作系统和算法设计中的应用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode14-最长公共前缀]]></title>
    <url>%2F2019%2F05%2F05%2FLeetcode14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[Description 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 123&gt; 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]&gt; 输出: &quot;fl&quot;&gt; 示例 2: 1234&gt; 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]&gt; 输出: &quot;&quot;&gt; 解释: 输入不存在公共前缀。&gt; 说明: 所有输入只包含小写字母 a-z 。 Method 利用StringBuilder保存第一个字符串，然后分别对另外的n-1个字符串判断，是不是以match为前缀 使用startWith函数判断，并依次裁剪match直到match满足所有的字符串 返回match 123456789101112public String longestCommonPrefix(String[] strs) &#123; if (strs.length &lt; 1) return ""; if (strs.length == 1) return strs[0]; StringBuilder match = new StringBuilder(strs[0]); for (int i = 1; i &lt; strs.length; i++) &#123; while (!strs[i].startsWith(match.toString())) &#123; match.deleteCharAt(match.length() - 1); if (match.length() &lt; 1) return ""; &#125; &#125; return match.toString(); &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(n). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Longest Common Prefix. Memory Usage: 38.8 MB, less than 20.63% of Java online submissions for Longest Common Prefix. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode01-两数之和]]></title>
    <url>%2F2019%2F05%2F05%2FLeetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Description 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 12345&gt; 给定 nums = [2, 7, 11, 15], target = 9&gt; &gt; 因为 nums[0] + nums[1] = 2 + 7 = 9&gt; 所以返回 [0, 1]&gt; Method 题目求解两个数之和等于目标数的数组下标 转化为将数字存放进哈希表，然后每一次检测目标数减去nums[i] (每一次数组遍历值) 若找到返回下标值 12345678910111213public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(target-nums[i]))&#123; result[1] = i; result[0] = map.get(target-nums[i]); return result; &#125; map.put(nums[i],i); &#125; return result; &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(n). AcceptedRuntime: 3 ms, faster than 99.54% of Java online submissions for Two Sum. Memory Usage: 38.9 MB, less than 31.85% of Java online submissions for Two Sum. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode122-买卖股票的最佳时机2]]></title>
    <url>%2F2019%2F05%2F05%2FLeetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2%2F</url>
    <content type="text"><![CDATA[Description 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 12345&gt; 输入: [7,1,5,3,6,4]&gt; 输出: 7&gt; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&gt; 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。&gt; 示例 2: 123456&gt; 输入: [1,2,3,4,5]&gt; 输出: 4&gt; 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&gt; 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。&gt; 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。&gt; 示例 3: 1234&gt; 输入: [7,6,4,3,1]&gt; 输出: 0&gt; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&gt; Method 与上一题的买卖股票较为类似，不同的是可以重复购买 所以只需要计算相邻之间的差值，如果大于0，则累加，即是一次交易（上一次买入，这一次卖出） 返回数组大于零的累积和 12345678910111213public int maxProfit(int[] prices) &#123; if (prices.length &lt; 2) return 0; int[] dp = new int[prices.length]; for (int i = 1; i &lt; prices.length; i++)&#123; dp[i] = prices[i] - prices[i - 1]; &#125; int res = 0; for (int i = 1; i &lt; dp.length; i++)&#123; if (dp[i] &gt; 0) res += dp[i]; &#125; return res; &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 81.61% of Java online submissions for Buy and Sell Stock 2. Memory Usage: 38.6 MB, less than 56.12% of Java online submissions for Buy and Sell Stock 2. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode121-买卖股票的最佳时机]]></title>
    <url>%2F2019%2F05%2F05%2FLeetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Description 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 12345&gt; 输入: [7,1,5,3,6,4]&gt; 输出: 5&gt; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&gt; 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。&gt; 示例 2: 1234&gt; 输入: [7,6,4,3,1]&gt; 输出: 0&gt; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&gt; AlgorithmMethod 对价格数组进行遍历，每次记录当前最小值，与股票最大收益 每次对股票最大收益与之前的最大收益作对比，进行更新最大值 返回最大值 1234567891011public int maxProfit(int[] prices) &#123; int max = Integer.MIN_VALUE; int minValue = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minValue) minValue = prices[i]; if (prices[i] - minValue &gt; max) max = prices[i] - minValue; &#125; return max &gt; 0 ? max : 0; &#125; Complexity Analysis Time complexity : O( n). Space complexity : O(1). AcceptedRuntime: 0ms, faster than 100.00% of Java online submissions for Buy and Sell Stock. Memory Usage: 38.7 MB, less than 53.26% of Java online submissions for Buy and Sell Stock. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode064-最小路径和]]></title>
    <url>%2F2019%2F05%2F05%2FLeetcode064-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Description 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 123456789&gt; 输入:&gt; [&gt; [1,3,1],&gt; [1,5,1],&gt; [4,2,1]&gt; ]&gt; 输出: 7&gt; 解释: 因为路径 1→3→1→1→1 的总和最小。&gt; AlgorithmMethod 这是一道典型的动态规划题，首先若想保证路径和最小，则从上一步中取最小值 最小值是 grid [i-1] [j] 和 grid[i] [j-1]中的最小值 最后grid[m-1] [n-1]就是结果 12345678910111213141516171819202122public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; if(m == 0 || n == 0)&#123; return 0; &#125; for (int i = 0; i &lt; m; i++)&#123; if (i &gt; 0)&#123; grid[i][0] += grid[i - 1][0]; &#125; &#125; for (int j = 0; j &lt; n; j++)&#123; if (j &gt; 0)&#123; grid[0][j] += grid[0][j - 1]; &#125; &#125; for (int i = 1; i &lt; m; i++) for(int j = 1; j &lt; n; j++)&#123; grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); &#125; return grid[m - 1][n - 1]; &#125; Complexity Analysis Time complexity : O(m * n). Space complexity : O(log n). AcceptedRuntime: 2 ms, faster than 96.31% of Java online submissions for Minimum Path Sum. Memory Usage: 44.3 MB, less than 11.79% of Java online submissions for Minimum Path Sum. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode66-Plus One]]></title>
    <url>%2F2019%2F03%2F25%2FLeetcode66-Plus-One%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: 1234&gt; Input: [1,2,3]&gt; Output: [1,2,4]&gt; Explanation: The array represents the integer 123.&gt; Example 2: 1234&gt; Input: [4,3,2,1]&gt; Output: [4,3,2,2]&gt; Explanation: The array represents the integer 4321.&gt; Accepted 364,557 Submissions 893,110 AlgorithmMethod From the low to the high, it is judged whether it is 9 or not. If it is, the current position is 0. Finally, add one at the highest position that needs to be carried. If the highest bit complement is required, expand the array and assign the highest bit to 1 1234567891011121314151617181920public int[] plusOne(int[] digits) &#123; int n = digits.length - 1; if (digits[n] != 9)&#123; digits[n]++; return digits; &#125; while (n &gt;= 0 &amp;&amp; digits[n] == 9)&#123; digits[n] = 0; n--; &#125; if (n &gt;= 0)&#123; digits[n]++; &#125;else &#123; int[] digits2 = Arrays.copyOf(digits, digits.length + 1); digits2[0] = 1; return digits2; &#125; return digits; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Plus One. Memory Usage: 37.3 MB, less than 5.01% of Java online submissions for Plus One. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode98-Validate Binary Search Tree]]></title>
    <url>%2F2019%2F03%2F25%2FLeetcode98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456&gt; Input:&gt; 2&gt; / \&gt; 1 3&gt; Output: true&gt; Example 2: 123456789&gt; 5&gt; / \&gt; 1 4&gt; / \&gt; 3 6&gt; Output: false&gt; Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value&gt; is 5 but its right child&apos;s value is 4.&gt; Accepted 371,783 Submissions 1,465,105 AlgorithmMethod Use the in-order traversal algorithm, because the in-order traversal just happens to be an ascending sequence Returns false if the ascending condition is not met, otherwise returns true 12345678910111213double last = -Double.MAX_VALUE; public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (isValidBST(root.left)) &#123; if (last &lt; root.val) &#123; last = root.val; return isValidBST(root.right); &#125; &#125; return false; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree. Memory Usage: 40.5 MB, less than 5.01% of Java online submissions for Validate Binary Search Tree. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode150-Evaluate Reverse Polish Notation]]></title>
    <url>%2F2019%2F03%2F25%2FLeetcode150-Evaluate-Reverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[Description Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: 1234&gt; Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]&gt; Output: 9&gt; Explanation: ((2 + 1) * 3) = 9&gt; Example 2: 1234&gt; Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]&gt; Output: 6&gt; Explanation: (4 + (13 / 5)) = 6&gt; Example 3: 1234567891011&gt; Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]&gt; Output: 22&gt; Explanation: &gt; ((10 * (6 / ((9 + 3) * -11))) + 17) + 5&gt; = ((10 * (6 / (12 * -11))) + 17) + 5&gt; = ((10 * (6 / -132)) + 17) + 5&gt; = ((10 * 0) + 17) + 5&gt; = (0 + 17) + 5&gt; = 17 + 5&gt; = 22&gt; Accepted 153,410 Submissions 485,932 AlgorithmMethod Determine if each string is a number If it is a number, put it on the stack If it is an operator, take the two numbers in the stack and put them into the stack. Returns the last number in the stack 12345678910111213141516171819202122232425262728public int evalRPN(String[] tokens) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); int num1, num2; for (int i = 0; i &lt; tokens.length; i++) &#123; if (Character.isDigit(tokens[i].charAt(tokens[i].length()-1)))&#123; stack.push(tokens[i]); &#125; else &#123; num2 = Integer.valueOf(stack.pop()); num1 = Integer.valueOf(stack.pop()); switch (tokens[i]) &#123; case "+": stack.push(String.valueOf(num1 + num2)); break; case "-": stack.push(String.valueOf(num1 - num2)); break; case "*": stack.push(String.valueOf(num1 * num2)); break; case "/": stack.push(String.valueOf(num1 / num2)); break; &#125; &#125; &#125; return Integer.parseInt(stack.peek()); &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). AcceptedRuntime: 7 ms, faster than 52.44% of Java online submissions for Evaluate Reverse Polish Notation. Memory Usage: 38.7 MB, less than 22.01% of Java online submissions for Evaluate Reverse Polish Notation. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode73-Set Matrix Zeroes]]></title>
    <url>%2F2019%2F03%2F19%2FLeetcode73-Set-Matrix-Zeroes%2F</url>
    <content type="text"><![CDATA[Description Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Accepted 194,111 Submissions 496,295 AlgorithmMethod One start with rowFlag,colFlag to indicate whether 0 exists in the first row, first column then use a HashSet to store the existing row and column labels of 0 (distinct row labels are represented by negative Numbers) iterates over the HashSet, setting the row and column to 0 set the first row, first column to 0 according to flag 中文： 首先用rowFlag,colFlag标志第一行第一列是否存在0 然后用HashSet存放存在的0的行标与列标(区别行标用负数表示) 遍历HashSet,将所在行与所在列置为0 依据flag将第一行，第一列置为0 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void setZeroes(int[][] matrix) &#123; if (matrix == null) return; int m = matrix.length; int n = matrix[0].length; int rowFlag = 0; int colFlag = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; matrix.length; i++) for(int j = 0; j &lt; matrix[i].length; j++)&#123; if (matrix[i][j] == 0)&#123; // save the index if (i != 0)&#123; set.add(i); &#125;else&#123; rowFlag = 1; &#125; if (j != 0)&#123; set.add(-j); &#125; else&#123; colFlag = 1; &#125; &#125; &#125; for (Integer ln : set)&#123; if (ln &gt; 0)&#123; for (int i = 0; i &lt; n; i++)&#123; matrix[ln][i] = 0; &#125; &#125; else if(ln &lt; 0)&#123; for (int i = 0; i &lt; m; i++)&#123; matrix[i][-ln] = 0; &#125; &#125; &#125; if (rowFlag == 1)&#123; for (int j = 0; j &lt; n; j++)&#123; matrix[0][j] = 0; &#125; &#125; if (colFlag == 1)&#123; for (int i = 0; i &lt; m; i++)&#123; matrix[i][0] = 0; &#125; &#125; &#125; Complexity Analysis Time complexity : O(m * n). Space complexity : O(1). AcceptedRuntime: 2 ms, faster than 33.77% of Java online submissions for Set Matrix Zeroes. Memory Usage: 42.1 MB, less than 86.07% of Java online submissions for Set Matrix Zeroes. Method Two start with rowFlag,colFlag to indicate whether 0 exists in the first row, first column traverses the number groups, and sets the first place (matrix[I] [0], matrix[j] [0]) of the row and column in which 0 is located as 0 traverses the first row and first column, with 0’s column or row set to 0 set the first row, first column to 0 according to flag 中文： 首先用rowFlag,colFlag标志第一行第一列是否存在0 遍历数组，将0所在的行与列的首位(matrix[i] [0], matrix[j] [0])置为0 遍历第一行与第一列，0所在的列或行置为0 依据flag将第一行，第一列置为0 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void setZeroes(int[][] matrix) &#123; boolean rowFlag = false; //判断首行 for (int i = 0; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; rowFlag = true; break; &#125; &#125; boolean colFlag = false; for (int i = 0; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; colFlag = true; break; &#125; &#125; for (int i = 1; i &lt; matrix.length; i++) &#123; for (int j = 1; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for (int i = 1; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; matrix[j][i] = 0; &#125; &#125; &#125; for (int i = 1; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if (rowFlag)&#123; for (int i = 0; i &lt; matrix[0].length; i++) &#123; matrix[0][i] = 0; &#125; &#125; if (colFlag)&#123; for (int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125; Complexity Analysis Time complexity : O(m * n). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Sort Colors. Memory Usage: 34.9 MB, less than 80.40% of Java online submissions for Sort Colors. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode75-Sort Colors]]></title>
    <url>%2F2019%2F03%2F19%2FLeetcode75-Sort-Colors%2F</url>
    <content type="text"><![CDATA[Description Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? Accepted 297,079 Submissions 716,181 AlgorithmMethod first move all the red to the front by scanning two subscripts from the front and from the back to the middle the second time you go from the maximum red index +1 to the maximum red index, just like in the first step, except you move the white to the end of the red blue is already in position 中文： 首先通过两个下标从前与从后向中间扫描，将所有的红色移到前面 第二次从红色下标最大值+1,到最大下标，与第一步一样，只是将白色移到红色后面 蓝色已经位置正确摆正 Code 1234567891011121314151617181920212223public void sortColors(int[] nums) &#123; int index = swap(nums, 0 , nums.length - 1, 0); swap(nums, index, nums.length - 1, 1); &#125; private int swap(int[] nums, int start, int end, int target)&#123; int temp; for (; start &lt; end;)&#123; if (nums[start] == target)&#123; start++; &#125;else&#123; if (nums[end] == target)&#123; temp = nums[end]; nums[end] = nums[start]; nums[start] = temp; start++; &#125;else&#123; end--; &#125; &#125; &#125; return start; &#125; Complexity Analysis Time complexity : O(n ). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Sort Colors. Memory Usage: 34.9 MB, less than 80.40% of Java online submissions for Sort Colors. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode46-Permutations]]></title>
    <url>%2F2019%2F03%2F18%2FLeetcode46-Permutations%2F</url>
    <content type="text"><![CDATA[Description Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]Accepted 347,568 Submissions 646,730 AlgorithmMethod Inspiration from the next arrangement First, every time you find the next permutation, you find the first pair of nums[I + 1] &lt; nums[I] from the right The Numbers after I are in descending order, so find the first number greater than nums[I] from the right to the left Swap nums[I],nums[j], and use swap The descending sequence after I was arranged in ascending order to ensure that the right side was the smallest. Reverse function was used to invert the array Recursive call add, add all the combination, when the number of lists added to the maximum permutation exit 中文： 根据下一个排列得到的灵感 首先每一次找到下一个排列，即每一次从右边找到第一对nums[i + 1] &lt; nums[i]的数 下标i之后的数是降序排列，所以从右边向左找到第一个大于nums[i]的数 交换nums[i],nums[j],利用swap函数 对i之后的降序序列进行升序排列，以保证右边是最小的，利用reverse函数逆置数组 递归调用add,添加所有的组合，当lists添加的数量达到排列最大值后退出 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums == null || nums.length == 0)&#123; return null; &#125; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++)&#123; list.add(nums[i]); &#125; int n = 1; for (int i = 1; i &lt;= nums.length; i++) &#123; n *= i; &#125; lists.add(list); add(nums, lists, n); return lists; &#125; private void add(int[] nums, List&lt;List&lt;Integer&gt;&gt; lists, int n)&#123; if (n == lists.size())&#123; return; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt; nums[i])&#123; i--; &#125; if (i &gt;= 0)&#123; int j = nums.length - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i])&#123; j--; &#125; swap(nums, i, j); &#125; reverse(nums, i + 1); for (int k = 0; k &lt; nums.length; k++)&#123; list.add(nums[k]); &#125; lists.add(list); add(nums, lists, n); &#125; private void swap(int[] nums, int i, int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; private void reverse(int[] nums, int start)&#123; int end = nums.length - 1; while (start &lt; end)&#123; swap(nums, start, end); start++; end--; &#125; &#125; Complexity Analysis Time complexity : O(n ^ 2). Space complexity : O(n). AcceptedRuntime: 2 ms, faster than 93.15% of Java online submissions for Permutations. Memory Usage: 39 MB, less than 29.07% of Java online submissions for Permutations. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode28-Implement strStr()]]></title>
    <url>%2F2019%2F03%2F16%2FLeetcode28-Implement-strStr%2F</url>
    <content type="text"><![CDATA[Description Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = “hello”, needle = “ll” Output: 2 Example 2: Input: haystack = “aaaaa”, needle = “bba” Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Accepted 391,178 Submissions 1,247,053 AlgorithmMethod if needle is empty, return 0 For loop traversal, each time intercepting the length of the string string, compared with the needle, equal to return i No result at the end of the loop, return -1 Code123456789101112131415public int strStr(String haystack, String needle) &#123; if (needle.length() == 0)&#123; return 0; &#125; int m = haystack.length(); int n = needle.length(); String cmp; for (int i = 0; i &lt;= m - n; i++)&#123; cmp = haystack.substring(i, i + n); if (cmp.equals(needle))&#123; return i; &#125; &#125; return -1; &#125; Complexity Analysis Time complexity : O(m - n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 93.21% of Java online submissions for Implement strStr(). Memory Usage: 38.8 MB, less than 7.49% of Java online submissions for Implement strStr(). ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode35-Search Insert Position]]></title>
    <url>%2F2019%2F03%2F15%2FLeetcode35-Search-Insert-Position%2F</url>
    <content type="text"><![CDATA[Description Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 Accepted 368,106 Submissions 908,904 AlgorithmMethod Use the dichotomy to find the target, if exists return subscript If the target is not found, it returns low because the loop ends with high == low - 1, and low happens to be the new position of the element insertion. Code1234567891011121314public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length - 1, mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (nums[mid] == target)&#123; return mid; &#125;else if (nums[mid] &gt; target)&#123; high = mid - 1; &#125;else &#123; low = mid + 1; &#125; &#125; return high + 1; &#125; Complexity Analysis Time complexity : O(log n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 2 ms, faster than 100.00% of Java online submissions for Search Insert Position. Memory Usage: 39.5 MB, less than 10.70% of Java online submissions for Search Insert Position. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode34- Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2019%2F03%2F15%2FLeetcode34-Find-First-and-Last-Position-of-Element-in-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Description Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Accepted 273,145 Submissions 826,276 Method Initialize the result array, return result if no target is found Use the dichotomy to find if the target is found,Find the left and right borders of the subscript mid and find the first and last index Return result Code12345678910111213141516171819202122public int[] searchRange(int[] nums, int target) &#123; int[] result = &#123;-1, -1&#125;; int low = 0, high = nums.length - 1, mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (nums[mid] == target)&#123; int tmp = mid; while (mid &gt; -1 &amp;&amp; nums[mid] == target)&#123; result[0] = mid--; &#125; while (tmp &lt; nums.length &amp;&amp; nums[tmp] == target)&#123; result[1] = tmp++; &#125; return result; &#125;else if (nums[mid] &gt; target)&#123; high = mid - 1; &#125;else &#123; low = mid + 1; &#125; &#125; return result; &#125; Complexity Analysis Time complexity : O(log n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 100.00% of Java online submissions for Find First and Last Position of Element in Sorted Array. Memory Usage: 42.8 MB, less than 5.19% of Java online submissions for Find First and Last Position of Element in Sorted Array. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode41-First Missing Positive]]></title>
    <url>%2F2019%2F03%2F14%2FLeetcode41-First-Missing-Positive%2F</url>
    <content type="text"><![CDATA[Description Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Accepted 194,768 Submissions 688,088 AlgorithmMethod The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue. Code1234567891011121314151617public int firstMissingPositive(int[] A) &#123; int i = 0; while(i &lt; A.length)&#123; if(A[i] == i+1 || A[i] &lt;= 0 || A[i] &gt; A.length) i++; else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1); else i++; &#125; i = 0; while(i &lt; A.length &amp;&amp; A[i] == i+1) i++; return i+1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). Constant space is used. AcceptedRuntime: 4 ms, faster than 100.00% of Java online submissions for First Missing Positive. Memory Usage: 37.2 MB, less than 49.02% of Java online submissions for First Missing Positive. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode31-Next Permutation]]></title>
    <url>%2F2019%2F03%2F14%2FLeetcode31-Next-Permutation%2F</url>
    <content type="text"><![CDATA[Description Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Accepted 217,486 Submissions 722,873 AlgorithmMethod First, we observe that for any given sequence that is in descending order, no next larger permutation is possible. For example, no next permutation is possible for the following array: 1[9, 5, 4, 3, 1] We need to find the first pair of two successive numbers a[i]and a[i-1], from the right, which satisfy a[i] &gt; a[i-1]. Now, no rearrangements to the right of a[i-1]a[i−1] can create a larger permutation since that subarray consists of numbers in descending order. Thus, we need to rearrange the numbers to the right of a[i-1] including itself. Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number a[i-1] with the number which is just larger than itself among the numbers lying to its right section, say a[j]. We swap the numbers a[i-1]and a[j]. We now have the correct number at index i-1. But still the current permutation isn’t the permutation that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of a[i-1]. Therefore, we need to place those numbers in ascending order to get their smallest permutation. But, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair a[i] and a[i-1] where, a[i] &gt; a[i-1]. Thus, all numbers to the right of a[i-1] were already sorted in descending order. Furthermore, swapping a[i-1] and a[j] didn’t change that order. Therefore, we simply need to reverse the numbers following a[i-1] to get the next smallest lexicographic permutation. The following animation will make things clearer: Code1234567891011121314151617181920212223242526272829public void nextPermutation(int[] nums) &#123; int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) &#123; i--; &#125; if (i &gt;= 0) &#123; int j = nums.length - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) &#123; j--; &#125; swap(nums, i, j); &#125; reverse(nums, i + 1); &#125; private void reverse(int[] nums, int start) &#123; int i = start, j = nums.length - 1; while (i &lt; j) &#123; swap(nums, i, j); i++; j--; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; Complexity Analysis Time complexity : O(N). In worst case, only two scans of the whole array are needed. Space complexity : O(1). No extra space is used. In place replacements are done. AcceptedRuntime: 7 ms, faster than 96.65% of Java online submissions for Next Permutation. Memory Usage: 38.8 MB, less than 25.58% of Java online submissions for Next Permutation. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode143-Reorder List]]></title>
    <url>%2F2019%2F03%2F13%2FLeetcode143-Reorder-List%2F</url>
    <content type="text"><![CDATA[Description Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. Accepted 144,363 Submissions 482,505 AlgorithmMethod Find the middle of the list Reverse the half after middle 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 Start reorder one by one 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4 Code1234567891011121314151617181920212223242526272829303132public void reorderList(ListNode head) &#123; if(head==null||head.next==null) return; //Find the middle of the list ListNode p1=head; ListNode p2=head; while(p2.next!=null&amp;&amp;p2.next.next!=null)&#123; p1=p1.next; p2=p2.next.next; &#125; //Reverse the half after middle 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 ListNode preMiddle=p1; ListNode preCurrent=p1.next; while(preCurrent.next!=null)&#123; ListNode current=preCurrent.next; preCurrent.next=current.next; current.next=preMiddle.next; preMiddle.next=current; &#125; //Start reorder one by one 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4 p1=head; p2=preMiddle.next; while(p1!=preMiddle)&#123; preMiddle.next=p2.next; p2.next=p1.next; p1.next=p2; p1=p2.next; p2=preMiddle.next; &#125; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(N). AcceptedRuntime: 2 ms, faster than 96.65% of Java online submissions for Reorder List. Memory Usage: 39.1 MB, less than 89.36% of Java online submissions for Reorder List. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode27-Remove Element]]></title>
    <url>%2F2019%2F03%2F13%2FLeetcode27-Remove-Element%2F</url>
    <content type="text"><![CDATA[Description Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-placewith O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: 123456&gt; Given nums = [3,2,2,3], val = 3,&gt; &gt; Your function should return length = 2, with the first two elements of nums being 2.&gt; &gt; It doesn&apos;t matter what you leave beyond the returned length.&gt; Example 2: 12345678&gt; Given nums = [0,1,2,2,3,0,4,2], val = 2,&gt; &gt; Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.&gt; &gt; Note that the order of those five elements can be arbitrary.&gt; &gt; It doesn&apos;t matter what values are set beyond the returned length.&gt; Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 123456789&gt; // nums is passed in by reference. (i.e., without making a copy)&gt; int len = removeElement(nums, val);&gt; &gt; // any modification to nums in your function would be known by the caller.&gt; // using the length returned by your function, it prints the first len elements.&gt; for (int i = 0; i &lt; len; i++) &#123;&gt; print(nums[i]);&gt; &#125;&gt; Accepted 377,642 Submissions 864,048 AlgorithmMethod Count the number of values equal to val using count The for loop evaluates each number, nums[i - count] = nums[i] , overwriting the previous data Return result Code1234567891011public int removeElement(int[] nums, int val) &#123; int count = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] == val)&#123; count++; &#125;else&#123; nums[i - count] = nums[i]; &#125; &#125; return nums.length - count; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 100.00% of Java online submissions for Remove Element. Memory Usage: 37.8MB, less than 45.50% of Java online submissions for Remove Element. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode33-Search in Rotated Sorted Array]]></title>
    <url>%2F2019%2F03%2F12%2FLeetcode33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 123&gt; Input: nums = [4,5,6,7,0,1,2], target = 0&gt; Output: 4&gt; Example 2: 123&gt; Input: nums = [4,5,6,7,0,1,2], target = 3&gt; Output: -1&gt; Accepted 375,746 Submissions 1,150,061 AlgorithmMethod if array is null or empty, return -1. Discuss each situation, a total of four return result Code1234567891011121314151617181920212223242526public int search(int[] A, int target) &#123; if (A == null || A.length == 0)&#123; return -1; &#125; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1; &#125; Complexity Analysis Time complexity : O(log n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 5 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array. Memory Usage: 38.9 MB, less than 75.73% of Java online submissions for Search in Rotated Sorted Array. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode13-Roman to Integer]]></title>
    <url>%2F2019%2F03%2F11%2FLeetcode13-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[Description Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 123456789&gt; Symbol Value&gt; I 1&gt; V 5&gt; X 10&gt; L 50&gt; C 100&gt; D 500&gt; M 1000&gt; For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 123&gt; Input: &quot;III&quot;&gt; Output: 3&gt; Example 2: 123&gt; Input: &quot;IV&quot;&gt; Output: 4&gt; Example 3: 123&gt; Input: &quot;IX&quot;&gt; Output: 9&gt; Example 4: 1234&gt; Input: &quot;LVIII&quot;&gt; Output: 58&gt; Explanation: L = 50, V= 5, III = 3.&gt; Example 5: 1234&gt; Input: &quot;MCMXCIV&quot;&gt; Output: 1994&gt; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.&gt; Accepted 371,873 Submissions 719,864 AlgorithmMethod count every Symbol and add its value to the sum, and minus the extra part of special cases. Traverse each character, plus the corresponding value Return result Code12345678910111213141516171819202122public int romanToInt(String s) &#123; int sum=0; if(s.indexOf("IV")!=-1)&#123;sum-=2;&#125; if(s.indexOf("IX")!=-1)&#123;sum-=2;&#125; if(s.indexOf("XL")!=-1)&#123;sum-=20;&#125; if(s.indexOf("XC")!=-1)&#123;sum-=20;&#125; if(s.indexOf("CD")!=-1)&#123;sum-=200;&#125; if(s.indexOf("CM")!=-1)&#123;sum-=200;&#125; char c[]=s.toCharArray(); for( int count=0;count&lt;=s.length()-1;count++)&#123; if(c[count]=='M') sum+=1000; if(c[count]=='D') sum+=500; if(c[count]=='C') sum+=100; if(c[count]=='L') sum+=50; if(c[count]=='X') sum+=10; if(c[count]=='V') sum+=5; if(c[count]=='I') sum+=1; &#125; return sum; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). Constant space is used. AcceptedRuntime: 37 ms, faster than 82.95% of Java online submissions for Roman to Integer. Memory Usage: 38.9 MB, less than 26.08% of Java online submissions for Roman to Integer. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode12-Integer to Roman]]></title>
    <url>%2F2019%2F03%2F11%2FLeetcode12-Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[Description Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 123456789&gt; Symbol Value&gt; I 1&gt; V 5&gt; X 10&gt; L 50&gt; C 100&gt; D 500&gt; M 1000&gt; For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: 123&gt; Input: 3&gt; Output: &quot;III&quot;&gt; Example 2: 123&gt; Input: 4&gt; Output: &quot;IV&quot;&gt; Example 3: 123&gt; Input: 9&gt; Output: &quot;IX&quot;&gt; Example 4: 1234&gt; Input: 58&gt; Output: &quot;LVIII&quot;&gt; Explanation: L = 50, V = 5, III = 3.&gt; Example 5: 1234&gt; Input: 1994&gt; Output: &quot;MCMXCIV&quot;&gt; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.&gt; Accepted 206,922 Submissions 414,880 AlgorithmMethod Use arrays to store every possible Roman numeral Take out each digit of num by calculation Corresponding to array subscript Return result Code1234567public String intToRoman(int num) &#123; String M[] = &#123;"", "M", "MM", "MMM"&#125;; String C[] = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; String X[] = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; String I[] = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125; Complexity Analysis Time complexity : O(1). Space complexity : O(1). Constant space is used. AcceptedRuntime: 40 ms, faster than 47.96% of Java online submissions for Integer to Roman. Memory Usage: 39.8 MB, less than 29.12% of Java online submissions for Integer to Roman. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode29-Divide Two Integers]]></title>
    <url>%2F2019%2F03%2F10%2FLeetcode29-Divide-Two-Integers%2F</url>
    <content type="text"><![CDATA[Description Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows. Accepted 181,967 Submissions 1,130,117 AlgorithmMethod Use long to avoid integer overflow cases. check the edge cases. sum = divisor, sum += sum , which equals sum = sum * 2, use multiple count result. Look for additional value for the multiple from the reminder (dividend - sum) recursively. Code123456789101112131415161718192021222324252627282930313233343536373839public int divide(int dividend, int divisor) &#123; //Reduce the problem to positive long integer to make it easier. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE)&#123; //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; else &#123; ans = (int) (sign * lans); &#125; return ans; &#125; private long ldivide(long ldividend, long ldivisor) &#123; // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) &#123; sum += sum; multiple += multiple; &#125; //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor); &#125; Complexity Analysis Time complexity : O(n). Single pass. Space complexity : O(1). Constant space is used. AcceptedRuntime: 13 ms, faster than 100.00% of Java online submissions for Divide Two Integers. Memory Usage: 38.1 MB, less than 60.82% of Java online submissions for Divide Two Integers. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetc]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode69-Sqrt(x)]]></title>
    <url>%2F2019%2F03%2F10%2FLeetcode69-Sqrt-x%2F</url>
    <content type="text"><![CDATA[Description Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned. Accepted 334,122 Submissions 1,086,877 AlgorithmMethod when x equals 0 or 1, return x use method of binary search ,from 0(low) to x(high) divide into three situations , calculate separately return res Code12345678910111213141516171819public int mySqrt(int x) &#123; if (x == 0 || x == 1)&#123; return x; &#125; return serach_sqrt(x, 0, x); &#125; private int serach_sqrt(int x, long low, long high) &#123; int res; long mid = (low + high) / 2; if (mid * mid &gt; x)&#123; res = serach_sqrt(x, low, mid); &#125;else if ((mid + 1)*(mid + 1) &gt; x)&#123; res = (int) mid; &#125;else &#123; res = serach_sqrt(x, mid + 1, high); &#125; return res; &#125; Complexity Analysis Time complexity : O(log2 x). Space complexity : O(log2 x). AcceptedRuntime: 14 ms, faster than 94.61% of Java online submissions for Sqrt(x).Memory Usage: 37.7 MB, less than 99.33% of Java online submissions for Sqrt(x). ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode15-3Sum]]></title>
    <url>%2F2019%2F03%2F09%2FLeetcode15-3Sum%2F</url>
    <content type="text"><![CDATA[Description Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Accepted 491,308 Submissions 2,092,104 AlgorithmMethod One The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. Code12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; // skip repeat answer int l = i + 1, r = nums.length - 1, sum = 0 - nums[i]; while (l &lt; r) &#123; if (nums[l] + nums[r] == sum) &#123; ls.add(Arrays.asList(nums[i], nums[l], nums[r])); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; &#125; else if (nums[l] + nums[r] &lt; sum) &#123; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; //skip repeat answer l++; &#125; else &#123; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; r--; &#125; &#125; &#125; &#125; return ls; &#125; Complexity Analysis Time complexity : O(n ^ 2). Double loop o(n ^ 2). Space complexity : O(n). Linear space is used. AcceptedRuntime: 44 ms, faster than 77.23% of Java online submissions for 3Sum.Memory Usage: 45 MB, less than 99.04% of Java online submissions for 3Sum. Method Two Waiting for the follow-up ….. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 100% beats * @param nums * @return */ public List&lt;List&lt;Integer&gt;&gt; threeSum_PLUS(int[] nums) &#123; if (nums.length &lt; 3) return Collections.emptyList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int minValue = Integer.MAX_VALUE; int maxValue = Integer.MIN_VALUE; int negSize = 0; int posSize = 0; int zeroSize = 0; for (int v : nums) &#123; if (v &lt; minValue) minValue = v; if (v &gt; maxValue) maxValue = v; if (v &gt; 0) posSize++; else if (v &lt; 0) negSize++; else zeroSize++; &#125; if (zeroSize &gt;= 3) res.add(Arrays.asList(0, 0, 0)); if (negSize == 0 || posSize == 0) return res; if (minValue * 2 + maxValue &gt; 0) maxValue = -minValue * 2; else if (maxValue * 2 + minValue &lt; 0) minValue = -maxValue * 2; int[] map = new int[maxValue - minValue + 1]; int[] negs = new int[negSize]; int[] poses = new int[posSize]; negSize = 0; posSize = 0; for (int v : nums) &#123; if (v &gt;= minValue &amp;&amp; v &lt;= maxValue) &#123; if (map[v - minValue]++ == 0) &#123; if (v &gt; 0) poses[posSize++] = v; else if (v &lt; 0) negs[negSize++] = v; &#125; &#125; &#125; Arrays.sort(poses, 0, posSize); Arrays.sort(negs, 0, negSize); int basej = 0; for (int i = negSize - 1; i &gt;= 0; i--) &#123; int nv = negs[i]; int minp = (-nv) &gt;&gt;&gt; 1; while (basej &lt; posSize &amp;&amp; poses[basej] &lt; minp) basej++; for (int j = basej; j &lt; posSize; j++) &#123; int pv = poses[j]; int cv = 0 - nv - pv; if (cv &gt;= nv &amp;&amp; cv &lt;= pv) &#123; if (cv == nv) &#123; if (map[nv - minValue] &gt; 1) res.add(Arrays.asList(nv, nv, pv)); &#125; else if (cv == pv) &#123; if (map[pv - minValue] &gt; 1) res.add(Arrays.asList(nv, pv, pv)); &#125; else &#123; if (map[cv - minValue] &gt; 0) res.add(Arrays.asList(nv, cv, pv)); &#125; &#125; else if (cv &lt; nv) break; &#125; &#125; return res; &#125; Complexity Analysis Time complexity : Waiting for the follow-up ….. Space complexity : Waiting for the follow-up ….. AcceptedRuntime: 18 ms, faster than 100.00% of Java online submissions for 3Sum.Memory Usage: 50.2 MB, less than 30.36% of Java online submissions for 3Sum. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode11-Container with Most Water]]></title>
    <url>%2F2019%2F03%2F09%2FLeetcode11-Container-with-Most-Water%2F</url>
    <content type="text"><![CDATA[Description Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 Accepted 324,381 Submissions 758,024 AlgorithmMethod ​ Initially we consider the area constituting the exterior most lines. Now, to maximize the area, we need to consider the area between the lines of larger lengths. If we try to move the pointer at the longer line inwards, we won’t gain any increase in area, since it is limited by the shorter line. ​ But moving the shorter line’s pointer could turn out to be beneficial, as per the same argument, despite the reduction in the width. This is done since a relatively longer line obtained by moving the shorter line’s pointer might overcome the reduction in area caused by the width reduction. Code12345678910111213141516171819202122/** * 利用双指针 分别进行左右遍历 * @param height * @return */ public int maxArea(int[] height) &#123; int len = height.length - 1; // calculate all length area int res = 0; int left = 0; int right = height.length - 1; while (left &lt; right)&#123; if (height[left] &lt; height[right])&#123; res = Math.max(res, height[left] * (right - left)); left++; &#125;else &#123; res = Math.max(res, height[right] * (right - left)); right--; &#125; &#125; return res; &#125; Complexity Analysis Time complexity : O(n). Single pass. Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 100.00% of Java online submissions for Container With Most Water.Memory Usage: 40.1 MB, less than 75.26% of Java online submissions for Container With Most Water. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode09-Palindrome Number]]></title>
    <url>%2F2019%2F03%2F08%2FLeetcode09-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[Description Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? Accepted 519,905 Submissions 1,234,941 AlgorithmMethod One Use a ArrayList store every number from (x % 10) Iterate through the list, returning false if not equal If no value is returned at the end of the traversal, flase is returned Code12345678910111213141516public boolean isPalindrome(int x) &#123; if (x &lt; 0)&#123; return false; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (x != 0)&#123; list.add(x % 10); x /= 10; &#125; for (int i = 0; i &lt; list.size() / 2; i++) &#123; if (list.get(i) != list.get(list.size() - 1 - i))&#123; return false; &#125; &#125; return true; &#125; Complexity Analysis Time complexity : O(lg10 n). We divided the input by 10 for every iteration, so the time complexity is O(lg10 n) Space complexity : O(1). Constant space is used. AcceptedRuntime: 74 ms, faster than 90.58% of Java online submissions for Palindrome Number.Memory Usage: 39.2 MB, less than 97.72% of Java online submissions for Palindrome Number. Method Two First of all we should take care of some edge cases. All negative numbers are not palindrome, for example: -123 is not a palindrome since the ‘-‘ does not equal to ‘3’. So we can return false for all negative numbers. Now let’s think about how to revert the last half of the number. For number 1221, if we do 1221 % 10, we get the last digit 1, to get the second to the last digit, we need to remove the last digit from 1221, we could do so by dividing it by 10, 1221 / 10 = 122. Then we can get the last digit again by doing a modulus by 10, 122 % 10 = 2, and if we multiply the last digit by 10 and add the second last digit, 1 * 10 + 2 = 12, it gives us the reverted number we want. Continuing this process would give us the reverted number with more digits. Now the question is, how do we know that we’ve reached the half of the number? Since we divided the number by 10, and multiplied the reversed number by 10, when the original number is less than the reversed number, it means we’ve processed half of the number digits. Code123456789101112public boolean isPalindrome(int x) &#123; if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; //reverse half digits int rev = 0; while (x &gt; rev) &#123; rev = rev * 10 + x % 10; x /= 10; &#125; return (x == rev) || (x == rev / 10); &#125; Complexity Analysis Time complexity : O(lg10 n). We divided the input by 10 for every iteration, so the time complexity is O(lg10 n) Space complexity : O(1). Constant space is used. AcceptedRuntime: 71 ms, faster than 99.08% of Java online submissions for Palindrome Number.Memory Usage: 39.1 MB, less than 98.69% of Java online submissions for Palindrome Number. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode07-Reverse Integer]]></title>
    <url>%2F2019%2F03%2F06%2FLeetcode07-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[Description Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321 Example 2: Input: -123Output: -321 Example 3: Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Accepted 621,383 Submissions 2,469,308 AlgorithmMethod One Get each digit of x, res records the value of x inversion Overflow if res is greater than the first n-1 digit of x Overflow if res is equal to the first n-1 digit of x and the last digit is greater than the ones of the most significant digit Return result res Code12345678910111213141516171819public int reverse(int x) &#123; int max = Integer.MAX_VALUE / 10; int min = Integer.MIN_VALUE / 10; int maxPop = Integer.MAX_VALUE % 10; int minPop = Integer.MIN_VALUE % 10; int res = 0; while (x != 0)&#123; int pop = x % 10; x = x / 10; if (res &gt; max || (res == max &amp;&amp; pop &gt; maxPop))&#123; return 0; &#125; if (res &lt; min || (res == min &amp;&amp; pop &lt; minPop))&#123; return 0; &#125; res = res * 10 + pop; &#125; return res; &#125; Complexity Analysis Time complexity : O(log10 n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 13 ms, faster than 99.99% of Java online submissions for Reverse Integer.Memory Usage: 37.9 MB, less than 71.08% of Java online submissions for Reverse Integer. Method Two Get each digit of x, res records the value of x inversion Receive the reverse value of x with long type temp to prevent overflow Return result res Code12345678910111213public int reverse_2(int x) &#123; int res = 0; while (x != 0)&#123; int pop = x % 10; x = x / 10; long temp = pop + res * 10; if (temp &gt; Integer.MAX_VALUE || temp &lt; Integer.MIN_VALUE)&#123; return 0; &#125; res = (int)temp; &#125; return res; &#125; Complexity Analysis Time complexity : O(log10 n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 13 ms, faster than 99.99% of Java online submissions for Reverse Integer.Memory Usage: 37.7 MB, less than 99.67% of Java online submissions for Reverse Integer. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode04-Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F03%2F05%2FLeetcode04-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[Description Given a 32-bit signed integer, reverse digits of an integer. Example 1: There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Accepted 389,847 Submissions 1,521,885 AlgorithmMethod A new auxiliary array res is used to store the merged results Nums1 and nums2 are traversed, and the comparison sizes are stored in res respectively Assign the remainder of a longer array to res Return result res Code123456789101112131415161718192021222324252627282930/** * 分治法节选部分思想 * @param nums1 * @param nums2 * @return */ public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] res = new int[nums1.length + nums2.length]; double result; int i = 0, j = 0, k = 0; while (i &lt;= nums1.length - 1 &amp;&amp; j &lt;= nums2.length - 1)&#123; if (nums1[i] &lt; nums2[j])&#123; res[k++] = nums1[i++]; &#125;else &#123; res[k++] = nums2[j++]; &#125; &#125; while (i &lt;= nums1.length - 1)&#123; res[k++] = nums1[i++]; &#125; while (j &lt;= nums2.length - 1)&#123; res[k++] = nums2[j++]; &#125; if (res.length % 2 == 0)&#123; result = (res[res.length / 2] + res[res.length / 2 - 1]) / 2.0; &#125;else &#123; result = res[res.length / 2]; &#125; return result; &#125; Complexity Analysis Time complexity : O(m + n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 24 ms, faster than 94.04% of Java online submissions for Median of Two Sorted Arrays.Memory Usage: 48.7 MB, less than 68.87% of Java online submissions for Median of Two Sorted Arrays. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode95-不同的二叉搜索树2]]></title>
    <url>%2F2019%2F03%2F05%2FLeetcode95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode94-二叉树的中序遍历]]></title>
    <url>%2F2019%2F03%2F04%2FLeetcode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个二叉树，返回它的中序 遍历。 示例: 123456789&gt; 输入: [1,null,2,3]&gt; 1&gt; \&gt; 2&gt; /&gt; 3&gt; &gt; 输出: [1,3,2]&gt; 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 算法思想方法一:迭代法 定义一个Integer类型list集合，存放所有的遍历值. 定义一个TreeNode类型 栈stack 存放遍历的TreeNode节点 因为是中序遍历，所以若左子树不为空且set不包含左子树（检验是否已经出栈，防止重复出栈）, cur = stack.peek().left, 赋值为左子树，并且压栈然后添加到set, 否则左子树为null , 右子树部位空，则将根节点值添加到list, 再将cur.right压栈. 若左右子树都为空，则将节点弹栈，将根节点也就是叶子节点的值添加到list. 返回list. 代码实现方法一代码1234567891011121314151617181920212223242526272829303132/** * 迭代循环 栈遍历 效率相对较低 * @param root * @return */ public List&lt;Integer&gt; inorderTraversal2(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); TreeNode cur = null; HashSet&lt;TreeNode&gt; set = new HashSet&lt;&gt;(); while(!stack.isEmpty()) &#123; if(stack.peek().left != null &amp;&amp; !set.contains(stack.peek().left)) &#123; cur = stack.peek().left; stack.push(cur); set.add(cur); &#125;else if(stack.peek().right != null) &#123; cur = stack.pop(); list.add(cur.val); stack.push(cur.right); &#125;else &#123; cur = stack.pop(); list.add(cur.val); &#125; &#125; return list; &#125; 复杂度分析时间复杂度：该算法对含有L个节点的二叉树root 进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 24% Solutionjava执行用时: 2msjava内存消耗: 37.6MB 算法思想方法二:递归法 定义一个Integer类型list集合，存放所有的遍历值. 递归调用左子树，添加根节点，递归调用右子树 返回list集合 代码实现方法二代码12345678910111213141516171819/** * 递归调用 * @param root * @return */ public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return list; &#125; if (root.left != null) &#123; list.addAll(inorderTraversal(root.left)); &#125; list.add(root.val); if (root.right != null) &#123; list.addAll(inorderTraversal(root.right)); &#125; return list; &#125; 复杂度分析时间复杂度：假设左孩子有R个, 有孩子有L个 ,该算法对二叉树进行了递归调用,所以算法时间复杂度为O(R + L) 空间复杂度：该算法对二叉树进行了递归调用，故空间复杂度为O(R + L) leetcode 85% Solutionjava执行用时: 1msjava内存消耗: 34MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode26-Remove Duplicates from Sorted Array]]></title>
    <url>%2F2019%2F03%2F04%2FLeetcode26-Remove-Duplicates-from-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Description Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in- place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i &lt; len; i++) { print(nums[i]); } Accepted 532,869 Submissions 1,341,074 AlgorithmMethod One Define times to count the number of occurrences of repeating elements For each new number that is encountered, result adds 1. TMP records the new number and overwrites the current new number to the previous one If it’s a duplicate number, times plus one Returns the result Code12345678910111213141516171819202122232425/** * 覆盖 times统计重复元素数 5ms * @param nums * @return */ public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0)&#123; return 0; &#125; int times = 0; int result = 1; // save the last number int tmp = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == tmp)&#123; times++; &#125;else &#123; result++; tmp = nums[i]; nums[i - times] = nums[i]; &#125; &#125; return result; &#125; Complexity Analysis Time complexity : O(n). Simple class. Space complexity : O(1). AcceptedRuntime: 5 ms, faster than 99.90% of Java online submissions for Remove Duplicates from Sorted Array.Memory Usage: 42 MB, less than 40.27% of Java online submissions for Remove Duplicates from Sorted Array. Method Two Since the array is already sorted, we can keep two pointers i and j, where i is the slow-runner while j is the fast-runner. As long as nums[i] = nums[j], we increment j to skip the duplicate. When we encounter nums[j] !=nums[i], the duplicate run has ended so we must copy its value to nums[i + 1], then incremented and we repeat the same process again until j reaches the end of array. Code1234567891011 public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; Complexity Analysis Time complexity : O(n). Assume that n is the length of array. Each of ii and j traverses at most n steps. Space complexity : O(1). AcceptedRuntime: 5 ms, faster than 99.90% of Java online submissions for Remove Duplicates from Sorted Array.Memory Usage: 41.5 MB, less than 56.02% of Java online submissions for Remove Duplicates from Sorted Array. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Points</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode92-反转链表2]]></title>
    <url>%2F2019%2F02%2F26%2FLeetcode92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82%2F</url>
    <content type="text"><![CDATA[问题描述 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 算法思想 先对head进行判断，如果head或head.next为null,或者m等于n,直接返回null. 通过递归将节点指针移动到第m个节点，然后将m~n的节点逆置，通过头插法将节点逆置，然后将逆置后的最后一个节点即head,与第m个节点后的链表连接起来，再将head指向prev,即逆置后的头结点. 返回得到最终结果头结点head。 代码实现123456789101112131415161718192021222324252627282930313233/** * 由反转链表得到灵感，将固定的一段链表，m到n的节点进行反转 * @param head * @param m * @param n * @return */ public ListNode reverseBetween(ListNode head, int m, int n) &#123; if (head == null || head.next == null || m == n)&#123; return head; &#125; ListNode curr = head; ListNode prev = null; ListNode next = null; int k = n - m + 1; if (m == 1) &#123; while (k-- != 0 &amp;&amp; curr != null)&#123; if (curr.next == null)&#123; next = null; &#125;else &#123; next = curr.next; &#125; curr.next = prev; prev = curr; curr = next; &#125; head.next = curr; head = prev; &#125; else &#123; head.next = reverseBetween(head.next, m - 1, n - 1); &#125; return head; &#125; 复杂度分析时间复杂度：该算法对前 n 个结点进行了一次遍历。因此时间复杂度为 O(m) 空间复杂度：因为递归调用了m次，故空间复杂度为O(m) leetcode 100% Solutionjava执行用时: 2msjava内存消耗: 36.7MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode86-分割链表]]></title>
    <url>%2F2019%2F02%2F26%2FLeetcode86-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 算法思想 先声明两个链表dummyHead1，dummyHead2，分别保存小于和大于x的节点。 再声明两个链表node1,node2,用来保存每一次遍历的节点。 最后连接两个链表，node1.next = dummyHead2.next . 返回dummyHead1.next 。 代码实现123456789101112131415161718192021public ListNode partition(ListNode head, int x) &#123; ListNode dummyHead1 = new ListNode(0); ListNode dummyHead2 = new ListNode(0); ListNode node1 = dummyHead1; ListNode node2 = dummyHead2; while (head != null) &#123; if (head.val &lt; x) &#123; node1.next = head; head = head.next; node1 = node1.next; node1.next = null; &#125; else &#123; node2.next = head; head = head.next; node2 = node2.next; node2.next = null; &#125; &#125; node1.next = dummyHead2.next; return dummyHead1.next; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 84% Solutionjava执行用时: 1msjava内存消耗: 20.5MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode23-合并k个排序链表]]></title>
    <url>%2F2019%2F02%2F24%2FLeetcode23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] 输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 算法思想方法一 定义一个头结点head, 还有一个point节点用来保存每一次遍历的头结点. 通过mergeKList函数将每两个链表合并排序 point.next = mergeKList(point.next, node), for循环遍历每一条lists里面的链表 返回head.next,去除第一个声明的 “0” 节点 代码实现方法一代码1234567891011121314151617181920212223242526/** * 效率低 260ms 55MB * 解题思想： * 从题目合并两个排序链表中得到灵感 两两合并最终得到结果 * @param lists * @return */public ListNode mergeKLists(ListNode[] lists) &#123; ListNode head = new ListNode(0); ListNode point = head; for (ListNode node : lists)&#123; point.next = mergeKList(point.next, node); &#125; return head.next; &#125;public ListNode mergeKList(ListNode l1, ListNode l2)&#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val)&#123; l1.next = mergeKList(l1.next , l2); return l1; &#125;else &#123; l2.next = mergeKList(l1, l2.next); return l2; &#125; &#125; 复杂度分析时间复杂度：该算法对含有k条链表一共 L 个结点的lists进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 31% Solutionjava执行用时: 234msjava内存消耗: 56MB 算法思想方法二 定义一个Integer类型list集合，存放所有的链表值. 利用自带的工具类Collections的sort方法，对list集合数据排序。 再构建一个新的链表result,将数据依次付给链表节点。 返回point.next,去除第一个声明的 “0” 节点 代码实现方法二代码12345678910111213141516171819202122/** * 解题思路： 将所有点的值放入一个数组中，然后对数组进行排序，再构建一个新的链表，将其返回 * @param lists * @return */ public ListNode mergeKLists(ListNode[] lists) &#123; ListNode result = new ListNode(0); ListNode point = result; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (ListNode node : lists)&#123; while (node != null)&#123; list.add(node.val); node = node.next; &#125; &#125; Collections.sort(list); for (int x : list)&#123; point.next = new ListNode(x); point = point.next; &#125; return result.next; &#125; 复杂度分析时间复杂度：假设链表数组的长度为n,该算法对含有 n 个结点的lists进行了一次遍历,时间复杂度为 O(n),Collections.sort采用TimSort算法，时间复杂度O(nlogn),所以算法时间复杂度为O(nlogn) 空间复杂度：TimSort算法空间复杂度O(n)，故空间复杂度为O(n) leetcode 72% Solutionjava执行用时: 17msjava内存消耗: 38.9MB 算法思想方法三 定义一个MSort函数对链表排序. 通过mergeTwoLists函数将每两个链表合并排序 返回结果 代码实现方法三代码123456789101112131415161718192021222324252627282930313233343536/** * 类似于快排算法，以链表以中心位置为分界，将链表数组分成两个链表数组，快速进行两两排序 * 利用两两排序函数进行排序 * @param lists * @return */ public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0)&#123; return null; &#125; return MSort(lists, 0, lists.length - 1); &#125; private ListNode MSort(ListNode[] lists, int low, int high) &#123; if (low &lt; high)&#123; int mid = (low + high) / 2; ListNode leftlist = MSort(lists, low, mid); ListNode rightlist = MSort(lists, mid + 1, high); return mergeTwoLists(leftlist, rightlist); &#125; return lists[low]; &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode res = null; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val)&#123; res = l1; l1.next = mergeTwoLists(l1.next , l2); &#125;else &#123; res = l2; l2.next = mergeTwoLists(l1, l2.next); &#125; return res; &#125; 复杂度分析时间复杂度：假设链表数组的长度为n,该算法对含有 n 个结点的lists快排比较,时间复杂度为 O(logn), mergeTwoLists时间复杂度O(L),所以算法时间复杂度为O(Llogn) 空间复杂度：mid申请了logn次，res申请了L次，故空间复杂度为O(max(L, logn)) leetcode 99.75% Solutionjava执行用时: 8msjava内存消耗: 38.6MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode82-删除排序链表中的重读元素2]]></title>
    <url>%2F2019%2F02%2F20%2FLeetcode82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E8%AF%BB%E5%85%83%E7%B4%A02%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 123&gt; 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5&gt; 输出: 1-&gt;2-&gt;5&gt; 示例 2: 123&gt; 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3&gt; 输出: 2-&gt;3&gt; 算法思想 先对head进行判断，如果head为null,直接返回null. if判断如果head.next 不为空且head.next节点值与head值相等，在while循环里进行if判断条件，head = head.next，去除重复元素，循环结束，说明head与head.next值不相等或者head.next为空，直接返回deleteDuplicates(head.next), 因为与Leetcode83不同的是不保留重复元素，即以最后一个重复元素的下一节点作为头结点继续递归循环。else 否则直接以head.next赋值当前节点下一节点继续递归调用deleteDuplicates(head.next). 返回得到最终结果头结点head。 代码实现1234567891011121314public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return null; &#125; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 98.6% Solutionjava执行用时: 1msjava内存消耗: 21.7MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode83-删除排序链表中的重读元素]]></title>
    <url>%2F2019%2F02%2F20%2FLeetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E8%AF%BB%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[问题描述 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 算法思想 先对head进行判断，如果head为null,直接返回null. if判断如果head.next 不为空且head.next节点值与head值相等，在while循环里进行if判断条件，head = head.next，去除重复元素，循环结束，说明head与head.next值不相等或者head.next为空，直接返回deleteDuplicates(head), 即以最后一个重复元素作为头结点继续递归循环。否则直接以head.next赋值当前节点下一节点继续递归调用deleteDuplicates(head.next). 返回得到最终结果头结点head。 代码实现1234567891011121314public ListNode deleteDuplicates(ListNode head) &#123; if (head == null)&#123; return null; &#125; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 100% Solutionjava执行用时: 0ms 1msjava内存消耗: 26.7MB 22.2MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode61-旋转链表]]></title>
    <url>%2F2019%2F02%2F19%2FLeetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456&gt; 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2&gt; 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; 解释:&gt; 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL&gt; 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; 示例 2: 12345678&gt; 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4&gt; 输出: 2-&gt;0-&gt;1-&gt;NULL&gt; 解释:&gt; 向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL&gt; 向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL&gt; 向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL&gt; 向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL&gt; 算法一算法思想 定义节点headPoint指向head,用while循环获得链表head的长度，用len保存。定义n赋值k % len, 如果n等于0,说明移动位置长度k是链表长度整数倍，链表不需要变动，直接返回head. n不等于0，只需要将倒数k个节点移至前面即可，定义节点flag指向head, n为需要移动的次数，而flag移动 len - n - 1即为断开处的前置节点。 定义节点tmp, 用来保存需要移动的倒数k个节点 ，tmp指向flag.next,保存倒数k个节点，断开左右两部分，flag.next = null, headPoint为右链的最后一个节点，使headPoint指向左链第一个节点head, head指向新链头结点tmp。 返回得到最终结果头结点head。 代码实现12345678910111213141516171819202122public static ListNode rotateRight(ListNode head, int k) &#123; if (head == null) return null; int len = 0; ListNode headPoint = head; while (headPoint != null &amp;&amp; headPoint.next != null)&#123; headPoint = headPoint.next; len++; &#125; len++; int n = k % len; if (n == 0) return head; ListNode flag = head; for (int i = 0; i &lt; (len - n - 1); i++) &#123; flag = flag.next; &#125; ListNode tmp; tmp = flag.next; flag.next = null; headPoint.next = head; head = tmp; return head; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历，获取其长度。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 90% Solutionjava执行用时: 5msjava内存消耗: 27.1MB 优化算法算法思想 定义节点headPoint指向head,用while循环获得链表head的长度，用len保存。定义n赋值k % len, 如果n等于0,说明移动位置长度k是链表长度整数倍，链表不需要变动，直接返回head. n不等于0，headPoint重新指向头结点head, 如果count不等于 len - n - 1, count加一，headPoint向后移动一位，headPoint = headPoint.next, 直到headPoint移动到分割点前置节点，满足count等于 len - n - 1, 节点next = headPoint.next保存右链的地址，headPoint.next = null ,断开左右链。定义节点res保存右链的头结点，通过while循环获得右链的最后一个节点，next.next = head, 将右链移动到左链前面，获得结果res. 返回得到最终结果头结点res。 代码实现1234567891011121314151617181920212223242526272829public static ListNode rotateRightPlus(ListNode head, int k) &#123; if (head == null) return null; int len = 0; ListNode headPoint = head; while (headPoint != null)&#123; headPoint = headPoint.next; len++; &#125; int n = k % len; if (n == 0) return head; int count = 0; headPoint = head; ListNode next = null; while (headPoint != null)&#123; if (count == (len - n -1))&#123; next = headPoint.next; headPoint.next = null; break; &#125; count++; headPoint = headPoint.next; &#125; ListNode res = next; while (next.next != null)&#123; next = next.next; &#125; next.next = head; return res; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 97% Solutionjava执行用时: 9msjava内存消耗: 21.9MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode25-k个一组翻转链表]]></title>
    <url>%2F2019%2F02%2F18%2FLeetcode25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 算法思想 定义四个ListNode节点,prev为前置节点，cur为当前节点，next为下一节点，check节点为了遍历长度为k的节点， canProceed统计每一次的节点长度是否有长度k . 如果canProceed等于k, 则满足有一段长度为k的链表，需要对这段链表进行逆置，否则直接返回链表即可，因为最后一段的长度小于k,不需要进行逆置。 逆置方法：当count &lt; k 且cur != null时(控制循环次数)每一次先保存当前节点的下一节点next,然后将当前节点cur指向前置节点prev,然后将前置节点指向cur,cur指向next，为下一次的循环做准备。while循环结束，如果next不为空，利用递归进行下一次的循环。 返回得到最终结果头结点head。 代码实现12345678910111213141516171819202122232425262728public ListNode reverseKGroupPlus(ListNode head, int k) &#123; ListNode prev = null; ListNode cur = head; ListNode next = null; ListNode check = head; int canProceed = 0; int count = 0; while(canProceed &lt; k &amp;&amp; check != null)&#123; check = check.next; canProceed++; &#125; if(canProceed == k)&#123; while(count &lt; k &amp;&amp; cur != null)&#123; next = cur.next; cur.next = prev; prev = cur; cur = next; count++; &#125; if(next != null)&#123; head.next = reverseKGroupPlus(next, k); &#125; return prev; &#125; else &#123; return head; &#125; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 92% Solutionjava执行用时: 5ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域与内存溢出异常]]></title>
    <url>%2F2019%2F01%2F23%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 自动内存管理机制概述对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”又是从事最基础工作的“劳动人民”——既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。 对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。 Java虚拟机原理所谓虚拟机，就是一台虚拟的机器。他是一款软件，用来执行一系列虚拟计算指令，大体上虚拟机可以分为系统虚拟机和程序虚拟机， 大名鼎鼎的Visual Box、Vmare就属于系统虚拟机，他们完全是对物理计算的仿真，提供了一个可以运行完整操作系统的软件平台。 程序虚拟机典型代码就是Java虚拟机，它专门为执行单个计算程序而计算，在Java虚拟机中执行的指令我们成为Java自己码指令。无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。Java发展至今，出现过很多虚拟机，做初Sun使用的一款叫ClassIc的Java虚拟机，到现在引用最广泛的是HotSpot虚拟机，除了Sun以外，还有BEA的Jrockit，目前Jrockit和HostSopt都被oralce收入旗下，大有整合的趋势。 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。字节码文件加载与数据区域如下图所示。 1、 类加载子系统:负责从文件系统或者网络加载Class信息，加载的信息存放在一块称之方法区的内存空间。 2、 方法区:就是存放类的信息、常量信息、常量池信息、包括字符串字面量和数字常量等。 3、 Java堆：在Java虚拟机启动的时候建立Java堆，它是Java程序最主要的内存工作区域，几乎所有的对象实例都存放到Java堆中，堆空间是所有线程共享。 4、 直接内存：JavaNio库允许Java程序直接内存，从而提高性能，通常直接内存速度会优于Java堆。读写频繁的场合可能会考虑使用。 5、 每个虚拟机线程都有一个私有栈，一个线程的Java栈在线程创建的时候被创建，Java栈保存着局部变量、方法参数、同事Java的方法调用、返回值等。 6、 本地方法栈，最大不同为本地方法栈用于本地方法调用。Java虚拟机允许Java直接调用本地方法（通过使用C语言写） 7、 垃圾收集系统是Java的核心，也是不可少的，Java有一套自己进行垃圾清理的机制，开发人员无需手工清理，后面会详细讲。 8、 PC（Program Couneter）寄存器也是每个线程私有的空间， Java虚拟机会为每个线程创建PC寄存器，它可以看作是当前线程执行的字节码的行号指示器。在任意时刻，一个Java线程总是在执行一个方法，这个方法称为当前方法，如果当前方法不是本地方法，PC寄存器总会执行当前正在被执行的指令，如果是本地方法，则PC寄存器值为Underfined，寄存器存放如果当前执行环境指针、程序技术器、操作栈指针、计算的变量指针等信息。 9、 虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般户先进行编译成机器码后执行。 堆、栈、方法区概念区别Java虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 Java堆 根据垃圾回收机制的不同，Java堆有可能拥有不同的结构，最为常见的就是将整个Java堆分为新生代和老年代。其中新声带存放新生的对象或者年龄不大的对象，老年代则存放老年对象。新生代分为den区、s0区、s1区，s0和s1也被称为from和to区域，他们是两块大小相等并且可以互相角色的空间。绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，之后每经过一次新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄后，则进入老年代。 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”，jdk8废弃永久代。在HotSpot JVM中，这次讨论的永久代，就是上图的方法区（JVM规范中称为方法区）。《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在其他JVM上不存在永久代。下图是永久代的位置。 ​ jdk8永久代变化如下图： ​ 新生代：Eden+From Survivor+To Survivor 老年代：OldGen 永久代（方法区的实现） : PermGen—–&gt;替换为Metaspace(本地内存中) 废弃永久代官方说明：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。 永久代现实易出问题：由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen。 深入理解元空间：元空间是方法区的在HotSpot jvm 中的实现，方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。，理论上取决于32位/64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数。 虚拟机参数配置在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排查会有一定的帮助，为此，在虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行Java虚拟机，就可以在系统运行时打印相关日志，用于分析实际问题。我们进行虚拟机参数配置，其实就是围绕着堆、栈、方法区、进行配置。 堆的参数配置-XX:+PrintGC 每次触发GC的时候打印相关日志 -XX:+UseSerialGC 串行回收 -XX:+PrintGCDetails 更详细的GC日志 -Xms 堆初始值 -Xmx 堆最大可用值 -Xmn 新生代堆最大可用值 -XX:SurvivorRatio 用来设置新生代中eden空间和from/to空间的比例. -XX:SurvivorRatio=eden/from=den/to== ==总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。 设置最大堆内存 参数: -Xms5m -Xmx20m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:+PrintCommandLineFlags 12345678910111213141516171819202122232425262728293031323334353637383940414243/**- jvm参数设置- @author elvis * */ public class JvmDemo01 &#123; public static void main(String[] args) throws InterruptedException &#123; byte[] b1 = new byte[1 * 1024 * 1024]; System.out.println("分配了1m"); jvmInfo(); Thread.sleep(3000); byte[] b2 = new byte[4 * 1024 * 1024]; System.out.println("分配了4m"); Thread.sleep(3000); jvmInfo(); &#125; /** - 转换为m - @param maxMemory - @return */ static private String toM(long maxMemory) &#123; float num = (float) maxMemory / (1024 * 1024); DecimalFormat df = new DecimalFormat("0.00");// 格式化小数 String s = df.format(num);// 返回的是String类型 return s; &#125; static private void jvmInfo() &#123; // 最大内存 long maxMemory = Runtime.getRuntime().maxMemory(); System.out.println("maxMemory:" + maxMemory + ",转换为M:" + toM(maxMemory)); // 当前空闲内存 long freeMemory = Runtime.getRuntime().freeMemory(); System.out.println("freeMemory:" +freeMemory+",转换为M:"+toM(freeMemory)); // 已经使用内存 long totalMemory = Runtime.getRuntime().totalMemory(); System.out.println("totalMemory:" +totalMemory+",转换为M"+toM(totalMemory)); &#125;&#125; 设置新生代与老年代优化参数 -Xmn 新生代大小，一般设为整个堆的1/3到1/4左右 -XX:SurvivorRatio 设置新生代中eden区和from/to空间的比例关系n/1 设置新生代比例参数 参数: -Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC 123456789public class JvmDemo02 &#123; public static void main(String[] args) &#123; //-Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC byte [] b = null; for (int i = 0; i &lt; 10; i++) &#123; b =new byte[1*1024*1024]; &#125; &#125;&#125; 设置新生与老年代代参数 -Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:NewRatio=2 总结:不同的堆分布情况，对系统执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。 除了可以设置新生代的绝对大小(-Xmn),可以使用(-XX:NewRatio)设置新生代和老年代的比例:-XX:NewRatio=老年代/新生代 内存溢出解决办法 设置堆内存大小 错误原因: java.lang.OutOfMemoryError: Java heap space 解决办法:设置堆内存大小 -Xms1m -Xmx70m -XX:+HeapDumpOnOutOfMemoryError 123456789101112public static void main(String[] args) throws InterruptedException &#123; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); Thread.sleep(3000); jvmInfo(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println("i:"+i); Byte [] bytes= new Byte[1*1024*1024]; list.add(bytes); jvmInfo(); &#125; System.out.println("添加成功..."); &#125; 设置栈内存大小 错误原因: java.lang.StackOverflowError 栈溢出 产生于递归调用，循环遍历是不会的，但是循环方法里面产生递归调用， 也会发生栈溢出。 解决办法:设置线程最大调用深度 -Xss5m 设置最大调用深度 123456789101112131415public class JvmDemo04 &#123; private static int count; public static void count()&#123; try &#123; count++; count(); &#125; catch (Throwable e) &#123; System.out.println("最大深度:"+count); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; count(); &#125;&#125; Tomcat内存溢出在catalina.sh 修改JVM堆内存大小 JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m” JVM参数调优总结在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置，默认情况不做任何设置JVM会工作的很好，但对一些配置很好的Server和具体的应用必须仔细调优才能获得最佳性能。通过设置我们希望达到一些目标： · GC的时间足够的小 · GC的次数足够的少 · 发生Full GC的周期足够的长 前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其衡。 针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值 年轻代和年老代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小 年轻代和年老代设置多大才算合理？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响？ · 更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC · 更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率 · 如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存溢出</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode21-合并两个有序链表]]></title>
    <url>%2F2019%2F01%2F23%2FLeetcode21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[问题描述 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 算法思想 定义两个链表 ，链表 flag 是保存结果的新表，带头结点； firstflag 是保存 flag 头节点地址的链表，while循环判断 L1 L2都不为空，分别判断当前节点的值大小 ，如果L1.val &lt; L2.val ,则用flag指向 L1 ,然后L1移到下一位 ，保存下一次遍历的地址，相反同理。然后 flag = flag.next 为下一次循环做准备。 循环结束，剩余一个链表还有数据，这时候，将first与两个链表中不为空的链表连接起来,得到就是最后的结果。 最后返回first.next,去除 flag头结点(初始化值为0)。 代码实现12345678910111213141516public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode flag = new ListNode(0); ListNode firstflag = flag; while (l1 != null &amp;&amp; l2 != null)&#123; if (l1.val &lt; l2.val)&#123; flag.next = l1; l1 = l1.next; &#125;else &#123; flag.next = l2; l2 = l2.next; &#125; flag = flag.next; &#125; flag.next = l1 != null ? l1 : l2; return firstflag.next; &#125; 复杂度分析时间复杂度：该算法对 L1 L2进行了一次遍历,假设链表L1 L2 成都分别为 r1 r2,则时间复杂度为 O(r1+r2) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 92% Solutionjava执行用时: 9ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode19-删除链表的倒数第N个节点]]></title>
    <url>%2F2019%2F01%2F23%2FLeetcode19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 算法思想 上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 最后返回头结点 dummy.next 值。 官方图解​ 代码实现1234567891011121314151617public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // Move first to the end, maintaining the gap while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next; &#125; 复杂度分析时间复杂度：该算法对含有 LL 个结点的列表进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 98% Solutionjava执行用时: 8ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode02-两数相加]]></title>
    <url>%2F2019%2F01%2F22%2FLeetcode02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[问题描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 算法思想 定义链表 rs 用以返回结果，定义链表 last 记录 上一次的链表求和值，并且记录 rs 中 next的指针地址，否则 rs 的 next 地址会被新的值覆盖 ；定义链表 cur 记录当前链表 L1 , L2 两位求和的值 。定义val 表示每一次对应位数上的求和值。 分别判断 L1 L2是否为空，分别 L1 L2 的 val值 求和计算 。第一次循环时，先将 rs 指向 cur ,这样就有了初始地址 ，然后依次 先用 last.next = cur,等价于 rs.next = cur ，再 last = cur 使 last记录下 下一次循环时的 上一次的引用地址 || 就是last指向 rs 的尾节点。 最后得到计算结果链表 rs , 返回 rs 值。 代码实现1234567891011121314151617181920212223242526272829public ListNode addTwoNumbers(ListNode l1, ListNode l2)&#123; ListNode rs = null; ListNode last = null; ListNode cur = null; int val = 0; while (null != l1 || null != l2)&#123; if (null != l1)&#123; val += l1.val; l1 = l1.next; &#125; if (null != l2)&#123; val += l2.val; l2 = l2.next; &#125; cur = new ListNode(val % 10); val = val / 10; if (null == last)&#123; rs = cur; &#125;else &#123; last.next = cur; &#125; last = cur; &#125; if (val &gt; 0)&#123; cur = new ListNode(val); last.next = cur; &#125; return rs; &#125; 复杂度分析时间复杂度：因为while循环遍历的次数是线性的，假设L1与L2的最大长度为 r , 则时间复杂度为O(r) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 92% Solutionjava执行用时: 31ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode84-柱状图最大矩形问题]]></title>
    <url>%2F2019%2F01%2F20%2FLeetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述​ 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 单调栈首先引入单调栈的概念，本文解法使用了递增栈的概念。 单调栈的定义：单调栈就是栈内元素单调递增或者单调递减的栈，单调栈只能在栈顶操作 单调栈的维护是 O(n) 级的时间复杂度，因为所有元素只会进入栈一次，并且出栈后再也不会进栈了。 单调栈的性质： 单调栈里的元素具有单调性 元素加入栈前，会在栈顶端把破坏栈单调性的元素都删除 使用单调栈可以找到元素向左遍历第一个比他小的元素，也可以找到元素向左遍历第一个比他大的元素。 由于单调栈中的元素只能是单调递增或者是单调递减的，所以我们可以分别讨论这两种情况（假设不存在两个相同的元素）： 当单调栈中的元素是单调递增的时候，根据上面我们从数组的角度阐述单调栈的性质的叙述，可以得出： 当a &gt; b 时，则将元素a插入栈顶，新的栈顶则为a 当a &lt; b 时，则将从当前栈顶位置向前查找（边查找，栈顶元素边出栈），直到找到第一个比a小的数，停止查找，将元素a 插入栈顶（在当前找到的数之后，即此时元素a找到了自己的“位置”） 当单调栈中的元素是单调递减的时候，则有： 当a &lt; b 时，则将元素a插入栈顶，新的栈顶则为a 当a &gt; b 时，则将从当前栈顶位置向前查找（边查找，栈顶元素边出栈），直到找到第一个比a大的数，停止查找，将元素a 插入栈顶（在当前找到的数之后，即此时元素a找到了自己的“位置”）来源：CSDN原文：https://blog.csdn.net/liujian20150808/article/details/50752861 算法思想 首先定义一个Integer类型的栈，用以装载矩形高度数组的下标。对每一个矩形高度进行遍历，while循环首先判断确保栈不为空且当前遍历元素小于等于栈顶元素（即元素高度违反递增栈的排放高度）, 若满足条件，则首先弹栈并用 j 记录弹栈元素的值 ，用k 记录当前栈顶元素的值（栈空赋值-1），用curArea记录当前元素(矩形高度，矩形块)到栈顶元素（每一次出栈前的最大值高度，如第一次最大值2，第二次最大值6），用栈顶元素下标的下一位 i 来定位到栈顶元素的下标，这样就能计算出当前元素到栈顶元素最大矩形面积，若栈为空或元素高度符合递增栈，则依次将数组高度压栈。 然后循环遍历栈，在进行第一步后，因为最后一次进栈形成的递增栈没有遍历记录最大面积，并且没有对整体的面积(就是选取最低的元素 * 数组长度) ，事实上，在第一步完成之后，栈底元素就是整个heights数组中最小的高度值，因为比它先出栈的元素大于它，栈内其他元素因为是递增栈故也大于它。然后如同第一步，这时候栈顶元素的位置为heights.length - 1 ，最后一次循环，栈底元素出栈，面积curArea为数组长度 * heights[i] ,最后得到最大值 res 。 最后得到接雨水总量 res , 返回 res 值。 代码实现1234567891011121314151617181920public int largestRectangleArea(int[] heights) &#123; if(heights.length == 0 || heights == null) return 0; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int res = 0; for(int i = 0; i &lt; heights.length; i++)&#123; while(!s.isEmpty() &amp;&amp; heights[i] &lt;= heights[s.peek()])&#123; int j = s.pop(); int k = s.isEmpty() ? -1 : s.peek(); int curArea = (i - k - 1) * heights[j]; res = Math.max(res, curArea); &#125; s.push(i); &#125; while(!s.isEmpty())&#123; int i = s.pop(); int k = s.isEmpty() ? - 1 : s.peek(); int curArea = (heights.length - k - 1) * heights[i]; res = Math.max(res, curArea); &#125; return res; 复杂度分析时间复杂度：单调栈的维护是 O(n) 级的时间复杂度，因为所有元素只会进入栈一次，并且出栈后再也不会进栈了。因此while循环遍历的次数是线性的，故时间复杂度为O(n) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 83% Solutionjava执行用时: 20ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>stack</tag>
        <tag>递增栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode42-接雨水问题]]></title>
    <url>%2F2019%2F01%2F18%2FLeetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述​ 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，记数组名为 height.在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 算法思想 先排除首尾不可能接雨水的部分，对于左端，从下标0处开始遍历，找到第一个下标 L 使得 height[ L ] &gt; height[ L + 1 ] , 因为只有从这个下标开始，它的右边才会积水， 否则因为左侧没有“墙”，故无法积水 。对于右端 ， 从下标height.length - 1 处开始遍历，找到第一个下标 R 使得 height[ R ] &gt; height[ R - 1 ] , 因为只有从这个下标开始，它的左边才会积水， 否则因为右侧没有“墙”而无法积水 。 第一步找到了左端坐标 L , 右端坐标 R , while循环遍历，每一次用left与right记录左右端下标对应的高度，即height[ L ] , height[ R ] , 当left &lt; right时（左端点高度小于右端点高度），移动坐标L , 若 height[ ++L ] &lt;= left ,则将雨水面积 left - height[ L ] 加到 ans (接雨水总量) 上；同理，当 left &gt; right 时（左端点高度大于右端点高度），移动坐标R , 若 height[ –R ] &lt;= right ,则将雨水面积right - height[ R ]加到ans (接雨水总量) 上。 最后得到接雨水总量 ans , 返回 ans 值。 代码实现12345678910111213141516171819202122232425public int trap(int [] height)&#123; if (height.length &lt; 3) return 0; int ans = 0; int l = 0, r = height.length - 1; //find the left and right edge which can hold water while (l &lt; r &amp;&amp; height[l] &lt;= height[l + 1]) l++; while (l &lt; r &amp;&amp; height[r] &lt;= height[r - 1]) r--; while (l &lt; r)&#123; int left = height[l]; int right = height[r]; if (left &lt;= right)&#123; // add volum until an edge larger than the left edge while (l &lt; r &amp;&amp; left &gt;= height[++l])&#123; ans += left - height[l]; &#125; &#125;else &#123; // add volum until an edge larger than the right edge while (l &lt; r &amp;&amp; height[--r] &lt;= right)&#123; ans += right - height[r]; &#125; &#125; &#125; return ans; &#125; 复杂度分析时间复杂度：因为while循环遍历的次数是线性的，故时间复杂度为O(n) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 98% Solutionjava执行用时: 12ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴与四十大盗-背包问题]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%8E%E5%9B%9B%E5%8D%81%E5%A4%A7%E7%9B%97-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[阿里巴巴与四十大盗-背包问题 有一天，阿里巴巴赶着一头毛驴上山砍柴。砍好柴准备下山时，远处突然出现一股烟尘，弥漫着直向上空飞扬，朝他这儿卷过来，而且越来越近。靠近以后，他才看清原来是一支马队，他们共有四十人，一个个年轻力壮、行动敏捷。一个首领模样的人背负沉重的鞍袋，从丛林中一直来到那个大石头跟前，喃喃地说道：“芝麻，开门吧！”随着那个头目的喊声，大石头前突然出现一道宽阔的门路，于是强盗们鱼贯而入。阿里巴巴待在树上观察他们，直到他们走得无影无踪之后，才从树上下来。他大声喊道：“芝麻，开门吧！”他的喊声刚落，洞门立刻打开了。他小心翼翼地走了进去，一下子惊呆了，洞中堆满了财物，还有多得无法计数的金银珠宝，有的散堆在地上，有的盛在皮袋中。突然看见这么多的金银财富，阿里巴巴深信这肯定是一个强盗们数代经营、掠夺所积累起来的宝窟。为了让乡亲们开开眼界，见识一下这些宝物，他想一种宝物只拿一个，如果太重就用锤子凿开，但毛驴的运载能力是有限的，怎么才能用驴子运走最大价值的财宝分给穷人呢？ 阿里巴巴陷入沉思中…… 问题分析假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v，毛驴运载能力有限，只能运走m重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？ 我们可以尝试贪心策略： （1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？ （2）每次挑选重量最小的宝物装入，能否得到最优解？ （3）每次选取单位重量价值最大的宝物，能否使价值最高？ 思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限的，所以第1种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在总重限制的情况下保证价值最大，第2种策略舍弃；而第3种是每次选取单位重量价值最大的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量m，那么一定能得到价值最大。 因此采用第3种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。 算法设计（1）数据结构及初始化。将n种宝物的重量和价值存储在结构体three（包含重量、价值、性价比3个成员）中，同时求出每种宝物的性价比也存储在对应的结构体three中，将其按照性价比从高到低排序。采用sum来存储毛驴能够运走的最大价值，初始化为0。 （2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于m（毛驴运载能力），如果小于m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m减去放入宝物的重量；如果不小于m，则取该宝物的一部分m p[i]，m=0，程序结束。m减少到0，则sum*得到最大值。 完美图解性价比排序因为贪心策略是每次选择性价比（价值/重量）高的宝物，可以按照性价比降序排序，排序后如下表所示。 宝物 i 重量 w[i] 价值v[i] 性价比p[i] 2 2 8 4 10 5 15 3 6 8 20 2.5 3 9 18 2 5 5 8 1.6 8 4 6 1.5 9 5 7 1.4 4 5 6 1.2 7 5 5 1 1 4 3 0.75 依据贪心策略，选择宝物按照贪心策略，每次选择性价比高的宝物放入： 第1次选择宝物2，剩余容量30−2=28，目前装入最大价值为8。 第2次选择宝物10，剩余容量28−5=23，目前装入最大价值为8+15=23。 第3次选择宝物6，剩余容量23−8=15，目前装入最大价值为23+20=43。 第4次选择宝物3，剩余容量15−9=6，目前装入最大价值为43+18=61。 第5次选择宝物5，剩余容量6−5=1，目前装入最大价值为61+8=69。 第6次选择宝物8，发现上次处理完时剩余容量为1，而8号宝物重量为4，无法全部放入，那么可以采用部分装入的形式，装入1个重量单位，因为8号宝物的单位重量价值为1.5，因此放入价值1×1.5=1.5，你也可以认为装入了8号宝物的1/4，目前装入最大价值为69+1.5=70.5，剩余容量为0。 构造最优解把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了8号财宝的1/4），能够装入宝物的最大价值为70.5。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Knapsack_problem implements Comparable&lt;Knapsack_problem&gt; &#123; public static final int n = 10; //宝物个数 public static double m = 30; //毛驴承载能力 double w;//每个宝物的重量 double v;//每个宝物的价值 double p;//性价比 public Knapsack_problem()&#123;&#125; public double getW() &#123; return w; &#125; public double getV() &#123; return v; &#125; public double getP() &#123; return p; &#125; @Override public int compareTo(Knapsack_problem kp) &#123; return kp.getP() &gt; this.getP() ? 1 : -1; &#125; public static void input(List&lt;Knapsack_problem&gt; list)&#123; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; Knapsack_problem.n; i++) &#123; Knapsack_problem kp = new Knapsack_problem(); System.out.print("请输入第"+(i + 1)+"个宝物的重量: "); kp.w = sc.nextDouble(); System.out.print("请输入第"+(i + 1)+"个宝物的价值: "); kp.v = sc.nextDouble(); kp.p = kp.v / kp.w; list.add(i, kp); &#125; &#125; public static double maxSum(List&lt;Knapsack_problem&gt; list)&#123; double sum = 0.0; //记录贪心算法运走宝物价值之和 for (int j = 0; j &lt; Knapsack_problem.n; j++) &#123; double w = list.get(j).getW(); double v = list.get(j).getV(); double p = list.get(j).getP(); if (m &gt; w)&#123; m -= w; sum += v; &#125;else &#123; sum += m * p; break; &#125; &#125; return sum; &#125; public static void main(String[] args) &#123; List&lt;Knapsack_problem&gt; list = new ArrayList&lt;&gt;(); input(list); Collections.sort(list); //已经按照性价比排序 double sum = maxSum(list); System.out.println("能够装入宝物的最大价值为:" + sum); &#125;&#125; 运行结果 运行结果图如上所示 算法解析算法复杂度分析 时间复杂度：该算法的时间主要耗费在将宝物按照性价比排序上，采用的是TimSort排序，算法平均时间复杂度为O(nlogn) ，最好情况是O(n) , 最差情况是 O(nlogn). 空间复杂度：空间主要耗费在存储宝物的性价比，空间复杂度为O(n) 为了使 m 重量里的所有物品的价值最大，利用贪心思想，每次取剩下物品里面性价比最高的物品，这样可以使得在相同重量条件下比选其他物品所得到的价值更大，因此采用贪心策略能得到最优解。]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人之初,性本贪]]></title>
    <url>%2F2019%2F01%2F17%2F%E4%BA%BA%E4%B9%8B%E5%88%9D-%E6%80%A7%E6%9C%AC%E8%B4%AA%2F</url>
    <content type="text"><![CDATA[人之初，性本贪 我们小时候背诵《三字经》，“人之初，性本善，性相近，习相远。“ 其实我们很多时候”人之初，性本贪“。小孩子吃糖果，总是想要多多的；吃水果，想要最大的；买玩具，总是想要最好的，这些东西不是大人教的，而是与生俱来的。对美好事物的趋优性，就像植物的趋光性，”良禽择木而栖，贤臣择主而事“ “窈窕淑女，君子好逑”，我们似乎永远在追求美而优的东西。现实中的很多事情，正是因为趋优性使我们的生活一步一步走向美好。例如，我们竭尽所能买了一套房子，然后就想要添置一套家具，再就想着可能还需要一辆车子…… ​ 凡事都有两面性，一把刀可以做出美味佳肴，也可以变成杀人凶器。在这里，我们只谈好的“贪心”。 贪心本质 一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。 ———— 《算法导论》 ​ 贪心算法在解决问题的策略上“目光短浅”，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心算法并不是从整体最优考虑，它做出的选择只是在某种意义上的局部最优。贪心算法能得到许多问题的整体最优解或整体最优解的近似解。因此，贪心算法在实际中得到了大量的应用。 ​ 在贪心算法中，我们需要注意以下几个问题。 ​ (1) 没有后悔药。一旦做出选择，不可以反悔。 ​ (2) 有可能得到的不是最优解，而是最优解的近似解。 ​ (3) 选择什么样的贪心策略，直接决定算法的好坏。 贪亦有道​ “君子爱财，取之有道”，我们在贪心算法中“贪亦有道”。通常我们在遇到具体问题时，往往分不清哪些问题该用贪心策略求解，哪些问题不能使用贪心策略。经过实践我们发现，利用贪心算法求解的问题往往具有两个重要的特性：贪心选择性质和最优子结构性质。如果满足这两个性质就可以使用贪心算法了。 (1)贪心选择 ​ 所谓贪心选择性质是指原问题的整体最优解可以通过一系列局部最优的选择得到。应用同一规则，将原问题变为一个相似的但规模更小的子问题，而后的每一步都是当前最佳的选择。这种选择依赖于已做出的选择，但不依赖于未做出的选择。运用贪心策略解决的问题在程序的运行过程中无回溯过程。关于贪心选择性质，读者可在后续的贪心策略状态空间图中得到深刻的体会。 (2)最优子结构 ​ 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。例如原问题S={a1，a2，…，ai，…，an}，通过贪心选择选出一个当前最优解{ai}之后，转化为求解子问题S−{ai}，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质，如下图所示。 ​ 贪心算法秘籍武林中有武功秘籍，算法中也有贪心秘籍。上面我们已经知道了具有贪心选择和最优子结构性质就可以使用贪心算法，那么如何使用呢？下面介绍贪心算法秘籍。 (1)贪心策略 ​ 首先要确定贪心策略，选择当前看上去最好的一个方案。例如，挑选苹果，如果你认为个大的是最好的，那你每次都从苹果堆中拿一个最大的，作为局部最优解，贪心策略就是选择当前最大的苹果；如果你认为最红的苹果是最好的，那你每次都从苹果堆中拿一个最红的，贪心策略就是选择当前最红的苹果。因此根据求解目标不同，贪心策略也会不同。 (2)局部最优解 ​ 根据贪心策略，一步一步地得到局部最优解。例如，第一次选一个最大的苹果放起来，记为a1，第二次再从剩下的苹果堆中选择一个最大的苹果放起来，记为a2，以此类推。 (3) 全局最优解 ​ 把所有的局部最优解合成为原来问题的一个最优解（a1，a2，…）。]]></content>
      <categories>
        <category>趣学算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始mybatis]]></title>
    <url>%2F2019%2F01%2F15%2F%E5%88%9D%E5%A7%8Bmybatis%2F</url>
    <content type="text"><![CDATA[１.Mybatis介绍MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 ２.jdbc问题总结如下：1、数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。2、Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。3、使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。4、对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 ３ mybatis解析 1、mybatis配置SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。2、通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂3、由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。4、mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。5、Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。6、Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。7、Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 ４ 初识sqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132~~~&lt;configuration&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; 数据库资源文件引入 &lt;!-- 别名 包以其子包下所有类 头字母大小都行--&gt; &lt;typeAliases&gt;&lt;!-- &lt;typeAlias type=&quot;User&quot; alias=&quot;User&quot;/&gt; --&gt; &lt;package name=&quot;com.elvis.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis01?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;test&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- Mapper的位置 Mapper.xml 写Sql语句的文件的位置 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;&lt;!-- &lt;mapper resource=&quot;sqlmap/User.xml&quot; class=&quot;&quot; url=&quot;&quot;/&gt; --&gt; &lt;!--&lt;mapper class=&quot;UserMapper&quot; /&gt; --&gt;&lt;!-- &lt;mapper url=&quot;&quot; /&gt; --&gt; &lt;package name=&quot;com.elvis.mybatis.mapper&quot;/&gt;推荐 &lt;/mappers&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不念过去,不畏将来]]></title>
    <url>%2F2019%2F01%2F15%2F%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%8E%BB-%E4%B8%8D%E7%95%8F%E5%B0%86%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[​ 岁月如歌，转眼已过了多年;时光荏苒，恍惚却不知所措;初来学校，满怀一生梦想;物是人非，已不再是曾经。￼有人说人们随着年龄的增长会越来越念旧，会去忍不住回想青春时期的往事。我认为处于任何年龄阶段的人们都可能会有这种情感，或许在某个时间段里这种情感会愈发地强烈。 听闻，我们我们用初中三年去盼望高中三年，高中三年去憧憬大学四年，而用大学四年去怀念中学六年年，最终用一生去惦记我们的青春。 愿我们经历着、成长着。虽然也说也笑也哭过，但愿从未畏惧过，世界很美好，偶尔怀念过去，也别停止前行，因为未来更精彩。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>青春</tag>
      </tags>
  </entry>
</search>
