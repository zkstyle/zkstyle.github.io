{"meta":{"title":"Elvis's Blogs","subtitle":"研一狗的日常","description":"Stay hungry, stay foolish","author":"zkstyle","url":"https://www.vazh.cn"},"pages":[{"title":"categories","date":"2019-01-14T02:28:27.000Z","updated":"2019-01-16T01:07:35.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.vazh.cn/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-01-14T06:05:27.000Z","updated":"2019-03-13T02:47:01.000Z","comments":false,"path":"about/index.html","permalink":"https://www.vazh.cn/about/index.html","excerpt":"","text":"努力的去成为并保持自己喜欢的样子，对生活不失去热情，对工作认真-负责-高效，将来的我，一定会感激现在拼命努力的自己~ 关于我教育经历： ​ 2014.9 - 2018.6 湖北大学 软件工程 ​ 2018.9 - 至今 武汉大学 软件工程在读 目前的我： 爱生活，爱音乐，爱coding。 关于我的博客 积累自己平时用到的知识 ,记录自己不断学习的足迹。 每天Leetcode题练习，喜欢刷题的小伙伴加我一起交流。 联系我 Ⅰ. Leave me a message in this page. 多说停用，插件正在升级… Ⅱ. Send to me.（Email: 712338173@qq.com） Ⅲ. Contact me.（QQ：712338173）（常年在线，昼夜不息。验证：elvis） 最近访客"},{"title":"","date":"2018-07-10T08:36:26.000Z","updated":"2019-01-13T05:44:26.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.vazh.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode04-寻找两个有序数组的中位数","slug":"Leetcode04-寻找两个有序数组的中位数","date":"2019-11-07T06:27:43.000Z","updated":"2019-11-17T06:58:32.990Z","comments":true,"path":"2019/11/07/Leetcode04-寻找两个有序数组的中位数/","link":"","permalink":"https://www.vazh.cn/2019/11/07/Leetcode04-寻找两个有序数组的中位数/","excerpt":"","text":"问题描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 算法思想为了解决这个问题，我们需要理解 “中位数的作用是什么”。在统计中，中位数被用来： 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 如果理解了中位数的划分作用，我们就很接近答案了。 首先，让我们在任一位置 iii 将 A\\text{A}A 划分成两个部分： left_A | right_A A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 由于 A 中有 m 个元素， 所以我们有 m+1种划分的方法（i=0∼m）。 我们知道： len(left_A) = i, len(right_A) = m−i 注意：当 i=0 时，left_A 为空集， 而当 i=m 时, right_A 为空集。 采用同样的方式，我们在任一位置 j将 B 划分成两个部分： left_B | right_B B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 将 left_A 和 left_B放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part： left_part | right_part A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们可以确认： len(left_part) = len(right_part) max⁡(left_part)≤min⁡(right_part) 那么，我们已经将 {A,B}中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么： $$median=\\frac{max(left_part)+min(right_part)}{2}$$要确保这两个条件，我们只需要保证： $$i+j=m−i+n−j（或：m - i + n - j + 1 )$$ $$如果 n≥m，只需要使 i = 0 ~ m,\\ j = \\frac{m + n + 1}{2} - i$$ $$\\text{B}[j-1] \\leq \\text{A}[i] 和 \\text{A}[i-1] \\leq \\text{B}[j]$$ ps.1 为了简化分析，我假设 A[i−1],B[j−1],A[i],B[j]总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。我将在最后讨论如何处理这些临界值。 ps.2 为什么 n≥m？由于0≤i≤m 且$$j= \\frac{m + n + 1}{2} - i$$ 我必须确保 j 不是负数。如果 n&lt;m，那么 j 将可能是负数，而这会造成错误的答案。 所以，我们需要做的是： 在 [0，m]中搜索并找到目标对象 i，以使： $$B[j−1]≤A[i] 且 \\text{A}[i-1] \\leq \\text{B}[j], 其中 j = \\frac{m + n + 1}{2} - i$$ 接着，我们可以按照以下步骤来进行二叉树搜索： 设 imin=0，imax=m, 然后开始在 [imin,imax]中进行搜索。 令$$ i = \\frac{\\text{imin} + \\text{imax}}{2}, j = \\frac{m + n + 1}{2} - i $$ 现在我们有 len(left_part)=len(right_part)。 而且我们只会遇到三种情况： B[j−1]≤A[i] 且 A[i−1]≤B[j]：这意味着我们找到了目标对象 i，所以可以停止搜索。 B[j−1]&gt;A[i]：这意味着 A[i]太小，我们必须调整 i 以使 B[j−1]≤A[i]。我们可以增大 i 吗？ 是的，因为当 i 被增大的时候，j 就会被减小。 因此 B\\[j−1] 会减小，而 A\\[i] 会增大，那么 B\\[j−1\\]≤A\\[i]就可能被满足。 我们可以减小 i吗？ 不行，因为当 i 被减小的时候，j就会被增大。 因此 B\\[j−1] 会增大，而 A\\[i]会减小，那么 B\\[j−1\\]≤A\\[i]就可能不满足。 所以我们必须增大 i。也就是说，我们必须将搜索范围调整为 [i+1,imax]。因此，设 imin=i+1，并转到步骤 2。 A[i−1]>B[j]：这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1]≤B[j]。也就是说，我们必须将搜索范围调整为 [imin,i−1]。因此，设 imax=i−1，并转到步骤 2。 当找到目标对象 i 时，中位数为： max⁡(A[i−1],B[j−1]), 当 m+n为奇数时 $$\\frac{max(A[i−1],B[j−1])+min(A[i],B[j])}{2} , 当m+n为偶数时$$ 现在，让我们来考虑这些临界值 i = 0,i = m, j = 0, j = n，此时A[i − 1], B[j − 1], A[i], B[j] 可能不存在。其实这种情况⽐你想象的要容易得多。其实这种情况比你想象的要容易得多。 我们需要做的是确保 max(left_part)≤min(right_part)。 因此，如果i 和 j 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j]全部存在）, 那么我们必须同时检查 B[j−1]≤A[i]以及 A[i−1]≤B[j]是否成立。但是如果 A[i−1],B[j−1],A[i],B[j]中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。举个例子，如果 i=0，那么 A[i−1] 不存在，我们就不需要检查 A[i−1]≤B[j]是否成立。所以，我们需要做的是： 在 [0，m]中搜索并找到目标对象 i，以使： (j =0 or i =m or B[j−1]≤A[i]) 或是(i =0 or j =n or A[i−1]≤B[j]), 其中$$j = \\frac{m + n + 1}{2} - i$$ 在循环搜索中，我们只会遇到三种情况： (j =0 or i =m or B[j−1]≤A[i]) 或是 (i =0 or j =n or A[i−1]≤B[j])，这意味着 i 是完美的，我们可以停止搜索。 j>0 and iA[i] 这意味着 i 太小，我们必须增大它。 i>0 and jB[j] 这意味着 i 太大，我们必须减小它。 i&lt;m⟹ j>0 以及 i>0 ⟹ j&lt;n 始终成立，这是因为： $$m≤n, i&lt;m⟹j= \\frac{m+n+1}{2} - i &gt; \\frac{m+n+1}{2} - m ≥ \\frac{2m+1}{2} - m ≥ 0$$ $$m≤n, i&gt;0⟹j= \\frac{m+n+1}{2} - i &lt;\\frac{m+n+1}{2} ≤ \\frac{2n+1}{2} ≤ n$$ 所以，在情况 2 和 3中，我们不需要检查 j>0 或是 j&lt;n 是否成立。 代码实现12345678910111213141516171819202122232425262728293031323334public double findMedianSortedArrays_P(int[] A, int[] B) &#123; int m = A.length; int n = B.length; if (m &gt; n) &#123; // to ensure m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i])&#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = B[j-1]; &#125; else if (j == 0) &#123; maxLeft = A[i-1]; &#125; else &#123; maxLeft = Math.max(A[i-1], B[j-1]); &#125; if ( (m + n) % 2 == 1 ) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = B[j]; &#125; else if (j == n) &#123; minRight = A[i]; &#125; else &#123; minRight = Math.min(B[j], A[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125; 复杂度分析 时间复杂度：O(log⁡(min(m,n)))，首先，查找的区间是 [0,m]。而该区间的长度在每次循环之后都会减少为原来的一半。所以，我们只需要执行 log⁡(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log⁡(m))。由于 m≤n ，所以时间复杂度是 O(log⁡(min(m,n)))。 空间复杂度：O(1 ，我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1) 。 leetcode 99% Solution执行用时 :3 ms, 在所有 java 提交中击败了99.23%的用户 内存消耗 :47 MB, 在所有 java 提交中击败了94.74%的用户 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://www.vazh.cn/tags/二分查找/"},{"name":"数组","slug":"数组","permalink":"https://www.vazh.cn/tags/数组/"}]},{"title":"Leetcode257-二叉树的所有路径","slug":"Leetcode275-二叉树的所有路径","date":"2019-09-04T01:48:42.000Z","updated":"2019-09-04T04:42:56.646Z","comments":true,"path":"2019/09/04/Leetcode275-二叉树的所有路径/","link":"","permalink":"https://www.vazh.cn/2019/09/04/Leetcode275-二叉树的所有路径/","excerpt":"","text":"Description 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \\2 3 \\ 5 输出: [“1-&gt;2-&gt;5”, “1-&gt;3”] 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 Method 如果二叉树为空,返回空的list 深度遍历二叉树,如果左右孩子节点为空 则为叶子节点 字符串拼接 s += root.val + “-&gt;”; 拼接每一次的值 如果左子树不为空 深度搜索 如果右子树不为空 深度搜索 12345678910111213141516171819public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; dfs(root, list, \"\"); return list; &#125; private void dfs(TreeNode root, List&lt;String&gt; list, String s)&#123; if (root.left == null &amp;&amp; root.right == null)&#123; list.add(s + root.val); return; &#125; s += root.val + \"-&gt;\"; if (root.left != null) dfs(root.left, list, s); if (root.right != null) dfs(root.right, list, s); &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(1). AcceptedRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths. Memory Usage: 36.4 MB, less than 100.00% of Java online submissions for Binary Tree Paths. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.vazh.cn/tags/DFS/"},{"name":"BST","slug":"BST","permalink":"https://www.vazh.cn/tags/BST/"}]},{"title":"垃圾收集器与内存分配策略-深入理解JVM","slug":"垃圾收集器与内存分配策略-深入理解JVM","date":"2019-08-29T11:56:03.000Z","updated":"2019-09-04T02:48:56.867Z","comments":true,"path":"2019/08/29/垃圾收集器与内存分配策略-深入理解JVM/","link":"","permalink":"https://www.vazh.cn/2019/08/29/垃圾收集器与内存分配策略-深入理解JVM/","excerpt":"","text":"​ 最近在看周志明老师的《深入理解Java虚拟机》，准备留下一些学习笔记，供以后复习用。以下内容主要来自于《深入理解Java虚拟机》第三章–垃圾收集器与内存分配策略。 一 学习目标 对象存活判断算法 GC（garbage collection）算法学习 垃圾回收器 内存分配与回收策略 对于GC学习,我们主要考虑三个问题：哪些内存需要回收 -&gt; 什么时候回收 -&gt; 如何回收 二 那些内存需要回收 内存运行时，程序计数器、本地方法栈和虚拟机栈是随着线程的产生而产生，随着线程的消亡而消亡的，这几部分的内存分配和回收是确定好了的，随方法结束或线程结束时，内存就紧跟着回收了。而Java堆和方法区不一样。一个接口中多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在运行期间才知道会创建哪些对象，故内存回收与分配重点关注的是堆内存和方法区内存。 三.什么时候回收（判断对象的存活）对于方法区，永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 对于堆，其中存放的是对象实例，对于对象实例的回收，我们首先要判断哪些对象是“存活的”，对于那部分“死亡的”对象，就是我们要回收的。判断对象的存活有两种方法： 引用计数算法 可达性分析算法 引用计数算法给对象添加一个引用计数器, 每当有一个地方引用它时, 计数器值+1, 引用失效, -1, 为0的对象不能被使用。 优势：实现简单，效率高。 缺点：无法解决对象相互引用的问题——会导致对象的引用虽然存在，但是已经不可能再被使用，却无法被回收。 可达性分析算法通过一系列的称为“GC Roots”的对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链(Reference Chain), 当一个对象到GC Roots不可达(也就是不存在引用链)的时候, 证明对象是不可用的。如下图: Object5、6、7 虽然互有关联, 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。（注意：不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记） 在Java, 可作为GC Roots的对象包括： 方法区: 类静态属性引用的对象; 方法区: 常量引用的对象; 虚拟机栈(本地变量表)中引用的对象. 本地方法栈JNI(Native方法)中引用的对象。 四 如何回收-垃圾收集算法1.标记清除算法 分为标记和清除两个阶段，先标记出需要回收的对象（可达性分析算法或者引用计数算法），在标记完成后统一回收所有被标记的对象。 不足之处：效率问题，标记和清除效率都不高。空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。 2.复制算法 将可用内存划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还存活的复制到另一块上，然后将这一块一次性清除。商业虚拟机都是采用该方法来回收新生代，新生代98%都是朝生夕死的。将内存分为较大Eden和两个较小的survivor空间。每次使用其中一块Eden和survivor，回收时将存活的对象一次性地复制到另一块survivor中，再清理掉之前的。HotSpot虚拟机Eden与Survivor默认的大小比例为8:1:1。survivor空间不够时，需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。 3.标记整理算法 复制在对象存活率较高时效率很低。根据老年代的特点提出该算法。标记过程同标记清除一样，但不是直接对可回收对象进行清理，而是让存活对象朝着一端移动，然后直接清理掉端边界外的内存。 4.分代收集算法 根据各年代特点分别采用最适当的GC算法。在新生代:中每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。在老年代: 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。即： 新生代：存活率低，使用复制算法 老年代：存活率高，使用“标记-整理”或“标记-清除”算法 五 Hotspot算法实现及准确式GC 上面讲到了Java虚拟机是如何利用可达性算法判断对象是否需要回收的，由于在GC进行时，必须暂停所有的Java执行线程（Sun称之为“Stop The World”），所以，虚拟机必须尽量的优化GC过程的效率，减少暂停的时间。那么对于GC Roots，HotSpot是如何快速确定的呢？ 对象的创建首先，我们需要知道在JVM中，对象是如何被创建的。 而对象的创建通常是通过new一个对象而已，当虚拟机接收到一个new指令时，它会做如下的操作: 1 判断对象对应的类是否加载、链接、初始化虚拟机接收到一条new指令时，首先会去检查这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被类加载器加载、链接和初始化过。如果没有则先执行相应的类加载过程。关于类加载器我们在前一篇文章中已经提到过，这里不再赘述。 2为对象分配内存类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式： 指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。 空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。 3处理并发安全问题创建对象是一个非常频繁的操作，所以需要解决并发的问题，有两种方式： 对分配内存空间的动作进行同步处理，比如在虚拟机采用CAS算法并配上失败重试的方式保证更新操作的原子性。 每个线程在Java堆中预先分配一小块内存，这块内存称为本地线程分配缓冲（Thread Local Allocation Buffer）简写为TLAB，线程需要分配内存时，就在对应线程的TLAB上分配内存，当线程中的TLAB用完并且被分配到了新的TLAB时，这时候才需要同步锁定。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。 4初始化分配到的内存空间将分配到的内存，除了对象头都初始化为零值。 5设置对象的对象头将对象的所属类、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中。 6执行init方法进行初始化执行init方法，初始化对象的成员变量、调用类的构造方法，这样一个对象就被创建了出来。 对象的堆内存布局在HotSpot虚拟机中，对象在堆内存的布局分为三个区域，分别是对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。 对象头：对象头包括两部分信息分别是Mark World和元数据指针，Mark World用于存储对象运行时的数据，比如HashCode、锁状态标志、GC分代年龄等。而元数据指针用于指向方法区的中目标类的类型信息，通过元数据指针可以确定对象的具体类型。 实例数据：用于存储对象中的各种类型的字段信息（包括从父类继承来的）。 对齐填充：对齐填充不一定存在，起到了占位符的作用，没有特别的含义。 对象分配如下图所示： HotSpot的对象模型HotSpot中采用了OOP-Klass模型，它是用来描述Java对象实例的一种模型，OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 HotSpot中，用instanceOopDesc 和 arrayOopDesc 来描述对象头，其中arrayOopDesc对象用于描述数组类型。 通过OOP-Klass模型，我们就知道了Java虚拟机是如何通过栈帧中的对象引用找到对应的对象实例，如下图所示： 从图中可以看出，通过栈帧中的对象引用找到Java堆中的instanceOopDesc对象，再通过instanceOopDesc中的元数据指针来找到方法区中的instanceKlass，从而确定该对象的具体类型。 HotSpot的准确式GCHotSpot采用了准确式GC以提升GC roots的枚举速度。所谓准确式GC，就是让JVM知道内存中某位置数据的类型什么。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。 HotSpot是利用OopMap来实现准确式GC的。当类加载完成后，HotSpot 就将对象内存布局之中什么偏移量上数值是一个什么样的类型的数据这些信息存放到 OopMap 中；在 HotSpot 的 JIT 编译过程中，同样会插入相关指令来标明哪些位置存放的是对象引用等，这样在 GC 发生时，HotSpot 就可以直接扫描 OopMap 来获取对象引用的存储位置，从而进行 GC Roots 枚举。 HotSpot安全点通过OopMap，HotSpot可以很快完成GC Roots的查找，但是，如果在每一行代码都有可能发生GC，那么也就意味着得为每一行代码的指令都生成OopMap，这样将占用大量的空间。实际上，HotSpot也不会这么做。 HotSpot只在特定的位置记录了OopMap，这些位置就叫做安全点（Safepoint），也就是说，程序并不能在任意地方都可以停下来进行GC，只有到达安全点时才能暂停进行GC。 在安全点中，HotSpot也会开始记录虚拟机的相关信息，如OopMap信息的录入。安全点的选择不能太少，否则GC等待时间太长；也不能太多，否则会增大运行负荷，其选择的原则为“是否具有让程序长时间执行的特征”，如方法调用，循环等等。具体安全点有下面几个： (1) 循环的末尾 (防止大循环的时候一直不进入Safepoint，而其他线程在等待它进入Safepoint)(2) 方法返回前(3) 调用方法的call之后(4) 抛出异常的位置 而安全点暂停线程运行的手段有两种：抢先式中断和主动式中断。 抢先式中断不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上再暂停。不过现在的虚拟机几乎没有采用此算法的。 主动式中断GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时去主动轮询查询此标志，发现中断标志为真时就中断自己挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 HotSpot安全区域产生原因安全点机制保证了程序执行时进入GC的问题。但是对于非执行态下，如线程Sleep或者Block下，由于此时程序（线程）无法响应JVM的中断请求，JVM也不太可能一直等待线程重新获取时间片，此时就需要安全区域(Safe Region)了。安全区域是指在一段代码片段内，引用关系不会发生变化，在这段区域内，任意地方开始GC都是安全的。 运行机理在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了；当线程要离开Safe Region时，如果整个GC完成，那线程可继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止。 六 七种垃圾收集器重点笔记： 并行（Parallel）：多条垃圾收集线程 并发（Concurrent）：用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户线程在继续运行，而垃圾收集程序运行于另外一个CPU上。 新生代：Serial收集器 ParNew收集器 Parallel Scavenge收集器 老年代：Serial Old收集器 Parallel Old收集器 CMS收集器 新生代垃圾收集器1.Serial收集器 最悠久，最基本的收集器；单线程收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，且在收集时，必须暂停其他所有的工作线程，直到收集结束。新生代采取复制算法。老年代采取标记整理算法。在进行垃圾收集时必须暂停其他所有的工作线程，即“Stop The World”。依然是虚拟机运行在Client模式下的默认新生代收集器。Serial一般在单核的机器上使用，是Java 5非服务端JVM的默认收集器。 新生代：单线程复制收集算法； 老年代：单线程标记整理算法。 参数-XX:UseSerialGC设置使用 优势：对于单CPU环境来说，Serial收集器没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集。Serial收集器对于在Client模式下的虚拟机是一个很好的选择。 2.ParNew收集器 Serial收集器的多线程版。多条线程进行垃圾收集，采用复制算法。其余和Serial收集器一样。目前唯一能与CMS收集器配合工作。ParNew收集器在单CPU环境中不比Serial效果好，甚至可能更差，两个CPU也不一定跑的过，但随着CPU数量的增加，性能会逐步增加。默认开启的收集线程数与CPU数量相同。在CPU数量很多的情况下，可以使用-XX:ParallelGCThreads参数来限制线程数。 新生代并行，老年代串行 新生代复制算法、老年代标记-整理 参数控制：-XX:+UseConcMarkSweepGC”：指定使用CMS后，会默认使用ParNew作为新生代收集器；-XX:+UseParNewGC”：强制指定使用ParNew；-XX:ParallelGCThreads”：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同； 优势：ParNew收集器是许多运行在server模式下的虚拟机中首选的新生代收集器，一个重要的原因是，只有ParNew和Serial收集器能和CMS收集器共同工作。无法与JDK1.4中存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew和Serial。 3.Parallel Scavenge收集器 新生代收集器，多线程并行、使用复制算法。 CMS的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而PS收集器的目的则是达到一个可控制的吞吐量。吞吐量即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间））。 使用-XX:MaxGCPauseMillus参数控制垃圾停顿时间 使用-XX:GCTimeRatio参数控制吞吐量。 Parallel Scavenge收集器设置-XX:UseAdaptiveSizePolicy参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量（GC自使用的调节策略）。自适应调节策略也是Parallel Scavenge收集器和ParNew收集器一个重要的区别。 老年代垃圾收集器4.Serial Old收集器 Serial Old同样是单线程收集器,使用“标记-整理”算法。可以与JDK1.5及之前的Parallel Scavenge搭配使用；也可以作为CMS收集器的后备预案，在并发收集发生Concureent Mode Failure时使用。 5.Parallel Old收集器 Parallel Old收集器是多线程，使用“标记-整理”算法。 JDK1.6前，Parallel Scavenge只能与老年代收集器Serial Old（PS MarkSweep）组合，由于Serial Old无法充分利用服务器多CPU的处理能力，会拖累整体性能。 JDK1.6后，Parallel Scavenge可与Parallel Old组合，达到名副其实的“吞吐量优先”，在注重吞吐量以及CPU资源敏感的场合可以优先考虑这个组合。 6.CMS收集器 基于“标记—清除”算法，低停顿，并发收集。以获取最短回收停顿时间、低延迟为目标，适用于重视服务响应速度的应用。 主要过程为一下四步： 初始标记；Stop the World，仅标记GCRoots能关联的对象，速度很快。 并发标记；进行GCRootsTracing的过程。 重新标记；修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比1长但远比2短。 并发清除；并发清除与并发标记耗时最长。收集器线程都可以与用户线程一起工作。并发清理以后重置线程。 CMS收集器的内存回收过程是与用户线程一起并发执行的 主要缺点： CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是因为占用了一部分CPU资源而导致应用程序变慢，总吞吐量就会降低。CMS默认启动的回收线程数为(CPU数量+3)/4。当CPU的个数少于2个的时候，CMS对用户程序的影响可能会变得很大。 CMS收集器无法处理浮动垃圾（floating garbage），可能会出现concurrent mode failure导致另一次full gc的产生。在CMS的并发清理阶段，由于程序还在运行，垃圾还会不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留到下一次GC再处理。这种垃圾称为浮动垃圾。同样由于CMS GC阶段用户线程还需要运行，即还需要预留足够的内存空间供用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被灌满了再进行收集而需要预留一部分空间提供并发收集时的程序运作使用。默认设置下 CMS收集器在老年代使用了68%的空间后就会被激活。这个值可以用-XX:CMSInitiatingOccupancyFraction来设置。要是CMS运行期间预留的内存无法满足程序需要，就会出现concurrent mode failure，这时候就会启用Serial Old收集器作为备用进行老年代的垃圾收集。 空间碎片过多（标记-清除算法的弊端），CMS是基于标记-清除算法来实现的回收器，提供-XX:+UseCMSCompactAtFullCollection参数，应用于在FULL GC后再进行一个碎片整理过程。-XX:CMSFullGCsBeforeCompaction,多少次不压缩的full gc后来一次带压缩的。 整堆收集器7.G1收集器 G1收集器（Garbage-First）：是当今收集器技术发展的最前沿的成果之一，G1是一款面向服务器端应用的垃圾收集器。 使用G1收集器时，java堆的内存布局就与其他收集器有很大差别，它将真个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代与老年代的概念，但新生代与老年代不再试物理隔离的了，他们都是一部分Region（不需要连续）的集合。G1具备如下特点： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能够独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记–整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这个特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前出发下一次GC。 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时java（RTSJ）的垃圾收集器的特性了。 初始标记（Initial Marking）：标记GC Roots能够直接关联到的对象，并且修改TAMS的值，能在正确可用的Region中创建对象，这阶段需要停顿线程，而且耗时很短。并发标记（Concurrent Marking）：从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这个时间耗时比较长，但可与用户程序并行执行。 最终标记（Final Marking）：为了修正和正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分没有标记记录，虚拟机将这一段对象变法记录在线程Rememberred Set logs里面，最终标记阶段需要把Remembered Set logs 的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并发执行。 筛选回收（Live Data Counting and Evacuation）：对各个Region的回收截止和成本进行排序，根据用户期望的GC停顿时间来制定回收计划，这阶段可以做到和用户程序一起并发执行，但是因为值回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高手机效率。 内存分配与回收策略重点笔记： 新生代GC（Minor GC）：发生在新生代的垃圾收集动作，非常频繁，一般回收速度也比较快。 老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作，一般会伴随Minor GC 速度一般比Minor GC慢上10倍以上。 优先在Eden区分配（如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）如果Eden区满，则触发一次Minor GC 大对象直接进入老年代；大对象，即大量连续内存空间的Java对象，最典型的是那种很长的字符串及数组。 长期存活的对象将进入老年代；设置对象年龄计数器。对象在Eden出生并经过第一次MinorGC后仍存活，年龄+1，移入Survivor区。以后每经过一次MinorGC年龄加一，当达到15时（默认的）就进入老年代 动态对象年龄判定，并不是对象年龄必须达到最大阈值才会进入老年代。如果survivor空间中相同年龄所有对象大小总和大于其空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到阈值时才进入。 空间分配担保；发生minorGC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立，MinorGC可以确保是安全的。不成立，则检查HandlePromotionFailure设置值是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。大于将尝试MinorGC，小于或者不允许冒险，也要进行一次FullGC。老年代分配担保，将survivor无法容纳的对象直接进入老年代。依然担保失败，则只好在失败后重新发起一次Full GC。 参考链接： 1234https://blog.csdn.net/u013667756/article/details/82948012https://www.jianshu.com/p/9d09f93001e4https://blog.csdn.net/u012998254/article/details/81635902https://blog.csdn.net/u012998254/article/details/81635902","categories":[{"name":"深入理解JVM","slug":"深入理解JVM","permalink":"https://www.vazh.cn/categories/深入理解JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.vazh.cn/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://www.vazh.cn/tags/GC/"},{"name":"内存分配策略","slug":"内存分配策略","permalink":"https://www.vazh.cn/tags/内存分配策略/"}]},{"title":"Linux的文件权限与目录配置","slug":"Linux的文件权限与目录配置","date":"2019-08-29T01:14:41.000Z","updated":"2019-09-04T04:33:34.820Z","comments":true,"path":"2019/08/29/Linux的文件权限与目录配置/","link":"","permalink":"https://www.vazh.cn/2019/08/29/Linux的文件权限与目录配置/","excerpt":"","text":"一、Linux 文件属性1.1、用户和组Linux 系统中的目录和文件的访问身份分为 user，group， others 分别简写为 u， g ， o 。 user：文件的所有者 group：文件所有者所在组 others ：不在所有者的所在组的其他用户 all：代表所有用户， 简写为 a 每个身份对文件的权限又分为 : read ， write ， execute， 分别简写为 : r，w ，x， 数字表示分别为 : 4， 2， 1。 1.2、文件详细信息Linux 文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。 ls -al 查看文件详细信息： drwxr-xr-x 5 root root 4096 Apr 23 14:49 . drwxr-xr-x 18 root root 4096 Apr 28 16:36 .. drwxr-xr-x 4 root root 4096 Apr 23 14:49 master drwxr-xr-x 3 root root 4096 Apr 23 14:49 spark1 drwxr-xr-x 3 root root 4096 Apr 23 14:49 spark2 1.2.1、第一栏：类型与权限 第一个字符代表这个文件的类型(如目录、文件或链接文件等等)： 当为[ d ]则是目录 当为[ - ]则是文件 若是[ l ]则表示为链接文件(link file) 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合： [ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute) ，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 第一组为『文件拥有者的权限，第二组为『同群组的权限』，第三组为『其他非本群组的权限』。 1.2.2、第二栏：多少档名连结到此节点(i-node)每个文件都会将他的权限与属性记录到文件系统的 i-node 中，不过，我们使用的目录树却是使用文件名来记录， 因此每个文件名就会链接到一个 i-node。这个属性记录的，就是有多少不同的文件名链接到相同的一个 i-node 号码。 1.2.3、第三栏：文件(或目录)的拥有者1.2.4、第四栏：文件的所属群组1.2.5、第五栏：文件的容量大小(默认单位为 bytes )1.2.6、第六栏：文件的建档日期或者是最近的修改日期1.2.7、第七栏：文件的全路径及其文件名这个字段就是档名。 比较特殊的是：如果档名之前多一个“.” ，则代表这个文件为隐藏档。 二、修改文件属性和权限2.1、chgrp ：改变文件所属群组12345678chgrp [-R] dirname/filename ...选项与参数：-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。范例：chgrp users initial-setup-ks.cfg 2.2、chown ：改变文件拥有者1234567chown [-R] 帐号名称 文件或目录选项与参数：-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都变更范例：将 initial-setup-ks.cfg 的拥有者改为bin这个帐号：chown bin initial-setup-ks.cfg 2.3、chmod ：改变文件的权限权限的设置方法有两种， 分别可以使用数字或者是符号来进行权限的变更。 2.3.1、数字类型改变文件权限Linux文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己的 read/write/execute 权限。 各权限的分数对照表如下： r:4 &gt; w:2 &gt; x:1 每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 &gt; group = rwx = 4+2+1 = 7 &gt; others= — = 0+0+0 = 0 变更权限的指令 chmo的语法是这样的： 12345chmod [-R] xyz 文件或目录选项与参数：xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都会变更 2.3.2、符号类型改变文件权限基本上就九个权限分别是（1）user （2）group （3）others 三种身份。那么就可以借由 u， g， o 来代表三种身份的权限！此外， a 则代表 all 亦即全部的身份！ 可以使用下面的方式来看： | chmod | u g o a | +（加入） -（除去） =（设置） | r w x | 文件或目录 | 123chmod u=rwx,go=rx .bashrc那个 u=rwx,go=rx 是连在一起的，中间并没有任何空白字符！ 如果是要将权限去掉而不更动其他已存在的权限，例如要拿掉全部人的可执行权 限，则： 1chmod a-x .bashrc 2.3.3 目录与文件的权限意义 能不能进入某一个目录，只与该目录的x权限有关。如果在某目录的下不具有x权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何命令，即使你具有该目录下的r权限。但是不能随便给w权限。 三、Linux 文件种类与扩展名3.1、文件种类3.1.1、正规文件（regular file ）ls -al 所显示出来的属性方面，第一个字符为 [ - ]。 可以分为： 纯文本文件（ASCII）：这是 Linux 系统中最多的一种文件类型， 称为纯文本文件，内容为我们人类可以直接读到的数据，例如数字、字母等等。 二进制档（binary）：Linux当中的可执行文件。 数据格式文件（data）：有些程序在运行的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 （data file）。举例来说，Linux 在使用者登陆时，都会将登录的数据记录在 /var/log/wtmp 那个文件内，该文件是一个 data file，他能够通过 last 这个指令读出来！ 但是使用cat时，会读出乱码。 3.1.2、目录（directory）目录，第一个属性为 [ d ]。 3.1.3、链接文件（link）第一个属性为 [ l ]。 就是类似 Windows 系统下面的快捷方式！ 3.1.4、设备与设备文件（device）与系统周边及储存等相关的一些文件， 通常都集中在 /dev 这个目录之下！通常又分为两种： 区块（block）设备文件 ：就是一些储存数据， 以提供系统随机存取的周边设备，举例来说，硬盘与软盘等就是。第一个属性为[ b ]。 字符（character）设备文件：亦即是一些序列埠的周边设备， 例如键盘、鼠标等等！这些设备的特色就是“一次性读取”的，不能够截断输出。 第一个属性为 [ c ]。 3.1.5、数据接口文件（sockets）第一个属性为 [ s ]。 这种类型的文件通常被用在网络上的数据承接。可以启动一个程序来监听用户端的要求， 而用户端就可以通过这个 socket 来进行数据的沟通了。 最常在 /run 或 /tmp 这些个目录中看到这种文件类型了。 3.1.6、数据输送档（FIFO, pipe）第一个属性为[p] FIFO也是一种特殊的文件类型，主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO 是 first-in-first-out 的缩写。 四、Linux 目录配置根据 FHS（Filesystem Hierarchy Standard ）的标准文件指出每个特定的目录下应该要放置什么样子的数据。 FHS 依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态： 可分享的：可以分享给其他系统挂载使用的目录，所以包括可执行文件与使用者的邮件等数据， 是能够分享给网络上其他主机挂载用的目录。 不可分享的：自己机器上面运行的设备文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函数库、文件说明文档、系统管理员所管理的主机服务配置文件等等。 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻群组等。 事实上，FHS 针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义： / （root, 根目录）：与开机系统有关 /usr （unix software resource）：与软件安装/执行有关 /var （variable）：与系统运行过程有关 4.1、根目录 （/） 的意义与内容根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函数库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区内， 因为越大的分区你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。 FHS 标准建议：根目录（/）所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但性能较佳，根目录所在的文件系统也较不容易发生问题。 鉴于上述的说明，因此 FHS 定义出根目录(/)底下应该要有底下这些次目录的存在才好： 目录 应放置文件内容 /bin 系统有很多放置执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot 这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机选单与开机所需配置文件等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub这个开机管理程序， 则还会存在/boot/grub/这个目录喔！ /dev 在Linux系统上，任何装置与接口设备都是以文件的型态存在于这个目录当中的。 你只要透过存取这个目录底下的某个文件，就等于存取某个装置啰～ 比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/lp, /dev/hd, /dev/sd*等等 /etc 系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中喔。比较重要的文件有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等。另外，其下重要的目录有： /etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话：『 /etc/init.d/iptables start』、『/etc/init.d/iptables stop』 /etc/xinetd.d/：这就是所谓的super daemon管理的各项服务的配置文件目录。 /etc/X11/：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。 /home 这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时， 默认的用户家目录都会规范到这里来。比较重要的是，家目录有两种代号喔： ~：代表目前这个用户的家目录，而 ~dmtsai ：则代表 dmtsai 的家目录！ /lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库， 以及在/bin或/sbin底下的指令会呼叫的函式库而已。 什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。 尤其重要的是/lib/modules/这个目录， 因为该目录会放置核心相关的模块(驱动程序)喔！ /media media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软盘、光盘、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 /opt 这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软件(非原本的distribution提供的)，那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ /root 系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。 /sbin Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srv srv可以视为『service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！ 底下是几个在 Linux 当中也是非常重要的目录： 目录 应放置文件内容 /lost+found 这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在， 例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』 /proc 这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中， 例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。 /sys 这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量喔！ 根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分割槽则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分割槽去！那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件 这五个目录千万不可与根目录分开在不同的分割槽！ 4.2、/usr 的意义与内容/usr 里面放置的数据属于可分享的与不可变动的(shareable, static)，/usr 可以分享给区域网络内的其他主机来使用。 usr 是 Unix Software Resource 的缩写， 也就是『Unix操作系统软件资源』。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。 因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似 Windows 系统的『C:\\Windows\\ + C:\\Program files\\』这两个目录的综合体。 /usr的次目录建议有底下这些： 目录 应放置文件内容 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里！请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档喔！ /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生喔！ /usr/local/ 系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！ /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)啰！ /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛！在此目录下常见的还有这些次目录： /usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 4.3、/var 的意义与内容/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有： 目录 应放置文件内容 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档； /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！ /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。 /var/log/ 重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！ /var/run/ 某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！ 至于PID的意义我们会在后续章节提到的。 /var/spool/ 这个目录通常放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.vazh.cn/categories/Linux/"}],"tags":[{"name":"linux文件权限","slug":"linux文件权限","permalink":"https://www.vazh.cn/tags/linux文件权限/"}]},{"title":"JDK源码阅读之ReentrantLock","slug":"JDK源码阅读之ReentrantLock","date":"2019-07-16T07:31:45.000Z","updated":"2019-09-04T02:50:48.770Z","comments":true,"path":"2019/07/16/JDK源码阅读之ReentrantLock/","link":"","permalink":"https://www.vazh.cn/2019/07/16/JDK源码阅读之ReentrantLock/","excerpt":"","text":"概述 ReentrantLock是一个可重入的互斥锁，也被称为“独占锁”。在上一篇讲解AQS的时候已经提到，“独占锁”在同一个时间点只能被一个线程持有；而可重入的意思是，ReentrantLock可以被单个线程多次获取。 ReentrantLock又分为“公平锁(fair lock)”和“非公平锁(non-fair lock)”。它们的区别体现在获取锁的机制上：在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”机制下，如果锁是可获取状态，不管自己是不是在队列的head节点都会去尝试获取锁。reentrantLock默认是非公平锁 数据结构与核心参数 ​ ReetrantLock继承关系 可以看到ReetrantLock继承自AQS，并实现了Lock接口。Lock源码如下： 1234567891011121314public interface Lock &#123; //获取锁，如果锁不可用则线程一直等待 void lock(); //获取锁，响应中断，如果锁不可用则线程一直等待 void lockInterruptibly() throws InterruptedException; //获取锁，获取失败直接返回 boolean tryLock(); //获取锁，等待给定时间后如果获取失败直接返回 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //释放锁 void unlock(); //创建一个新的等待条件 Condition newCondition();&#125; 在Lock提供的获取锁方法中，有lock()、lockInterruptibly()、tryLock()和tryLock(long time, TimeUnit unit)四种方式，他们的区别如下： lock() 获取失败后，线程进入等待队列自旋或休眠，直到锁可用，并且忽略中断的影响 lockInterruptibly() 线程进入等待队列park后，如果线程被中断，则直接响应中断（抛出InterruptedException） tryLock() 获取锁失败后直接返回，不进入等待队列 tryLock(long time, TimeUnit unit) 获取锁失败等待给定的时间后返回获取结果 ReetrantLock通过AQS实现了自己的同步器Sync，分为公平锁FairSync和非公平锁NonfairSync。在构造时，通过所传参数boolean fair来确定使用那种类型的锁。 本篇会以对比的方式分析两种锁的源码实现方式。 源码解析lock()lock()方法用于获取锁，两种类型的锁源码实现如下： 1234567891011121314151617//获取锁，一直等待锁可用public void lock() &#123; sync.lock();&#125;//公平锁获取final void lock() &#123; acquire(1);&#125;//非公平锁获取final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 说明：公平锁的lock方法调用了AQS的acquire(1)；而非公平锁则直接通过CAS修改state值来获取锁，当获取失败时才会调用acquire(1)来获取锁。 关于acquire()方法，在上篇介绍AQS的时候已经讲过，印象不深的同学可以翻回去看一下，这里主要来看一下tryAcquire在ReetrantLock中的实现。 公平锁tryAcquire： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState();//获取锁状态state if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; //判断当前线程是否还有前节点 compareAndSetState(0, acquires)) &#123;//CAS修改state //获取锁成功，设置锁的持有线程为当前线程 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123;//当前线程已经持有锁 int nextc = c + acquires;//重入 if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc);//更新state状态 return true; &#125; return false;&#125; 说明：公平锁模式下的tryAcquire，执行流程如下： 如果当前锁状态state为0，说明锁处于闲置状态可以被获取，首先调用hasQueuedPredecessors方法判断当前线程是否还有前节点(prev node)在等待获取锁。如果有，则直接返回false；如果没有，通过调用compareAndSetState（CAS）修改state值来标记自己已经拿到锁，CAS执行成功后调用setExclusiveOwnerThread设置锁的持有者为当前线程。程序执行到现在说明锁获取成功，返回true； 如果当前锁状态state不为0，但当前线程已经持有锁（current == getExclusiveOwnerThread()），由于锁是可重入（多次获取）的，则更新重入后的锁状态state += acquires 。锁获取成功返回true。 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; hasQueuedPredecessors源码如上，如果在该队列中还有Node结点（即还有等待的线程），那么就返回true，否则返回false。 非公平锁tryAcquire 12345678910111213141516171819202122//非公平锁获取protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123;//CAS修改state setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires;//计算重入后的state if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; 说明：通过对比公平锁和非公平锁tryAcquire的代码可以看到，非公平锁的获取略去了!hasQueuedPredecessors()这一操作，也就是说它不会判断当前线程是否还有前节点(prev node)在等待获取锁，而是直接去进行锁获取操作。 unlock()1234//释放锁public void unlock() &#123; sync.release(1);&#125; 说明：关于release()方法，在上篇介绍AQS的时候已经讲过，印象不深的同学可以翻回去看一下，这里主要来看一下tryRelease在ReetrantLock中的实现： 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases;//计算释放后的state值 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true;//锁全部释放，可以唤醒下一个等待线程 setExclusiveOwnerThread(null);//设置锁持有线程为null &#125; setState(c); return free;&#125; 说明：tryRelease用于释放给定量的资源。在ReetrantLock中每次释放量为1，也就是说，在可重入锁中，获取锁的次数必须要等于释放锁的次数，这样才算是真正释放了锁。在锁全部释放后（state==0）才可以唤醒下一个等待线程。 等待条件Condition 在上篇介绍AQS中提到过，在AQS中不光有等待队列，还有一个条件队列，这个条件队列就是我们接下来要讲的Condition。 Condition的作用是对锁进行更精确的控制。Condition中的await()、signal()、signalAll()方法相当于Object的wait()、notify()、notifyAll()方法。不同的是，Object中的wait()、notify()、notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与Lock捆绑使用的。 Condition函数列表 1234567891011121314151617181920//使当前线程在被唤醒或被中断之前一直处于等待状态。void await()//使当前线程在被唤醒、被中断或到达指定等待时间之前一直处于等待状态。boolean await(long time, TimeUnit unit)//使当前线程在被唤醒、被中断或到达指定等待时间之前一直处于等待状态。long awaitNanos(long nanosTimeout)//使当前线程在被唤醒之前一直处于等待状态。void awaitUninterruptibly()//使当前线程在被唤醒、被中断或到达指定最后期限之前一直处于等待状态。boolean awaitUntil(Date deadline)//唤醒一个等待线程。void signal()//唤醒所有等待线程。void signalAll() 下面我们来看一下Condition在AQS中的实现 await()123456789101112131415161718192021//使当前线程在被唤醒或被中断之前一直处于等待状态。public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter();//添加并返回一个新的条件节点 int savedState = fullyRelease(node);//释放全部资源 int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //当前线程不在等待队列，park阻塞 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) //线程被中断，跳出循环 break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters();//解除条件队列中已经取消的等待节点的链接 if (interruptMode != 0) reportInterruptAfterWait(interruptMode);//等待结束后处理中断&#125; 说明： await()方法相当于Object的wait()。把当前线程添加到条件队列中调用LockSupport.park()阻塞，直到被唤醒或中断。函数流程如下： 首先判断线程是否被中断，如果是，直接抛出InterruptedException，否则进入下一步； 添加当前线程到条件队列中，然后释放全部资源/锁; 如果当前节点不在等待队列中，调用LockSupport.park()阻塞当前线程，直到被unpark或被中断。这里先简单说一下signal方法，在线程接收到signal信号后，unpark当前线程，并把当前线程转移到等待队列中（sync queue）。所以，在当前方法中，如果线程被解除阻塞（unpark），也就是说当前线程被转移到等待队列中，就会跳出while循环，进入下一步； 线程进入等待队列后，调用acquireQueued方法获取锁； 调用unlinkCancelledWaiters方法检查条件队列中已经取消的节点，并解除它们的链接（这些取消的节点在随后的垃圾收集中被回收掉）； 逻辑处理结束，最后处理中断（抛出InterruptedException或把忽略的中断补上）。 signal()1234567891011121314151617181920212223242526272829303132333435//唤醒线程public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);//唤醒条件队列的首节点线程&#125;//从条件队列中移除给定节点，并把它转移到等待队列private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; //解除首节点链接 &#125; while (!transferForSignal(first) &amp;&amp; //接收到signal信号后，把节点转入等待队列 (first = firstWaiter) != null);&#125;//接收到signal信号后，把节点转入等待队列final boolean transferForSignal(Node node) &#123; /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) //CAS修改状态失败，说明节点被取消，直接返回false return false; Node p = enq(node);//添加节点到等待队列，并返回节点的前继节点(prev) int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) //如果前节点被取消，说明当前为最后一个等待线程，unpark唤醒当前线程 LockSupport.unpark(node.thread); return true;&#125; 说明：signal方法用于发送唤醒信号。在不考虑线程争用的情况下，执行流程如下： 获取条件队列的首节点，解除首节点的链接（first.nextWaiter = null;）； 调用transferForSignal把条件队列的首节点转移到等待队列的尾部。在transferForSignal中，转移节点后，转移的节点没有前继节点，说明当前最后一个等待线程，直接调用unpark()唤醒当前线程。 Condition的其他例如awaitNanos(long nanosTimeout)、signalAll()等方法这里这里就不多赘述了，执行流程都差不多，同学们可以参考上述分析阅读。 synchronized和ReentrantLock的选择 ReentrantLock在加锁和内存上提供的语义与内置锁synchronized相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。从性能方面来说，在JDK5的早期版本中，ReentrantLock的性能远远好于synchronized，但是从JDK6开始，JDK在synchronized上做了大量优化，使得两者的性能差距不大。synchronized的优点就是简洁。 所以说，两者之间的选择还是要看具体的需求，ReentrantLock可以作为一种高级工具，当需要一些高级功能时可以使用它。","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.vazh.cn/categories/源码阅读/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"https://www.vazh.cn/tags/JDK/"},{"name":"ReentrantLock","slug":"ReentrantLock","permalink":"https://www.vazh.cn/tags/ReentrantLock/"},{"name":"JUC","slug":"JUC","permalink":"https://www.vazh.cn/tags/JUC/"},{"name":"可重入锁","slug":"可重入锁","permalink":"https://www.vazh.cn/tags/可重入锁/"}]},{"title":"JUC源码分析之AQS","slug":"JUC源码分析之AQS","date":"2019-07-06T07:41:47.000Z","updated":"2019-09-04T02:51:52.796Z","comments":true,"path":"2019/07/06/JUC源码分析之AQS/","link":"","permalink":"https://www.vazh.cn/2019/07/06/JUC源码分析之AQS/","excerpt":"","text":"AQS概述 AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。 AQS解决了子实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获得这个优势。 AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 AQS支持独占锁（Exclusive）和共享锁（Share）两种模式： 独占锁：只能被一个线程获取到(ReentrantLock)； 共享锁：可以被多个线程同时获取(CountDownLatch、ReadWriteLock的读锁)。 不管是独占锁还是共享锁，本质上都是对AQS内部的一个变量state的获取，state是一个原子性的int变量，可用来表示锁状态、资源数等，如下图。 1234/** * The synchronization state. */ private volatile int state; AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，当然AQS可以确保对state的操作是安全的。变量使用volatile修饰，表示每一次更新都会及时的刷到主存中。 数据结构与结构参数AQS的内部实现了两个队列，一个同步队列和一个条件队列 条件队列是为Lock实现的一个基础同步器，并且一个线程可能会有多个条件队列，只有在使用了Condition才会存在条件队列。 同步队列的作用是，在线程获取资源失败后，进入同步队列队尾保持自旋等待状态， 在同步队列中的线程在自旋时会判断其前节点是否为head节点，如果为head节点则不断尝试获取资源/锁，获取成功则退出同步队列。当线程执行完逻辑后，会释放资源/锁，释放后唤醒其后继节点。同步队列与条件队列的关系 首先展示同步队列与条件队列的结构图，如下： 同步队列节点来源： 同步队列依赖一个双向链表来完成同步状态的管理，当前线程获取同步状态失败 后，同步器会将线程构建成一个节点，并将其加入同步队列中。 通过signal或signalAll将条件队列中的节点转移到同步队列。（由条件队列转化为同步队列） 条件队列节点来源： 调用await方法阻塞线程； 当前线程存在于同步队列的头结点，调用await方法进行阻塞（从同步队列转化到条件队列） 可总结为： 同步队列与条件队列节点可相互转化 一个线程只能存在于两个队列中的一个 实例说明 假设初始状态如下，节点A、节点B在同步队列中。 节点A的线程获取锁权限，此时调用await方法。节点A从同步队列移除， 并加入条件队列中。 调用 signal方法，从条件队列中取出第一个节点，并加入同步队列中，等待获取资源 以上三个说明实例用图片形式解释了同步队列与条件队列节点可相互转化 。需要注意的是同步队列中，头结点head与尾节点tail被放在一个同步器中，也就是Node节点。不管是同步队列还是条件队列，其内部都是由节点Node组成，首先介绍下AQS的内部类Node，主要源码如下： 12345678910111213141516171819202122232425262728static final class Node &#123; /** * Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** * Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; //取消 static final int CANCELLED = 1; //等待触发 static final int SIGNAL = -1; //等待条件 static final int CONDITION = -2; //状态需要向后传播 static final int PROPAGATE = -3;/** 等待状态 */ volatile int waitStatus; /** 前驱节点 */ volatile Node prev; /** 后继节点 */ volatile Node next; /** 获取同步状态的线程 */ volatile Thread thread; Node nextWaiter;&#125; 说明：Node的实现很简单，就是一个普通双向链表的实现，这里主要说明一下内部的几个等待状态： CANCELLED：值为1，当前节点由于超时或中断被取消。 SIGNAL：值为-1，表示当前节点的前节点被阻塞，当前节点在release或cancel时需要执行unpark来唤醒后继节点。 CONDITION：值为-2，当前节点正在等待Condition，这个状态在同步队列里不会被用到。 PROPAGATE：值为-3，(针对共享锁) releaseShared()操作需要被传递到其他节点，这个状态在doReleaseShared中被设置，用来保证后续节点可以获取共享资源。 0：初始状态，当前节点在sync queue中，等待获取锁。 AQS主要提供了如下一些方法： getState()：返回同步状态的当前值； setState(int newState)：设置当前同步状态； compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性； tryAcquire(int arg)：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态； tryRelease(int arg)：独占式释放同步状态； tryAcquireShared(int arg)：共享式获取同步状态，返回值大于等于0则表示获取成功，否则获取失败； tryReleaseShared(int arg)：共享式释放同步状态； isHeldExclusively()：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占； acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法； acquireInterruptibly(int arg)：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回； tryAcquireNanos(int arg,long nanos)：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true； acquireShared(int arg)：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态； acquireSharedInterruptibly(int arg)：共享式获取同步状态，响应中断； tryAcquireSharedNanos(int arg, long nanosTimeout)：共享式获取同步状态，增加超时限制； release(int arg)：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒； releaseShared(int arg)：共享式释放同步状态； 源码分析acquire(int)123456//独占模式获取资源public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 说明：独占模式下获取资源/锁，忽略中断的影响。内部主要调用了三个方法，其中tryAcquire需要自定义实现。后面会对各个方法进行详细分析。acquire方法流程如下： tryAcquire() 尝试直接获取资源，如果成功则直接返回，失败进入第二步； addWaiter() 获取资源失败后，将当前线程加入等待队列的尾部，并标记为独占模式； acquireQueued() 使线程在等待队列中自旋等待获取资源，一直获取到资源后才返回。如果在等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断(interrupt)是不响应的，在获取资源成功之后根据返回的中断状态调用selfInterrupt()方法再把中断状态补上。 tryAcquire(int)123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：尝试获取资源，成功返回true。具体资源获取/释放方式交由自定义同步器实现。ReentrantLock中公平锁和非公平锁的实现如下: 123456789101112131415161718192021222324252627282930313233343536373839//公平锁protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125;//非公平锁final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; 3.1.2 addWaiter(Node)1234567891011121314151617181920212223242526272829303132//添加等待节点到尾部private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure //尝试快速入队 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125;//插入给定节点到队尾private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 说明：获取独占锁失败后，将当前线程加入等待队列的尾部，并标记为独占模式。返回插入的等待节点。 3.1.3 acquireQueued(Node,int)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//自旋等待获取资源final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor();//获取前继节点 //前继节点为head，说明可以尝试获取资源 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node);//获取成功，更新head节点 p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //检查是否可以park parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;//获取资源失败后，检查并更新等待状态private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ //如果前节点取消了，那就一直往前找到一个等待状态的节点，并排在它的后边 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ //此时前节点状态为0或PROPAGATE，表示我们需要一个唤醒信号，但是不立即park,在park前调用者需要重试来确认它不能获取资源。 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;//阻塞当前线程，返回中断状态private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 说明：线程进入等待队列后，在等待队列中自旋等待获取资源。如果在整个等待过程中被中断过，则返回true，否则返回false。具体流程如下： 获取当前等待节点的前继节点，如果前继节点为head，说明可以尝试获取锁； 调用tryAcquire获取锁，成功后更新head为当前节点； 获取资源失败，调用shouldParkAfterFailedAcquire方法检查并更新等待状态。如果前继节点状态为SIGNAL，说明当前节点可以进入waiting状态等待唤醒；被唤醒后，继续自旋重复上述步骤。 获取资源成功后返回中断状态。 当前线程通过parkAndCheckInterrupt()阻塞之后进入waiting状态，此状态下可以通过下面两种途径唤醒线程： 前继节点释放资源后，通过unparkSuccessor()方法unpark当前线程； 当前线程被中断。 3.2 release(int)12345678910/**独占模式释放资源*/public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123;//尝试释放资源 Node h = head;//头结点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);//唤醒head的下一个节点 return true; &#125; return false;&#125; 说明：独占模式下释放指定量的资源，成功释放后调用unparkSuccessor唤醒head的下一个节点。 3.2.1 tryRelease(int)123protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：和tryAcquire()一样，这个方法也需要自定义同步器去实现。一般来说，释放资源直接拿state减去给定的参数arg，释放后state==0说明释放成功。在ReentrantLock中实现如下： 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null);//设置独占锁持有线程为null &#125; setState(c); return free;&#125; 3.2.2 unparkSuccessor(Node)12345678910111213141516private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0)//当前节点没有被取消,更新waitStatus为0。 compareAndSetWaitStatus(node, ws, 0); Node s = node.next;//找到下一个需要唤醒的结点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; //next节点为空，从tail节点开始向前查找有效节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 说明：成功获取到资源后，调用此方法唤醒head的下一个节点。因为当前节点已经释放掉资源，下一个等待的线程可以被唤醒继续获取资源。 3.3 acquireShared(int)1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 说明：共享模式下获取资源/锁，忽略中断的影响。内部主要调用了两个个方法，其中tryAcquireShared需要自定义同步器实现。后面会对各个方法进行详细分析。acquireShared方法流程如下： tryAcquireShared(arg) 尝试获取共享资源。成功获取并且还有可用资源返回正数；成功获取但是没有可用资源时返回0；获取资源失败返回一个负数。 获取资源失败后调用doAcquireShared方法进入等待队列，获取资源后返回。 3.3.1 tryAcquireShared(int arg)1234/**共享模式下获取资源*/protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：尝试获取共享资源，需同步器自定义实现。有三个类型的返回值： 正数：成功获取资源，并且还有剩余可用资源，可以唤醒下一个等待线程； 负数：获取资源失败，准备进入等待队列； 0：获取资源成功，但没有剩余可用资源。 3.3.2 doAcquireShared(int)1234567891011121314151617181920212223242526272829//获取共享锁private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED);//添加一个共享模式Node到队列尾 boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor();//获取前节点 if (p == head) &#123; int r = tryAcquireShared(arg);//前节点为head，尝试获取资源 if (r &gt;= 0) &#123; //获取资源成功，设置head为自己，如果有剩余资源可以在唤醒之后的线程 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //检查获取失败后是否可以阻塞 parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：在tryAcquireShared中获取资源失败后，将当前线程加入等待队列尾部等待唤醒，成功获取资源后返回。在阻塞结束后成功获取到资源时，如果还有剩余资源，就调用setHeadAndPropagate方法继续唤醒之后的线程，源码如下： 123456789101112131415//设置head，如果有剩余资源可以再唤醒之后的线程private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); /* * 如果满足下列条件可以尝试唤醒下一个节点： * 调用者指定参数(propagate&gt;0)，并且后继节点正在等待或后继节点为空 */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 3.4 releaseShared(int)12345678/**共享模式释放资源*/public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared();//释放锁，并唤醒后继节点 return true; &#125; return false;&#125; 说明：共享模式下释放给定量的资源，如果成功释放，唤醒等待队列的后继节点。tryReleaseShared需要自定义同步器去实现。方法执行流程：tryReleaseShared(int)尝试释放给定量的资源，成功释放后调用doReleaseShared()唤醒后继线程。 3.4.1 tryReleaseShared(int)1234/**共享模式释放资源*/protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 说明：释放给定量的资源，需自定义同步器实现。释放后如果允许后继等待线程获取资源返回true。 3.4.2 doReleaseShared(int)1234567891011121314151617181920//释放共享资源-唤醒后继线程并保证后继节点的资源传播private void doReleaseShared() &#123; //自旋，确保释放后唤醒后继节点 for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h);//唤醒后继节点 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) //waitStatus为0，CAS修改为PROPAGATE continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 说明：在tryReleaseShared成功释放资源后，调用此方法唤醒后继线程并保证后继节点的release传播（通过设置head节点的waitStatus为PROPAGATE）。 小结自此，AQS的主要方法就讲完了，有几个没有讲到的方法如tryAcquireNanos、tryAcquireSharedNanos，都是带等待时间的资源获取方法，还有acquireInterruptibly acquireSharedInterruptibly,响应中断式资源获取方法。都比较简单，同学们可以参考本篇源码阅读。","categories":[{"name":"源码分析","slug":"源码分析","permalink":"https://www.vazh.cn/categories/源码分析/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://www.vazh.cn/tags/JUC/"},{"name":"AQS","slug":"AQS","permalink":"https://www.vazh.cn/tags/AQS/"}]},{"title":"JUC源码分析之CAS和Unsafe","slug":"JUC源码分析之CAS和Unsafe","date":"2019-07-06T07:39:18.000Z","updated":"2019-07-08T08:38:04.000Z","comments":true,"path":"2019/07/06/JUC源码分析之CAS和Unsafe/","link":"","permalink":"https://www.vazh.cn/2019/07/06/JUC源码分析之CAS和Unsafe/","excerpt":"","text":"初识CAS 在对J.U.C包的源码分析之前，首先介绍下一个比较重要的概念-CAS（Compare-and-Swap）。在J.U.C包中大量使用了CAS，涉及并发或资源争用的地方都使用了sun.misc.Unsafe类的方法进行CAS操作。在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁 锁机制存在以下问题： （1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。 （2）一个线程持有锁会导致其它所有需要此锁的线程挂起。 （3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。 独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。 什么是CAS ?CAS,即compare and swap比较并替换。 CAS有三个参数：需要读写的内存位值（V）、进行比较的预期原值（A）和拟写入的新值(B)。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。以多线程并发为例，简单来说，CAS的含义是：“两个进程都在操作V, 我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少, 显然在这个过程中, V的值可能会被其他线程修改，所以若是V值与预期原值A不相等, 则V值被修改”。CAS是一项乐观的技术，它希望能成功地执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么CAS能检测到这个错误。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败。但是，失败的线程并不会被挂起（这就是与获取锁的机制不同之处），而是被告知在这次竞争中失败，并可以多次尝试。这种灵活性就大大减少了与锁相关的活跃性风险。 以AtomicInteger为例，内部的CAS实现如下： 1234567891011121314151617181920212223242526272829303132333435public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); //value的偏移地址 private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev; &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125;&#125; 说明： 可以看到AtomicInteger内部都是使用了Unsafe类来进行CAS操作，valueOffset表示的是value值的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的原值的, 偏移量可以简单理解为指针指向该变量的内存地址。 value使用volatile修饰，直接从共享内存中操作变量，保证多线程之间看到的value值是同一份。 以方法getAndUpdate()为例，执行步骤如下： 从内存中读取修改前的值prev，并执行给定函数式计算修改后的值next； 调用compareAndSet修改value值（内部是调用了unsafe的compareAndSwapInt方法）。如果此时有其他线程也在修改这个value值，那么CAS操作就会失败，继续进入do循环重新获取新值. 由while循环判断知compareAndSet(prev, next)返回false，即没有更新成功时，就会一直循环下去，直到更新成功. 下面通熟易懂的上一个Demo: 12345public static void main(String[] args)&#123; AtomicInteger atomicInteger = new AtomicInteger(10); System.out.println(atomicInteger.compareAndSet(10,666)); System.out.println(atomicInteger.compareAndSet(10,888));&#125; AtomicInteger有一个compareAndSet方法，有两个操作数，第一个是期望值，第二个是希望修改成的值。首先初始值是10，也是内存中的值，第一次调用compareAndSet方法的时候，会将10拷贝回自己的工作空间，然后改成666，写回到主内存中的时候，它期望主内存中的值是10，而这时确实也是10，所以可以修改成功，主内存中的值也变成了666，输出true。第二次调用compareAndSet的时候，在自己的工作内存将值修改成888，写回去的时候，希望主内存中的值是10，但是此时是666，所以set失败，输出false。这就是比较并交换，也即CAS。当然实际过程中是不会这样顺序执行，而是并发执行，多个线程都在修改值，而当其中一个线程修改成功时，这意味着在这一轮中，其他线程都更新失败，进行下一次更新。 CAS的工作原理简而言之，CAS工作原理就是UnSafe类和自旋锁。 1、UnSafe类： UnSafe类在jdk的rt.jar下面的一个类，全包名是sun.misc.UnSafe。这个类大多数方法都是native方法。由于Java不能操作计算机系统，所以设计之初就留了一个UnSafe类。通过UnSafe类，Java就可以操作指定内存地址的数据。调用UnSafe类的CAS，JVM会帮我们实现出汇编指令，从而实现原子操作。现在就来分析一下AtomicInteger的getAndIncrement方法是怎么工作的。看下面的代码： 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; 这个方法调用的是unsafe类的getAndAddInt方法，有三个参数。第一个表示当前对象，也就是你new 的那个AtomicInteger对象；第二个表示内存地址；第三个表示自增步伐。然后再点进去看看这个getAndAddInt方法。 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; 这里的val1就是当前对象，val2是内存地址，val4是1，也就是自增步伐。首先把当前对象主内存中的值赋给val5，然后进入while循环。判断当前对象此刻主内存中的值是否等于val5，如果是，就自增，否则继续循环，重新获取val5的值。这里的compareAndSwapInt方法就是一个native方法，这个方法汇编之后是CPU原语指令，原语指令是连续执行不会被打断的，所以可以保证原子性。 2、自旋锁： 所谓的自旋，其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时，就重新获取主内存中的值，这就是自旋。 CAS存在的问题CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。 循环时间长，开销大。synchronized是加锁，同一时间只能一个线程访问，并发性不好。而CAS并发性提高了，但是由于CAS存在自旋操作，即do while循环，如果CAS失败，会一直进行尝试。如果CAS长时间不成功，会给CPU带来很大的开销。 只能保证一个共享变量的原子性。上面也看到了，getAndAddInt方法的val1是代表当前对象，所以它也就是能保证这一个共享变量的原子性。如果要保证多个，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量z=1, k = a，合并一下zk = 1a，然后用CAS来操作zk。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 引来的ABA问题。 什么是ABA问题？ 假设现在主内存中的值是A，现有t1和t2两个线程去对其进行操作。t1和t2先将A拷贝回自己的工作内存。这个时候t2线程将A改成B，刷回到主内存。此刻主内存和t2的工作内存中的值都是B。接下来还是t2线程抢到执行权，t2又把B改回A，并刷回到主内存。这时t1终于抢到执行权了，自己工作内存中的值的A，主内存也是A，因此它认为没人修改过，就在工作内存中把A改成了X，然后刷回主内存。也就是说，在t1线程执行前，t2将主内存中的值由A改成B再改回A。这便是ABA问题。看下面的代码演示(代码涉及到原子引用，请参考下面的原子引用的介绍)： 123456789101112131415161718class ABADemo &#123; static AtomicReference&lt;String&gt; atomicReference = new AtomicReference&lt;&gt;(\"A\"); public static void main(String[] args)&#123; new Thread(() -&gt; &#123; atomicReference.compareAndSet(\"A\",\"B\"); atomicReference.compareAndSet(\"B\",\"A\"); &#125;,\"t2\").start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicReference.compareAndSet(\"A\",\"C\") + \"\\t\" + atomicReference.get()); &#125;,\"t1\").start(); &#125;&#125; 这段代码执行结果是”true C”，这就证明了ABA问题的存在。如果一个业务只管开头和结果，不管这个A中间是否变过，那么出现了ABA问题也没事。如果需要A还是最开始的那个A，中间不许别人动手脚，那么就要规避ABA问题。要解决ABA问题，先看下面的原子引用的介绍。 原子引用： JUC包下给我们提供了原子包装类，像AtomicInteger。如果我不仅仅想要原子包装类，我自己定义的User类也想具有原子操作，怎么办呢？JUC为我们提供了AtomicReference，即原子引用。看下面的代码： 1234567891011@AllArgsConstructorclass User &#123; int age; String name; public static void main(String[] args)&#123; User user = new User(20,\"张三\"); AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;(); atomicReference.set(user); &#125;&#125; 像这样，就把User类变成了原子User类了。 解决ABA问题思路： 我们可以这个共享变量带上一个版本号。比如现在主内存中的是A，版本号是1，然后t1和t2线程拷贝一份到自己工作内存。t2将A改为B，刷回主内存。此时主内存中的是B，版本号为2。然后再t2再改回A，此时主内存中的是A，版本号为3。这个时候t1线程终于来了，自己工作内存是A，版本号是1，主内存中是A，但是版本号为3，它就知道已经有人动过手脚了。那么这个版本号从何而来，这就要说说AtomicStampedReference这个类了。 带时间戳的原子引用(AtomicStampedReference)：这个时间戳就理解为版本号就行了。看如下代码： 1234567891011121314151617181920212223class ABADemo &#123; static AtomicStampedReference&lt;String&gt; atomicReference = new AtomicStampedReference&lt;&gt;(\"A\", 1); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(1);// 睡一秒，让t1线程拿到最初的版本号 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; atomicReference.compareAndSet(\"A\", \"B\", atomicReference.getStamp(), atomicReference.getStamp() + 1); atomicReference.compareAndSet(\"B\", \"A\", atomicReference.getStamp(), atomicReference.getStamp() + 1); &#125;, \"t2\").start(); new Thread(() -&gt; &#123; int stamp = atomicReference.getStamp();//拿到最开始的版本号 try &#123; TimeUnit.SECONDS.sleep(3);// 睡3秒，让t2线程的ABA操作执行完 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicReference.compareAndSet(\"A\", \"C\", stamp, stamp + 1)); &#125;, \"t1\").start(); &#125;&#125; 初始版本号为1，t2线程每执行一次版本号加。等t1线程执行的时候，发现当前版本号不是自己一开始拿到的1了，所以set失败，输出false。这就解决了ABA问题。 Unsafe Unsafe是实现CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。Unsafe类提供了硬件级别的原子操作。 Unsafe函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293///--------------------- peek and poke 指令--------------//获取对象o中给定偏移地址(offset)的值。以下相关get方法作用相同public native int getInt(Object o, long offset);//在对象o的给定偏移地址存储数值x。以下set方法作用相同public native void putInt(Object o, long offset, int x);public native Object getObject(Object o, long offset);public native void putObject(Object o, long offset, Object x);/**篇幅原因，省略其他类型方法 *///从给定内存地址获取一个byte。下同public native byte getByte(long address);//在给定内存地址放置一个x。下同public native void putByte(long address, byte x);/**篇幅原因，省略其他类型方法*///获取给定内存地址的一个本地指针public native long getAddress(long address);//在给定的内存地址处存放一个本地指针xpublic native void putAddress(long address, long x);///------------------内存操作----------------------//在本地内存分配一块指定大小的新内存，内存的内容未初始化;它们通常被当做垃圾回收。public native long allocateMemory(long bytes);//重新分配给定内存地址的本地内存public native long reallocateMemory(long address, long bytes);//将给定内存块中的所有字节设置为固定值（通常是0）public native void setMemory(Object o, long offset, long bytes, byte value);//复制一块内存，double-register模型public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);//复制一块内存，single-register模型public void copyMemory(long srcAddress, long destAddress, long bytes) &#123; copyMemory(null, srcAddress, null, destAddress, bytes);&#125;//释放给定地址的内存public native void freeMemory(long address);//获取给定对象的偏移地址public native long staticFieldOffset(Field f);public native long objectFieldOffset(Field f);//------------------数组操作---------------------------------//获取给定数组的第一个元素的偏移地址public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);//获取给定数组的元素增量地址，也就是说每个元素的占位数public native int arrayIndexScale(Class&lt;?&gt; arrayClass);//------------------------------------------------------------//告诉虚拟机去定义一个类。默认情况下，类加载器和保护域都来自这个方法public native Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);//定义匿名内部类public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);//定位一个实例，但不运行构造函数public native Object allocateInstance(Class&lt;?&gt; cls) throws InstantiationException;///--------------------锁指令（synchronized）-------------------------------//对象加锁public native void monitorEnter(Object o);//对象解锁public native void monitorExit(Object o);public native boolean tryMonitorEnter(Object o);//解除给定线程的阻塞public native void unpark(Object thread);//阻塞当前线程public native void park(boolean isAbsolute, long time);// CASpublic final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);//获取对象o的给定偏移地址的引用值（volatile方式）public native Object getObjectVolatile(Object o, long offset);public native void putObjectVolatile(Object o, long offset, Object x);/** 省略其他类型方法 *///用于lazySet，适用于低延迟代码。public native void putOrderedObject(Object o, long offset, Object x);/** 省略其他类型方法 *///获取并加上给定delta，返回加之前的值public final int getAndAddInt(Object o, long offset, int delta)/** 省略其他类型方法 *///为给定偏移地址设置一个新的值，返回设置之前的值public final int getAndSetInt(Object o, long offset, int newValue)/** 省略其他类型方法 *////--------------------1.8新增指令-----------------------// loadFence() 表示该方法之前的所有load操作在内存屏障之前完成public native void loadFence();//表示该方法之前的所有store操作在内存屏障之前完成public native void storeFence();//表示该方法之前的所有load、store操作在内存屏障之前完成，这个相当于上面两个的合体功能public native void fullFence(); Unsafe的方法比较简单，直接看方法字面意思就大概知道方法的作用。 在Unsafe里有两个方法模型： double-register模型：给定对象，给定偏移地址offset。从给定对象的偏移地址取值。如getInt(Object o, long offset)； single-register模型：给定内存地址，直接从给定内存地址取值，如getInt(long)。 这里介绍一下几个比较重要的方法，在之后的源码阅读里会用到。 arrayBaseOffset：操作数组，用于获取数组的第一个元素的偏移地址 arrayIndexScale：操作数组，用于获取数组元素的增量地址，也就是说每个元素的占位数。打个栗子：如果有一个数组{1,2,3,4,5,6}，它第一个元素的偏移地址为16，每个元素的占位是4，如果我们要获取数组中“5”这个数字，那么它的偏移地址就是16+4*4。 putOrderedObject：putOrderedObject 是 lazySet 的实现，适用于低延迟代码。它能够实现非堵塞写入，避免指令重排序，这样它使用快速的存储-存储(store-store) barrier,而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上。这种性能提升是有代价的，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到。类似的方法还有putOrderedInt、putOrderedLong。 loadFence、storeFence、fullFence：这三个方法是1.8新增，主要针对内存屏障定义，也是为了避免重排序： loadFence() 表示该方法之前的所有load操作在内存屏障之前完成。 storeFence()表示该方法之前的所有store操作在内存屏障之前完成。 fullFence()表示该方法之前的所有load、store操作在内存屏障之前完成。 总结：1.什么是CAS? —— 比较并交换，主内存值和工作内存值相同，就set为更新值。 2.CAS原理是什么？ —— UnSafe类和自旋锁。理解那个do while循环。 3.CAS缺点是什么？ —— 循环时间长会消耗大量CPU资源；只能保证一个共享变量的原子性操作；造成ABA问题。 4.什么是ABA问题？ —— t2线程先将A改成B，再改回A，此时t1线程以为没人修改过。 5.如何解决ABA问题？—— 使用带时间戳的原子引用。 参考引用链接：https://www.jianshu.com/p/8e74009684c7 ​ https://www.jianshu.com/p/a897c4b8929f","categories":[{"name":"JDK","slug":"JDK","permalink":"https://www.vazh.cn/categories/JDK/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://www.vazh.cn/tags/JUC/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.vazh.cn/tags/源码分析/"},{"name":"CAS","slug":"CAS","permalink":"https://www.vazh.cn/tags/CAS/"}]},{"title":"JDK源码阅读之ConcurrentHashMap","slug":"JDK源码阅读之ConcurrentHashMap","date":"2019-06-27T05:55:18.000Z","updated":"2019-06-27T05:55:18.000Z","comments":true,"path":"2019/06/27/JDK源码阅读之ConcurrentHashMap/","link":"","permalink":"https://www.vazh.cn/2019/06/27/JDK源码阅读之ConcurrentHashMap/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JDK源码阅读之String类","slug":"JDK源码阅读之String类","date":"2019-05-25T07:10:32.000Z","updated":"2019-09-04T02:51:15.791Z","comments":true,"path":"2019/05/25/JDK源码阅读之String类/","link":"","permalink":"https://www.vazh.cn/2019/05/25/JDK源码阅读之String类/","excerpt":"","text":"String类简介String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 String类的类图 该类实现了序列化接口，说明该类可以被序列化和反序列化（反序列化是构建对象的一种方式） 该类实现了比较器的接口，说明该类实现了默认的比较方式，在集合中的排序会根据这个比较的方式来进行排序。 该类实现了CharSequence 接口，CharSequence 是 char 值的一个可读序列。此接口对许多不同种类的 char 序列提供统一的只读访问 String类的重要方法源码解读String类域123456789101112131415161718/** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; /** * Class String is special cased within the Serialization Stream Protocol. * * A String instance is written into an ObjectOutputStream according to * &lt;a href=\"&#123;@docRoot&#125;/../platform/serialization/spec/output.html\"&gt; * Object Serialization Specification, Section 6.2, \"Stream Elements\"&lt;/a&gt; */ private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; 主要注意value和hash这两个域，String内部也是使用数组进行存储数据的，hash是这个字符串对应的哈希码，因为String是不可变的，当String的内容发生变化之后，虚拟机会生成一个新的字符串，并将String的引用只想这个字符串，这样如果String经常发生变化时，字符串常量表里面会有大量的字符串，会浪费内存，为了节约内存空间，一个方法是使用StringBuilder，StringBuilder是可变的，另一个方法就是为每一个不可变的字符串生成一个哈希码，这样如果字符串常量表中有现成的字符串时，就不需要再生成了，直接引用就行了.为了验证常量字符串的缓存。12345678public class TestDemo1 implements Cloneable &#123; public static void main(String[] args) throws Exception &#123; String a = \"abc\"; String b = \"abc\"; System.out.println(aString == bString); &#125;&#125; 上面程序的最终结果为true.这也证明了a和b指向的是同一个对象，即常量池只有一个”abc”字符串。当然，上面成立的前提是直接将字符串常量赋值给String引用才有效，如果使用new的话，就会在堆中生成对象，即使使用一样的字符串初始化，引用也不会相等。 采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在”abc”这个对象，如果不存在，则在字符串常量池中创建”abc”这个对象，然后将池中”abc”这个对象的引用地址返回给”abc”对象的引用s1，这样s1会指向字符串常量池中”abc”这个字符串对象；如果存在，则不创建任何对象，直接将池中”abc”这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的”abc”对象，所以结果为true。 123String s3 = new String(\"xyz\");String s4 = new String(\"xyz\");System.out.println(s3==s4); 结果是 false 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”xyz”这个字符串对象，如果有，则不在池中再去创建”xyz”这个对象了，直接在堆中创建一个”xyz”字符串对象，然后将堆中的这个”xyz”对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个”xyz”字符串对象；如果没有，则首先在字符串池中创建一个”xyz”字符串对象，然后再在堆中创建一个”xyz”字符串对象，然后将堆中这个”xyz”字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个”xyz”字符串对象。s4则指向了堆中创建的另一个”xyz”字符串对象。s3 、s4是两个指向不同对象的引用，指向的都是堆中的地址，结果当然是false。 构造函数 不带参数的构造函数，实际上就是空，源码如下。 123public String() &#123; this.value = \"\".value; &#125; 从上面的属性变量可以知道，我们这个类中主要有char数组和hash值。那么理所当然的，构造方法就是围绕着两个变量在展开的。将全部的构造方法阅读一遍之后，发现除了参数检验(下标越界)之外的操作，主要是： Arrays.copyOf() 和 Arrays.copyOfRange() 两个方法（如果涉及了编码问题会调用StringCoding.decode() 方法），将要组成String的值放入到char数组中。最后这两个方法都会调用System.arraycopy(), 然后就会发现这个方法调用系统方法(native 方法)。 1234567891011121314151617//通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。 public String(char value[], int offset, int count) &#123; //检验offset 初始偏移量 的值，不能小于0 if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; //检验 count 裁剪的数量 不能小于0 if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. //检验范围 if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count); &#125; 12345678910111213141516//通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 Stringpublic String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException(\"charset\"); //检验参数，如上 checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length); &#125;private static void checkBounds(byte[] bytes, int offset, int length) &#123; if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset &gt; bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length); &#125; 常用方法String 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。大小写映射基于 Character 类指定的 Unicode 标准版。 字符串判断相关方法 public boolean equals(Object anObject) 123456789101112131415161718192021222324// 比较两个字符串是否想等。public boolean equals(Object anObject) &#123; //首先判断两个对象是不是同一个对象，如果是那么一定是true,否则则进行第二道判断 if (this == anObject) &#123; return true; &#125; //首先判断对象是否是String类型对象，在底层就是将两个数组一个一个的对比 if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; public boolean equalsIgnoreCase(String anotherString) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 忽略大小写比较两个字符串是否相等public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length); &#125;//测试两个字符串区域是否相等。/**将此 String 对象的子字符串与参数 other 的子字符串进行比较。如果这两个子字符串表示相同的字符序列，则结果为 true，当且仅当 ignoreCase 为 true 时忽略大小写。要比较的此 String 对象的子字符串从索引 toffset 处开始，长度为 len。要比较的 other 的子字符串从索引 ooffset 处开始，长度为 len。当且仅当下列至少一项为 true 时，结果才为 false：**/ public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true; &#125; 忽略大小写的方法就是在比较的时候，在加上比较将两个字符同时转换成大写，小写的比较。至于为什么转成大写了之后，还要转换成小写的在比较一次，我也不是很清楚。官方的解释是：如果只比较大写的话，有些情况是不能得到我们想要的答案的。 public boolean startsWith(String prefix, int toffset) 12345678910111213141516171819202122232425//测试此字符串从指定索引开始的子字符串是否以指定前缀开始。public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true; &#125; public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0); &#125;public boolean endsWith(String suffix) &#123; return startsWith(suffix, value.length - suffix.value.length); &#125; startsWith函数用于检测字符串是否以prefix为前缀开始，是返回true。第一个是指定开始的下标索引，第二个则是从开始位置，endWith则是表示以suffix结尾, 底层还是通过调用startsWith, 计算出开始索引。 public int compareTo(String anotherString) 123456789101112131415161718public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2; &#125; String类实现了Comparable接口，所以说String是可比较的，compareTo的返回值是这样的，从两者的第一个字母比较过去，如果有一个字母不相等，则返回大的字母减去小的字母的int值，如果比较完了，则返回两者String的长度之差。符合compareTo方法的返回值要求，即：如果a小于b返回负数，如果a大于b，返回正数，否则返回0. 获取字符串的方法 public char charAt(int index) 123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index]; &#125; 获取某一个索引的字符，因为String是字符数组实现，所以直接返回value[index]即可 public int indexOf(String str) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int indexOf(String str) &#123; return indexOf(str, 0); &#125;public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ // 寻找第一个字符相同的地方 if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ // 继续对比接下来的字符 if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125; 原来判断字符串1是不是字符串2的子串，java的源码是使用暴力循环，并没有使用其他的算法。 public String substring(int beginIndex, int endIndex) 1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); &#125; 返回一个新的String对象, 截取字符串方法，包括beginIndex索引，不包括endIndex索引 另一个方法substring(int beginIndex)是截取从索引 beginIndex 到结尾。 字符串转换的方法 public char[] toCharArray() 123456public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; 第一眼看到这个方法，结合String以字符数组实现，我以为会直接返回对象数组，现在看了代码之后发现不是，后来想一想发现，数组是引用类型，如果将数组的引用放出去，那么String的值也会相应的改变。如果发生这个，那么就会产生很大的灾难。 public String toLowerCase() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public String toLowerCase() &#123; return toLowerCase(Locale.getDefault()); &#125; // 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 public String toLowerCase(Locale locale) &#123; if (locale == null) &#123; throw new NullPointerException(); &#125; int firstUpper; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: &#123; for (firstUpper = 0 ; firstUpper &lt; len; ) &#123; char c = value[firstUpper]; if ((c &gt;= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123; int supplChar = codePointAt(firstUpper); if (supplChar != Character.toLowerCase(supplChar)) &#123; break scan; &#125; firstUpper += Character.charCount(supplChar); &#125; else &#123; if (c != Character.toLowerCase(c)) &#123; break scan; &#125; firstUpper++; &#125; &#125; return this; &#125; char[] result = new char[len]; int resultOffset = 0; /* result may grow, so i+resultOffset * is the write location in result */ /* Just copy the first few lowerCase characters. */ System.arraycopy(value, 0, result, 0, firstUpper); String lang = locale.getLanguage(); boolean localeDependent = (lang == \"tr\" || lang == \"az\" || lang == \"lt\"); char[] lowerCharArray; int lowerChar; int srcChar; int srcCount; for (int i = firstUpper; i &lt; len; i += srcCount) &#123; srcChar = (int)value[i]; if ((char)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123; srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); &#125; else &#123; srcCount = 1; &#125; if (localeDependent || srcChar == '\\u03A3') &#123; // GREEK CAPITAL LETTER SIGMA lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale); &#125; else if (srcChar == '\\u0130') &#123; // LATIN CAPITAL LETTER I DOT lowerChar = Character.ERROR; &#125; else &#123; lowerChar = Character.toLowerCase(srcChar); &#125; if ((lowerChar == Character.ERROR) || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123; if (lowerChar == Character.ERROR) &#123; if (!localeDependent &amp;&amp; srcChar == '\\u0130') &#123; lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, Locale.ENGLISH); &#125; else &#123; lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale); &#125; &#125; else if (srcCount == 2) &#123; resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount; continue; &#125; else &#123; lowerCharArray = Character.toChars(lowerChar); &#125; /* Grow result if needed */ int mapLen = lowerCharArray.length; if (mapLen &gt; srcCount) &#123; char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; &#125; for (int x = 0; x &lt; mapLen; ++x) &#123; result[i + resultOffset + x] = lowerCharArray[x]; &#125; resultOffset += (mapLen - srcCount); &#125; else &#123; result[i + resultOffset] = (char)lowerChar; &#125; &#125; return new String(result, 0, len + resultOffset); &#125; 其他方法 public String trim()1234567891011121314// 返回字符串的副本，忽略前导空白和尾部空白。 public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; &#125; 将字符串前导空白和尾部空白忽略。 public String[] split(String regex, int limit) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public String[] split(String regex, int limit) &#123; /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters \".$|()[&#123;^?*+\\\\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 &amp;&amp; \".$|()[&#123;^?*+\\\\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) resultSize--; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit); &#125; 内部使用arrayList集合来收集被分割的子串，子串是通过substring（）方法来得到的，参数是通过indexof方法来获取的。 public String concat(String str) 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); &#125; intern方法1public native String intern(); intern方法是一个本地方法，调用该方法，会判断是否常量池中有一个与该String对象相等的对象（也就是equals返回0），如果有返回常量池中的对象，否则，将该String对象添加到常量池中再返回常量池中的对象。 String类涉及的设计模式享元模式模式解释一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素 String类的体现因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。 阅读String类的感想String类是我们最常使用的一个类，我们也都知道String类是不可改变的，每当改变一个变量的值时候，地址也会随之改变。基于这种不变的特性，出现了享元模式，让系统中的多个相同的String共享一个地址，避免了开销。 String类的底层是char数组，所以我们看到String的方法（对字符串的操作）底层都是操作数组。其实我们看到方法之后，了解底层是数组，对方法的一些大概操作是可以预知的，在读完源码之后，会更加清晰明了。","categories":[{"name":"JDK","slug":"JDK","permalink":"https://www.vazh.cn/categories/JDK/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.vazh.cn/tags/源码阅读/"}]},{"title":"Leetcode17-电话号码的字母组合","slug":"Leetcode17-电话号码的字母组合","date":"2019-05-25T02:56:07.000Z","updated":"2019-09-04T02:54:55.852Z","comments":true,"path":"2019/05/25/Leetcode17-电话号码的字母组合/","link":"","permalink":"https://www.vazh.cn/2019/05/25/Leetcode17-电话号码的字母组合/","excerpt":"","text":"Description 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 123&gt; 输入：&quot;23&quot;&gt; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].&gt; 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 Method 使用字符串数组map存储电话号码的字母映射 使用深度遍历方法DFS , 依次遍历digits的数字，再字典map中查找，组合可能 如果拼接的字符串长度等于数字字符长度，则添加该字符串 返回结果 123456789101112131415161718private String[] map = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (digits != null &amp;&amp; digits.length() &gt; 0) dfs(ans, \"\", digits); return ans; &#125; public void dfs(List&lt;String&gt; ans, String cur, String digits) &#123; if (cur.length() == digits.length()) &#123; ans.add(cur); return; &#125; int index = digits.charAt(cur.length()) - '0'; for (int i = 0; i &lt; map[index].length(); i++) &#123; dfs(ans, cur + map[index].charAt(i), digits); &#125; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Letter Combinations of a Phone Number. Memory Usage: 35.2 MB, less than 98.30% of Java online submissions for Letter Combinations of a Phone Number. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.vazh.cn/tags/贪心/"},{"name":"DFS","slug":"DFS","permalink":"https://www.vazh.cn/tags/DFS/"}]},{"title":"Leetcode300-最长上升子序列","slug":"Leetcode300-最长上升子序列","date":"2019-05-25T02:12:03.000Z","updated":"2019-09-04T04:32:58.468Z","comments":true,"path":"2019/05/25/Leetcode300-最长上升子序列/","link":"","permalink":"https://www.vazh.cn/2019/05/25/Leetcode300-最长上升子序列/","excerpt":"","text":"Description 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 1234&gt; 输入: [10,9,2,5,3,7,101,18]&gt; 输出: 4 &gt; 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。&gt; 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? Method One 如果长度小于等于1,直接返回nunms.length max 记录当前遍历i 情况下的最长子串长度, dp[i] 存放最长子串的最后一个元素值（最大值） 如果当前元素比最大的那个子串的最后一个元素还要大，那就直接长度加一，新子串的最后一个元素为当前元素 如果当前元素比最大的那个子串的最后一个元素要小，那就要更新dp数组，保证每一个子串都是最优解 12345678910111213141516171819202122232425262728public int lengthOfLIS(int[] nums) &#123; if(nums.length &lt;= 1)&#123; return nums.length; &#125; //最大长度 int max = 1; //dp[i]表示第i长的子序列，最后的元素 int[] dp = new int[nums.length + 1]; dp[1] = nums[0]; for(int i = 1;i &lt; nums.length;i++)&#123; //如果当前元素比最大的那个子串的最后一个元素还要大 //那就直接长度加一，新子串的最后一个元素为当前元素 if(nums[i] &gt; dp[max])&#123; dp[++max] = nums[i]; &#125;else if(nums[i] &lt; dp[max])&#123; //如果当前元素比最大的那个子串的最后一个元素要小 //那就要更新dp数组，保证每一个子串都是最优解 for(int j = 1 ;j &lt;= max; j++)&#123; //因为是递增，所以是&lt;=,在将等于的时候直接终止循环 if(nums[i] &lt;= dp[j])&#123; dp[j] = nums[i]; break; &#125; &#125; &#125; &#125; return max; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence. Memory Usage: 36.3 MB, less than 57.53% of Java online submissions for Longest Increasing Subsequence. Method Two 如果长度小于等于1,直接返回nunms.length max 记录当前遍历i 情况下的最长子串长度, dp[i] 存放最长子串的最后一个元素值（最大值） 如果当前元素比最大的那个子串的最后一个元素还要大，那就直接长度加一，新子串的最后一个元素为当前元素 如果当前元素比最大的那个子串的最后一个元素要小，那就要更新dp数组，保证每一个子串都是最优解，采用二分查找法，因为dp是严格递增的数组 123456789101112131415161718192021222324252627282930public int lengthOfLIS(int[] nums) &#123; int len = nums.length; if(len &lt;= 1)&#123; return len; &#125; int maxL = 0; //dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数 int[] dp = new int[nums.length]; dp[0] = nums[0]; for(int i = 1; i &lt; len; i++)&#123; if(nums[i] &gt; dp[maxL])&#123; dp[++maxL]= nums[i]; &#125;else&#123; int left = 0, right = maxL; while(left &lt; right)&#123; int mid = left + (right-left)/2; if(dp[mid] == nums[i])&#123; left = mid; break; &#125;else if(dp[mid] &lt; nums[i])&#123; left = left + 1; &#125;else&#123; right = mid; &#125; &#125; dp[left] = nums[i]; &#125; &#125; return ++maxL; &#125; Complexity Analysis Time complexity : O(n log n). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence. Memory Usage: 36.3 MB, less than 57.53% of Java online submissions for Longest Increasing Subsequence. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://www.vazh.cn/tags/DP/"}]},{"title":"Leetcode120-三角形最小路径和","slug":"Leetcode120-三角形最小路径和","date":"2019-05-07T03:23:52.000Z","updated":"2019-09-04T04:31:58.688Z","comments":true,"path":"2019/05/07/Leetcode120-三角形最小路径和/","link":"","permalink":"https://www.vazh.cn/2019/05/07/Leetcode120-三角形最小路径和/","excerpt":"","text":"Description 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 1234567&gt; [&gt; [2],&gt; [3,4],&gt; [6,5,7],&gt; [4,1,8,3]&gt; ]&gt; 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 Method 动态规划题型，已知最佳路径，则最佳路径必定经过上一层的两个值中较小值 从倒数第二层开始遍历，用长度为n的整形数组a 统计当前层的每一列的最优长度 对当前层，对上一层每相邻的两个数据进行比对大小，将较小值加到a[j] 上，记录每一列的最优值 最后到第０层，取第一层中较小值加到a[0]上 返回最小值a[0] 123456789101112131415161718// 动态规划 // 状态定义 dp[i][j] 包含 dp[i][j]的最小值 // 地推方程 dp[i][j] = min&#123;dp[i + 1][j], dp[i + 1][j + 1] &#125; + nums[i][j] public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null || triangle.get(0) == null) return 0; int m = triangle.size(), n = triangle.size(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = triangle.get(n - 1).get(i); for (int i = n - 2; i &gt;= 0; i--) &#123; List&lt;Integer&gt; cur = triangle.get(i); for(int j = 0; j &lt; i + 1; j++) &#123; a[j] = a[j] &lt; a[j + 1] ? a[j] : a[j + 1]; a[j] += cur.get(j); &#125; &#125; return a[0]; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 99.94% of Java online submissions for Triangle. Memory Usage: 37.9 MB, less than 77.62% of Java online submissions for Triangle. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.vazh.cn/tags/动态规划/"}]},{"title":"Leetcode55-跳跃游戏","slug":"Leetcode55-跳跃游戏","date":"2019-05-07T03:23:07.000Z","updated":"2019-09-04T04:27:52.747Z","comments":true,"path":"2019/05/07/Leetcode55-跳跃游戏/","link":"","permalink":"https://www.vazh.cn/2019/05/07/Leetcode55-跳跃游戏/","excerpt":"","text":"Description 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 1234&gt; 输入: [2,3,1,1,4]&gt; 输出: true&gt; 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。&gt; 示例 2: 1234&gt; 输入: [3,2,1,0,4]&gt; 输出: false&gt; 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。&gt; Method 从后向前遍历，从倒数第二个点判断能否到达最后一个点 分两种情况，若可以，即nums[i] 大于i到终点距离(minEnd - i), 这时，将终点修改为当前点，因为当前点可达 若不可以，继续向前遍历，终点minEnd不变，继续寻找，最后若minEnd为起点0,则说明从起点到终点可达 返回 minEnd 等于0是否为真 123456789public boolean canJump(int[] nums) &#123; int length = nums.length, minEnd = length - 1; for (int i = minEnd; i &gt;= 0; i--) &#123; if (nums[i] &gt;= (minEnd - i)) &#123; minEnd = i; &#125; &#125; return minEnd == 0; &#125; Complexity Analysis Time complexity : O( n). Space complexity : O(1). AcceptedRuntime: 1 ms, faster than 99.93% of Java online submissions for Jump Game. Memory Usage: 41.4 MB, less than 16.44% of Java online submissions for Jump Game. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode52-N皇后问题2","slug":"Leetcode52-N皇后问题2","date":"2019-05-07T02:52:41.000Z","updated":"2019-09-04T04:27:47.055Z","comments":true,"path":"2019/05/07/Leetcode52-N皇后问题2/","link":"","permalink":"https://www.vazh.cn/2019/05/07/Leetcode52-N皇后问题2/","excerpt":"","text":"Description n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例: 123456789101112131415&gt; 输入: 4&gt; 输出: 2&gt; 解释: 4 皇后问题存在如下两个不同的解法。&gt; [&gt; [&quot;.Q..&quot;, // 解法 1&gt; &quot;...Q&quot;,&gt; &quot;Q...&quot;,&gt; &quot;..Q.&quot;],&gt; &gt; [&quot;..Q.&quot;, // 解法 2&gt; &quot;Q...&quot;,&gt; &quot;...Q&quot;,&gt; &quot;.Q..&quot;]&gt; ]&gt; Method N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到 采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放 利用checkPerRow函数，检测摆放皇后是否满足条件 若发现摆放的皇后不满足要求，则回退, list删除刚摆放的不满足的皇后 若满足条件，则递归，将层数加一，若层数等于N,则将结果加一，即total++ 返回全局变量total 1234567891011121314151617181920212223242526272829private int total = 0; public int totalNQueens(int n) &#123; int[] rows = new int[n]; perRowQueen(0, rows, n); return total; &#125; private void perRowQueen(int row, int[] rows, int n) &#123; if (row &gt;= n) &#123; total++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; rows[row] = i; if (checkPerRow(row, rows)) &#123; perRowQueen(row + 1, rows, n); &#125; &#125; &#125; private boolean checkPerRow(int row, int[] rows) &#123; for (int i = 0; i &lt; row; i++) &#123; if (rows[row] == rows[i] || Math.abs(row - i) == Math.abs(rows[row] - rows[i])) &#123; return false; &#125; &#125; return true; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 97.11% of Java online submissions for N-Queens 2. Memory Usage: 31.7 MB, less than 100.00% of Java online submissions for N-Queens 2. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"回溯法","slug":"回溯法","permalink":"https://www.vazh.cn/tags/回溯法/"}]},{"title":"Leetcode51-N皇后问题2","slug":"Leetcode51-N皇后问题2","date":"2019-05-07T02:52:41.000Z","updated":"2019-09-04T04:26:46.770Z","comments":true,"path":"2019/05/07/Leetcode51-N皇后问题2/","link":"","permalink":"https://www.vazh.cn/2019/05/07/Leetcode51-N皇后问题2/","excerpt":"","text":"Description n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例: 123456789101112131415&gt; 输入: 4&gt; 输出: 2&gt; 解释: 4 皇后问题存在如下两个不同的解法。&gt; [&gt; [&quot;.Q..&quot;, // 解法 1&gt; &quot;...Q&quot;,&gt; &quot;Q...&quot;,&gt; &quot;..Q.&quot;],&gt; &gt; [&quot;..Q.&quot;, // 解法 2&gt; &quot;Q...&quot;,&gt; &quot;...Q&quot;,&gt; &quot;.Q..&quot;]&gt; ]&gt; Method N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到 采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放 利用checkPerRow函数，检测摆放皇后是否满足条件 若发现摆放的皇后不满足要求，则回退, list删除刚摆放的不满足的皇后 若满足条件，则递归，将层数加一，若层数等于N,则将结果加一，即total++ 返回全局变量total 1234567891011121314151617181920212223242526272829private int total = 0; public int totalNQueens(int n) &#123; int[] rows = new int[n]; perRowQueen(0, rows, n); return total; &#125; private void perRowQueen(int row, int[] rows, int n) &#123; if (row &gt;= n) &#123; total++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; rows[row] = i; if (checkPerRow(row, rows)) &#123; perRowQueen(row + 1, rows, n); &#125; &#125; &#125; private boolean checkPerRow(int row, int[] rows) &#123; for (int i = 0; i &lt; row; i++) &#123; if (rows[row] == rows[i] || Math.abs(row - i) == Math.abs(rows[row] - rows[i])) &#123; return false; &#125; &#125; return true; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 97.11% of Java online submissions for N-Queens 2. Memory Usage: 31.7 MB, less than 100.00% of Java online submissions for N-Queens 2. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"回溯法","slug":"回溯法","permalink":"https://www.vazh.cn/tags/回溯法/"}]},{"title":"Leetcode51-N皇后问题","slug":"Leetcode51-N皇后问题","date":"2019-05-07T02:45:32.000Z","updated":"2019-09-04T04:26:36.718Z","comments":true,"path":"2019/05/07/Leetcode51-N皇后问题/","link":"","permalink":"https://www.vazh.cn/2019/05/07/Leetcode51-N皇后问题/","excerpt":"","text":"Description n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例: 1234567891011121314&gt; 输入: 4&gt; 输出: [&gt; [&quot;.Q..&quot;, // 解法 1&gt; &quot;...Q&quot;,&gt; &quot;Q...&quot;,&gt; &quot;..Q.&quot;],&gt; &gt; [&quot;..Q.&quot;, // 解法 2&gt; &quot;Q...&quot;,&gt; &quot;...Q&quot;,&gt; &quot;.Q..&quot;]&gt; ]&gt; 解释: 4 皇后问题存在两个不同的解法。&gt; Method N皇后问题要求在棋盘上，每一个皇后在每一行每一列，每一条斜线上不能攻击到 采用回溯法，对0～ N-1行依次进行排放皇后，对于每一行，对每一列进行试探摆放 利用三个boolean数组分别对当前皇后的列，左上，右上进行判断（右上则横纵坐标和相等） 若发现摆放的皇后不满足要求，则回退，将boolean数组值复位（false）,list删除刚摆放的不满足的皇后 返回res 1234567891011121314151617181920212223242526272829private List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; helper(0, n, new boolean[n], new boolean[2*n-1], new boolean[2*n-1], new ArrayList&lt;&gt;()); return res; &#125; private void helper(int row, int n, boolean[] cols, boolean[] d1, boolean[] d2, List&lt;String&gt; list)&#123; if(row == n)&#123; res.add(new ArrayList&lt;&gt;(list)); return; &#125; for(int col = 0; col &lt; n; col++)&#123; int d1Num = col + row; int d2Num = col - row + n - 1; if(!cols[col] &amp;&amp; !d1[d1Num] &amp;&amp;!d2[d2Num])&#123; char[] temp = new char[n]; Arrays.fill(temp,'.'); temp[col] = 'Q'; cols[col] = true; d1[d1Num] = true; d2[d2Num] = true; list.add(new String(temp)); helper(row + 1, n, cols, d1, d2, list); cols[col] = false; d1[d1Num] = false; d2[d2Num] = false; list.remove(list.size() - 1); &#125; &#125; &#125; Complexity Analysis Time complexity : O(n * n). Space complexity : O(n). AcceptedRuntime: 2 ms, faster than 97.49% of Java online submissions for N-Queens. Memory Usage: 38.8 MB, less than 62.86% of Java online submissions for N-Queens. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"回溯法","slug":"回溯法","permalink":"https://www.vazh.cn/tags/回溯法/"}]},{"title":"数据结构与算法-表、栈和队列","slug":"数据结构与算法-表、栈和队列","date":"2019-05-05T04:45:40.000Z","updated":"2019-05-05T04:46:33.000Z","comments":true,"path":"2019/05/05/数据结构与算法-表、栈和队列/","link":"","permalink":"https://www.vazh.cn/2019/05/05/数据结构与算法-表、栈和队列/","excerpt":"","text":"表、栈和队列本章重点 介绍抽象数据类型的概念 阐述如何有效的执行表的操作 介绍栈ADT及其在实现递归方面的应用 介绍队列ADT及其在操作系统和算法设计中的应用","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.vazh.cn/categories/数据结构/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.vazh.cn/tags/栈/"},{"name":"队列","slug":"队列","permalink":"https://www.vazh.cn/tags/队列/"}]},{"title":"Leetcode14-最长公共前缀","slug":"Leetcode14-最长公共前缀","date":"2019-05-05T03:15:38.000Z","updated":"2019-09-04T02:54:27.183Z","comments":true,"path":"2019/05/05/Leetcode14-最长公共前缀/","link":"","permalink":"https://www.vazh.cn/2019/05/05/Leetcode14-最长公共前缀/","excerpt":"","text":"Description 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 123&gt; 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]&gt; 输出: &quot;fl&quot;&gt; 示例 2: 1234&gt; 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]&gt; 输出: &quot;&quot;&gt; 解释: 输入不存在公共前缀。&gt; 说明: 所有输入只包含小写字母 a-z 。 Method 利用StringBuilder保存第一个字符串，然后分别对另外的n-1个字符串判断，是不是以match为前缀 使用startWith函数判断，并依次裁剪match直到match满足所有的字符串 返回match 123456789101112public String longestCommonPrefix(String[] strs) &#123; if (strs.length &lt; 1) return \"\"; if (strs.length == 1) return strs[0]; StringBuilder match = new StringBuilder(strs[0]); for (int i = 1; i &lt; strs.length; i++) &#123; while (!strs[i].startsWith(match.toString())) &#123; match.deleteCharAt(match.length() - 1); if (match.length() &lt; 1) return \"\"; &#125; &#125; return match.toString(); &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(n). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Longest Common Prefix. Memory Usage: 38.8 MB, less than 20.63% of Java online submissions for Longest Common Prefix. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.vazh.cn/tags/String/"}]},{"title":"Leetcode01-两数之和","slug":"Leetcode01-两数之和","date":"2019-05-05T03:14:36.000Z","updated":"2019-09-04T02:39:14.978Z","comments":true,"path":"2019/05/05/Leetcode01-两数之和/","link":"","permalink":"https://www.vazh.cn/2019/05/05/Leetcode01-两数之和/","excerpt":"","text":"Description 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 12345&gt; 给定 nums = [2, 7, 11, 15], target = 9&gt; &gt; 因为 nums[0] + nums[1] = 2 + 7 = 9&gt; 所以返回 [0, 1]&gt; Method 题目求解两个数之和等于目标数的数组下标 转化为将数字存放进哈希表，然后每一次检测目标数减去nums[i] (每一次数组遍历值) 若找到返回下标值 12345678910111213public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(target-nums[i]))&#123; result[1] = i; result[0] = map.get(target-nums[i]); return result; &#125; map.put(nums[i],i); &#125; return result; &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(n). AcceptedRuntime: 3 ms, faster than 99.54% of Java online submissions for Two Sum. Memory Usage: 38.9 MB, less than 31.85% of Java online submissions for Two Sum. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"HashTable","slug":"HashTable","permalink":"https://www.vazh.cn/tags/HashTable/"}]},{"title":"Leetcode122-买卖股票的最佳时机2","slug":"Leetcode122-买卖股票的最佳时机2","date":"2019-05-05T02:57:23.000Z","updated":"2019-09-04T04:32:10.708Z","comments":true,"path":"2019/05/05/Leetcode122-买卖股票的最佳时机2/","link":"","permalink":"https://www.vazh.cn/2019/05/05/Leetcode122-买卖股票的最佳时机2/","excerpt":"","text":"Description 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 12345&gt; 输入: [7,1,5,3,6,4]&gt; 输出: 7&gt; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&gt; 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。&gt; 示例 2: 123456&gt; 输入: [1,2,3,4,5]&gt; 输出: 4&gt; 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&gt; 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。&gt; 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。&gt; 示例 3: 1234&gt; 输入: [7,6,4,3,1]&gt; 输出: 0&gt; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&gt; Method 与上一题的买卖股票较为类似，不同的是可以重复购买 所以只需要计算相邻之间的差值，如果大于0，则累加，即是一次交易（上一次买入，这一次卖出） 返回数组大于零的累积和 12345678910111213public int maxProfit(int[] prices) &#123; if (prices.length &lt; 2) return 0; int[] dp = new int[prices.length]; for (int i = 1; i &lt; prices.length; i++)&#123; dp[i] = prices[i] - prices[i - 1]; &#125; int res = 0; for (int i = 1; i &lt; dp.length; i++)&#123; if (dp[i] &gt; 0) res += dp[i]; &#125; return res; &#125; Complexity Analysis Time complexity : O(n). Space complexity : O(n). AcceptedRuntime: 1 ms, faster than 81.61% of Java online submissions for Buy and Sell Stock 2. Memory Usage: 38.6 MB, less than 56.12% of Java online submissions for Buy and Sell Stock 2. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://www.vazh.cn/tags/dp/"}]},{"title":"Leetcode121-买卖股票的最佳时机","slug":"Leetcode121-买卖股票的最佳时机","date":"2019-05-05T02:52:54.000Z","updated":"2019-09-04T04:32:04.676Z","comments":true,"path":"2019/05/05/Leetcode121-买卖股票的最佳时机/","link":"","permalink":"https://www.vazh.cn/2019/05/05/Leetcode121-买卖股票的最佳时机/","excerpt":"","text":"Description 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 12345&gt; 输入: [7,1,5,3,6,4]&gt; 输出: 5&gt; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&gt; 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。&gt; 示例 2: 1234&gt; 输入: [7,6,4,3,1]&gt; 输出: 0&gt; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&gt; AlgorithmMethod 对价格数组进行遍历，每次记录当前最小值，与股票最大收益 每次对股票最大收益与之前的最大收益作对比，进行更新最大值 返回最大值 1234567891011public int maxProfit(int[] prices) &#123; int max = Integer.MIN_VALUE; int minValue = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minValue) minValue = prices[i]; if (prices[i] - minValue &gt; max) max = prices[i] - minValue; &#125; return max &gt; 0 ? max : 0; &#125; Complexity Analysis Time complexity : O( n). Space complexity : O(1). AcceptedRuntime: 0ms, faster than 100.00% of Java online submissions for Buy and Sell Stock. Memory Usage: 38.7 MB, less than 53.26% of Java online submissions for Buy and Sell Stock. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://www.vazh.cn/tags/dp/"}]},{"title":"Leetcode064-最小路径和","slug":"Leetcode064-最小路径和","date":"2019-05-05T02:37:16.000Z","updated":"2019-09-04T04:28:30.287Z","comments":true,"path":"2019/05/05/Leetcode064-最小路径和/","link":"","permalink":"https://www.vazh.cn/2019/05/05/Leetcode064-最小路径和/","excerpt":"","text":"Description 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 123456789&gt; 输入:&gt; [&gt; [1,3,1],&gt; [1,5,1],&gt; [4,2,1]&gt; ]&gt; 输出: 7&gt; 解释: 因为路径 1→3→1→1→1 的总和最小。&gt; AlgorithmMethod 这是一道典型的动态规划题，首先若想保证路径和最小，则从上一步中取最小值 最小值是 grid [i-1] [j] 和 grid[i] [j-1]中的最小值 最后grid[m-1] [n-1]就是结果 12345678910111213141516171819202122public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; if(m == 0 || n == 0)&#123; return 0; &#125; for (int i = 0; i &lt; m; i++)&#123; if (i &gt; 0)&#123; grid[i][0] += grid[i - 1][0]; &#125; &#125; for (int j = 0; j &lt; n; j++)&#123; if (j &gt; 0)&#123; grid[0][j] += grid[0][j - 1]; &#125; &#125; for (int i = 1; i &lt; m; i++) for(int j = 1; j &lt; n; j++)&#123; grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); &#125; return grid[m - 1][n - 1]; &#125; Complexity Analysis Time complexity : O(m * n). Space complexity : O(log n). AcceptedRuntime: 2 ms, faster than 96.31% of Java online submissions for Minimum Path Sum. Memory Usage: 44.3 MB, less than 11.79% of Java online submissions for Minimum Path Sum. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://www.vazh.cn/tags/dp/"}]},{"title":"Leetcode66-Plus One","slug":"Leetcode66-Plus-One","date":"2019-03-25T03:28:27.000Z","updated":"2019-09-04T04:28:39.011Z","comments":true,"path":"2019/03/25/Leetcode66-Plus-One/","link":"","permalink":"https://www.vazh.cn/2019/03/25/Leetcode66-Plus-One/","excerpt":"","text":"Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: 1234&gt; Input: [1,2,3]&gt; Output: [1,2,4]&gt; Explanation: The array represents the integer 123.&gt; Example 2: 1234&gt; Input: [4,3,2,1]&gt; Output: [4,3,2,2]&gt; Explanation: The array represents the integer 4321.&gt; Accepted 364,557 Submissions 893,110 AlgorithmMethod From the low to the high, it is judged whether it is 9 or not. If it is, the current position is 0. Finally, add one at the highest position that needs to be carried. If the highest bit complement is required, expand the array and assign the highest bit to 1 1234567891011121314151617181920public int[] plusOne(int[] digits) &#123; int n = digits.length - 1; if (digits[n] != 9)&#123; digits[n]++; return digits; &#125; while (n &gt;= 0 &amp;&amp; digits[n] == 9)&#123; digits[n] = 0; n--; &#125; if (n &gt;= 0)&#123; digits[n]++; &#125;else &#123; int[] digits2 = Arrays.copyOf(digits, digits.length + 1); digits2[0] = 1; return digits2; &#125; return digits; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Plus One. Memory Usage: 37.3 MB, less than 5.01% of Java online submissions for Plus One. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode98-Validate Binary Search Tree","slug":"Leetcode98-Validate-Binary-Search-Tree","date":"2019-03-25T03:10:32.000Z","updated":"2019-09-04T04:31:51.912Z","comments":true,"path":"2019/03/25/Leetcode98-Validate-Binary-Search-Tree/","link":"","permalink":"https://www.vazh.cn/2019/03/25/Leetcode98-Validate-Binary-Search-Tree/","excerpt":"","text":"Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456&gt; Input:&gt; 2&gt; / \\&gt; 1 3&gt; Output: true&gt; Example 2: 123456789&gt; 5&gt; / \\&gt; 1 4&gt; / \\&gt; 3 6&gt; Output: false&gt; Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value&gt; is 5 but its right child&apos;s value is 4.&gt; Accepted 371,783 Submissions 1,465,105 AlgorithmMethod Use the in-order traversal algorithm, because the in-order traversal just happens to be an ascending sequence Returns false if the ascending condition is not met, otherwise returns true 12345678910111213double last = -Double.MAX_VALUE; public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (isValidBST(root.left)) &#123; if (last &lt; root.val) &#123; last = root.val; return isValidBST(root.right); &#125; &#125; return false; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree. Memory Usage: 40.5 MB, less than 5.01% of Java online submissions for Validate Binary Search Tree. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.vazh.cn/tags/DFS/"},{"name":"Tree","slug":"Tree","permalink":"https://www.vazh.cn/tags/Tree/"}]},{"title":"Leetcode150-Evaluate Reverse Polish Notation","slug":"Leetcode150-Evaluate-Reverse-Polish-Notation","date":"2019-03-25T03:02:24.000Z","updated":"2019-09-04T04:32:38.352Z","comments":true,"path":"2019/03/25/Leetcode150-Evaluate-Reverse-Polish-Notation/","link":"","permalink":"https://www.vazh.cn/2019/03/25/Leetcode150-Evaluate-Reverse-Polish-Notation/","excerpt":"","text":"Description Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: 1234&gt; Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]&gt; Output: 9&gt; Explanation: ((2 + 1) * 3) = 9&gt; Example 2: 1234&gt; Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]&gt; Output: 6&gt; Explanation: (4 + (13 / 5)) = 6&gt; Example 3: 1234567891011&gt; Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]&gt; Output: 22&gt; Explanation: &gt; ((10 * (6 / ((9 + 3) * -11))) + 17) + 5&gt; = ((10 * (6 / (12 * -11))) + 17) + 5&gt; = ((10 * (6 / -132)) + 17) + 5&gt; = ((10 * 0) + 17) + 5&gt; = (0 + 17) + 5&gt; = 17 + 5&gt; = 22&gt; Accepted 153,410 Submissions 485,932 AlgorithmMethod Determine if each string is a number If it is a number, put it on the stack If it is an operator, take the two numbers in the stack and put them into the stack. Returns the last number in the stack 12345678910111213141516171819202122232425262728public int evalRPN(String[] tokens) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); int num1, num2; for (int i = 0; i &lt; tokens.length; i++) &#123; if (Character.isDigit(tokens[i].charAt(tokens[i].length()-1)))&#123; stack.push(tokens[i]); &#125; else &#123; num2 = Integer.valueOf(stack.pop()); num1 = Integer.valueOf(stack.pop()); switch (tokens[i]) &#123; case \"+\": stack.push(String.valueOf(num1 + num2)); break; case \"-\": stack.push(String.valueOf(num1 - num2)); break; case \"*\": stack.push(String.valueOf(num1 * num2)); break; case \"/\": stack.push(String.valueOf(num1 / num2)); break; &#125; &#125; &#125; return Integer.parseInt(stack.peek()); &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). AcceptedRuntime: 7 ms, faster than 52.44% of Java online submissions for Evaluate Reverse Polish Notation. Memory Usage: 38.7 MB, less than 22.01% of Java online submissions for Evaluate Reverse Polish Notation. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://www.vazh.cn/tags/Stack/"}]},{"title":"Leetcode73-Set Matrix Zeroes","slug":"Leetcode73-Set-Matrix-Zeroes","date":"2019-03-19T05:10:55.000Z","updated":"2019-09-04T04:29:27.479Z","comments":true,"path":"2019/03/19/Leetcode73-Set-Matrix-Zeroes/","link":"","permalink":"https://www.vazh.cn/2019/03/19/Leetcode73-Set-Matrix-Zeroes/","excerpt":"","text":"Description Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Accepted 194,111 Submissions 496,295 AlgorithmMethod One start with rowFlag,colFlag to indicate whether 0 exists in the first row, first column then use a HashSet to store the existing row and column labels of 0 (distinct row labels are represented by negative Numbers) iterates over the HashSet, setting the row and column to 0 set the first row, first column to 0 according to flag 中文： 首先用rowFlag,colFlag标志第一行第一列是否存在0 然后用HashSet存放存在的0的行标与列标(区别行标用负数表示) 遍历HashSet,将所在行与所在列置为0 依据flag将第一行，第一列置为0 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void setZeroes(int[][] matrix) &#123; if (matrix == null) return; int m = matrix.length; int n = matrix[0].length; int rowFlag = 0; int colFlag = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; matrix.length; i++) for(int j = 0; j &lt; matrix[i].length; j++)&#123; if (matrix[i][j] == 0)&#123; // save the index if (i != 0)&#123; set.add(i); &#125;else&#123; rowFlag = 1; &#125; if (j != 0)&#123; set.add(-j); &#125; else&#123; colFlag = 1; &#125; &#125; &#125; for (Integer ln : set)&#123; if (ln &gt; 0)&#123; for (int i = 0; i &lt; n; i++)&#123; matrix[ln][i] = 0; &#125; &#125; else if(ln &lt; 0)&#123; for (int i = 0; i &lt; m; i++)&#123; matrix[i][-ln] = 0; &#125; &#125; &#125; if (rowFlag == 1)&#123; for (int j = 0; j &lt; n; j++)&#123; matrix[0][j] = 0; &#125; &#125; if (colFlag == 1)&#123; for (int i = 0; i &lt; m; i++)&#123; matrix[i][0] = 0; &#125; &#125; &#125; Complexity Analysis Time complexity : O(m * n). Space complexity : O(1). AcceptedRuntime: 2 ms, faster than 33.77% of Java online submissions for Set Matrix Zeroes. Memory Usage: 42.1 MB, less than 86.07% of Java online submissions for Set Matrix Zeroes. Method Two start with rowFlag,colFlag to indicate whether 0 exists in the first row, first column traverses the number groups, and sets the first place (matrix[I] [0], matrix[j] [0]) of the row and column in which 0 is located as 0 traverses the first row and first column, with 0’s column or row set to 0 set the first row, first column to 0 according to flag 中文： 首先用rowFlag,colFlag标志第一行第一列是否存在0 遍历数组，将0所在的行与列的首位(matrix[i] [0], matrix[j] [0])置为0 遍历第一行与第一列，0所在的列或行置为0 依据flag将第一行，第一列置为0 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void setZeroes(int[][] matrix) &#123; boolean rowFlag = false; //判断首行 for (int i = 0; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; rowFlag = true; break; &#125; &#125; boolean colFlag = false; for (int i = 0; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; colFlag = true; break; &#125; &#125; for (int i = 1; i &lt; matrix.length; i++) &#123; for (int j = 1; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for (int i = 1; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; matrix[j][i] = 0; &#125; &#125; &#125; for (int i = 1; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if (rowFlag)&#123; for (int i = 0; i &lt; matrix[0].length; i++) &#123; matrix[0][i] = 0; &#125; &#125; if (colFlag)&#123; for (int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125; Complexity Analysis Time complexity : O(m * n). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Sort Colors. Memory Usage: 34.9 MB, less than 80.40% of Java online submissions for Sort Colors. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"},{"name":"HashSet","slug":"HashSet","permalink":"https://www.vazh.cn/tags/HashSet/"}]},{"title":"Leetcode75-Sort Colors","slug":"Leetcode75-Sort-Colors","date":"2019-03-19T05:02:19.000Z","updated":"2019-09-04T04:29:37.279Z","comments":true,"path":"2019/03/19/Leetcode75-Sort-Colors/","link":"","permalink":"https://www.vazh.cn/2019/03/19/Leetcode75-Sort-Colors/","excerpt":"","text":"Description Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? Accepted 297,079 Submissions 716,181 AlgorithmMethod first move all the red to the front by scanning two subscripts from the front and from the back to the middle the second time you go from the maximum red index +1 to the maximum red index, just like in the first step, except you move the white to the end of the red blue is already in position 中文： 首先通过两个下标从前与从后向中间扫描，将所有的红色移到前面 第二次从红色下标最大值+1,到最大下标，与第一步一样，只是将白色移到红色后面 蓝色已经位置正确摆正 Code 1234567891011121314151617181920212223public void sortColors(int[] nums) &#123; int index = swap(nums, 0 , nums.length - 1, 0); swap(nums, index, nums.length - 1, 1); &#125; private int swap(int[] nums, int start, int end, int target)&#123; int temp; for (; start &lt; end;)&#123; if (nums[start] == target)&#123; start++; &#125;else&#123; if (nums[end] == target)&#123; temp = nums[end]; nums[end] = nums[start]; nums[start] = temp; start++; &#125;else&#123; end--; &#125; &#125; &#125; return start; &#125; Complexity Analysis Time complexity : O(n ). Space complexity : O(1). AcceptedRuntime: 0 ms, faster than 100.00% of Java online submissions for Sort Colors. Memory Usage: 34.9 MB, less than 80.40% of Java online submissions for Sort Colors. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode46-Permutations","slug":"Leetcode46-Permutations","date":"2019-03-18T05:37:01.000Z","updated":"2019-09-04T04:26:17.030Z","comments":true,"path":"2019/03/18/Leetcode46-Permutations/","link":"","permalink":"https://www.vazh.cn/2019/03/18/Leetcode46-Permutations/","excerpt":"","text":"Description Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]Accepted 347,568 Submissions 646,730 AlgorithmMethod Inspiration from the next arrangement First, every time you find the next permutation, you find the first pair of nums[I + 1] &lt; nums[I] from the right The Numbers after I are in descending order, so find the first number greater than nums[I] from the right to the left Swap nums[I],nums[j], and use swap The descending sequence after I was arranged in ascending order to ensure that the right side was the smallest. Reverse function was used to invert the array Recursive call add, add all the combination, when the number of lists added to the maximum permutation exit 中文： 根据下一个排列得到的灵感 首先每一次找到下一个排列，即每一次从右边找到第一对nums[i + 1] &lt; nums[i]的数 下标i之后的数是降序排列，所以从右边向左找到第一个大于nums[i]的数 交换nums[i],nums[j],利用swap函数 对i之后的降序序列进行升序排列，以保证右边是最小的，利用reverse函数逆置数组 递归调用add,添加所有的组合，当lists添加的数量达到排列最大值后退出 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums == null || nums.length == 0)&#123; return null; &#125; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++)&#123; list.add(nums[i]); &#125; int n = 1; for (int i = 1; i &lt;= nums.length; i++) &#123; n *= i; &#125; lists.add(list); add(nums, lists, n); return lists; &#125; private void add(int[] nums, List&lt;List&lt;Integer&gt;&gt; lists, int n)&#123; if (n == lists.size())&#123; return; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt; nums[i])&#123; i--; &#125; if (i &gt;= 0)&#123; int j = nums.length - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i])&#123; j--; &#125; swap(nums, i, j); &#125; reverse(nums, i + 1); for (int k = 0; k &lt; nums.length; k++)&#123; list.add(nums[k]); &#125; lists.add(list); add(nums, lists, n); &#125; private void swap(int[] nums, int i, int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; private void reverse(int[] nums, int start)&#123; int end = nums.length - 1; while (start &lt; end)&#123; swap(nums, start, end); start++; end--; &#125; &#125; Complexity Analysis Time complexity : O(n ^ 2). Space complexity : O(n). AcceptedRuntime: 2 ms, faster than 93.15% of Java online submissions for Permutations. Memory Usage: 39 MB, less than 29.07% of Java online submissions for Permutations. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"},{"name":"Permutation","slug":"Permutation","permalink":"https://www.vazh.cn/tags/Permutation/"}]},{"title":"Leetcode28-Implement strStr()","slug":"Leetcode28-Implement-strStr","date":"2019-03-16T02:18:37.000Z","updated":"2019-09-04T04:23:08.853Z","comments":true,"path":"2019/03/16/Leetcode28-Implement-strStr/","link":"","permalink":"https://www.vazh.cn/2019/03/16/Leetcode28-Implement-strStr/","excerpt":"","text":"Description Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = “hello”, needle = “ll” Output: 2 Example 2: Input: haystack = “aaaaa”, needle = “bba” Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Accepted 391,178 Submissions 1,247,053 AlgorithmMethod if needle is empty, return 0 For loop traversal, each time intercepting the length of the string string, compared with the needle, equal to return i No result at the end of the loop, return -1 Code123456789101112131415public int strStr(String haystack, String needle) &#123; if (needle.length() == 0)&#123; return 0; &#125; int m = haystack.length(); int n = needle.length(); String cmp; for (int i = 0; i &lt;= m - n; i++)&#123; cmp = haystack.substring(i, i + n); if (cmp.equals(needle))&#123; return i; &#125; &#125; return -1; &#125; Complexity Analysis Time complexity : O(m - n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 93.21% of Java online submissions for Implement strStr(). Memory Usage: 38.8 MB, less than 7.49% of Java online submissions for Implement strStr(). ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.vazh.cn/tags/String/"}]},{"title":"Leetcode35-Search Insert Position","slug":"Leetcode35-Search-Insert-Position","date":"2019-03-15T02:13:17.000Z","updated":"2019-09-04T04:24:58.318Z","comments":true,"path":"2019/03/15/Leetcode35-Search-Insert-Position/","link":"","permalink":"https://www.vazh.cn/2019/03/15/Leetcode35-Search-Insert-Position/","excerpt":"","text":"Description Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 Accepted 368,106 Submissions 908,904 AlgorithmMethod Use the dichotomy to find the target, if exists return subscript If the target is not found, it returns low because the loop ends with high == low - 1, and low happens to be the new position of the element insertion. Code1234567891011121314public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length - 1, mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (nums[mid] == target)&#123; return mid; &#125;else if (nums[mid] &gt; target)&#123; high = mid - 1; &#125;else &#123; low = mid + 1; &#125; &#125; return high + 1; &#125; Complexity Analysis Time complexity : O(log n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 2 ms, faster than 100.00% of Java online submissions for Search Insert Position. Memory Usage: 39.5 MB, less than 10.70% of Java online submissions for Search Insert Position. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://www.vazh.cn/tags/Binary-Search/"}]},{"title":"Leetcode34- Find First and Last Position of Element in Sorted Array","slug":"Leetcode34-Find-First-and-Last-Position-of-Element-in-Sorted-Array","date":"2019-03-15T02:12:50.000Z","updated":"2019-09-04T04:24:09.313Z","comments":true,"path":"2019/03/15/Leetcode34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/","link":"","permalink":"https://www.vazh.cn/2019/03/15/Leetcode34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/","excerpt":"","text":"Description Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Accepted 273,145 Submissions 826,276 Method Initialize the result array, return result if no target is found Use the dichotomy to find if the target is found,Find the left and right borders of the subscript mid and find the first and last index Return result Code12345678910111213141516171819202122public int[] searchRange(int[] nums, int target) &#123; int[] result = &#123;-1, -1&#125;; int low = 0, high = nums.length - 1, mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (nums[mid] == target)&#123; int tmp = mid; while (mid &gt; -1 &amp;&amp; nums[mid] == target)&#123; result[0] = mid--; &#125; while (tmp &lt; nums.length &amp;&amp; nums[tmp] == target)&#123; result[1] = tmp++; &#125; return result; &#125;else if (nums[mid] &gt; target)&#123; high = mid - 1; &#125;else &#123; low = mid + 1; &#125; &#125; return result; &#125; Complexity Analysis Time complexity : O(log n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 100.00% of Java online submissions for Find First and Last Position of Element in Sorted Array. Memory Usage: 42.8 MB, less than 5.19% of Java online submissions for Find First and Last Position of Element in Sorted Array. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://www.vazh.cn/tags/Binary-Search/"}]},{"title":"Leetcode41-First Missing Positive","slug":"Leetcode41-First-Missing-Positive","date":"2019-03-14T02:57:16.000Z","updated":"2019-09-04T04:25:15.270Z","comments":true,"path":"2019/03/14/Leetcode41-First-Missing-Positive/","link":"","permalink":"https://www.vazh.cn/2019/03/14/Leetcode41-First-Missing-Positive/","excerpt":"","text":"Description Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Accepted 194,768 Submissions 688,088 AlgorithmMethod The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue. Code1234567891011121314151617public int firstMissingPositive(int[] A) &#123; int i = 0; while(i &lt; A.length)&#123; if(A[i] == i+1 || A[i] &lt;= 0 || A[i] &gt; A.length) i++; else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1); else i++; &#125; i = 0; while(i &lt; A.length &amp;&amp; A[i] == i+1) i++; return i+1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). Constant space is used. AcceptedRuntime: 4 ms, faster than 100.00% of Java online submissions for First Missing Positive. Memory Usage: 37.2 MB, less than 49.02% of Java online submissions for First Missing Positive. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode31-Next Permutation","slug":"Leetcode31-Next-Permutation","date":"2019-03-14T02:56:54.000Z","updated":"2019-09-04T04:23:33.189Z","comments":true,"path":"2019/03/14/Leetcode31-Next-Permutation/","link":"","permalink":"https://www.vazh.cn/2019/03/14/Leetcode31-Next-Permutation/","excerpt":"","text":"Description Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Accepted 217,486 Submissions 722,873 AlgorithmMethod First, we observe that for any given sequence that is in descending order, no next larger permutation is possible. For example, no next permutation is possible for the following array: 1[9, 5, 4, 3, 1] We need to find the first pair of two successive numbers a[i]and a[i-1], from the right, which satisfy a[i] &gt; a[i-1]. Now, no rearrangements to the right of a[i-1]a[i−1] can create a larger permutation since that subarray consists of numbers in descending order. Thus, we need to rearrange the numbers to the right of a[i-1] including itself. Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number a[i-1] with the number which is just larger than itself among the numbers lying to its right section, say a[j]. We swap the numbers a[i-1]and a[j]. We now have the correct number at index i-1. But still the current permutation isn’t the permutation that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of a[i-1]. Therefore, we need to place those numbers in ascending order to get their smallest permutation. But, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair a[i] and a[i-1] where, a[i] &gt; a[i-1]. Thus, all numbers to the right of a[i-1] were already sorted in descending order. Furthermore, swapping a[i-1] and a[j] didn’t change that order. Therefore, we simply need to reverse the numbers following a[i-1] to get the next smallest lexicographic permutation. The following animation will make things clearer: Code1234567891011121314151617181920212223242526272829public void nextPermutation(int[] nums) &#123; int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) &#123; i--; &#125; if (i &gt;= 0) &#123; int j = nums.length - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) &#123; j--; &#125; swap(nums, i, j); &#125; reverse(nums, i + 1); &#125; private void reverse(int[] nums, int start) &#123; int i = start, j = nums.length - 1; while (i &lt; j) &#123; swap(nums, i, j); i++; j--; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; Complexity Analysis Time complexity : O(N). In worst case, only two scans of the whole array are needed. Space complexity : O(1). No extra space is used. In place replacements are done. AcceptedRuntime: 7 ms, faster than 96.65% of Java online submissions for Next Permutation. Memory Usage: 38.8 MB, less than 25.58% of Java online submissions for Next Permutation. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode143-Reorder List","slug":"Leetcode143-Reorder-List","date":"2019-03-13T02:19:28.000Z","updated":"2019-09-04T04:32:29.588Z","comments":true,"path":"2019/03/13/Leetcode143-Reorder-List/","link":"","permalink":"https://www.vazh.cn/2019/03/13/Leetcode143-Reorder-List/","excerpt":"","text":"Description Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. Accepted 144,363 Submissions 482,505 AlgorithmMethod Find the middle of the list Reverse the half after middle 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 Start reorder one by one 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4 Code1234567891011121314151617181920212223242526272829303132public void reorderList(ListNode head) &#123; if(head==null||head.next==null) return; //Find the middle of the list ListNode p1=head; ListNode p2=head; while(p2.next!=null&amp;&amp;p2.next.next!=null)&#123; p1=p1.next; p2=p2.next.next; &#125; //Reverse the half after middle 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 ListNode preMiddle=p1; ListNode preCurrent=p1.next; while(preCurrent.next!=null)&#123; ListNode current=preCurrent.next; preCurrent.next=current.next; current.next=preMiddle.next; preMiddle.next=current; &#125; //Start reorder one by one 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4 p1=head; p2=preMiddle.next; while(p1!=preMiddle)&#123; preMiddle.next=p2.next; p2.next=p1.next; p1.next=p2; p1=p2.next; p2=preMiddle.next; &#125; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(N). AcceptedRuntime: 2 ms, faster than 96.65% of Java online submissions for Reorder List. Memory Usage: 39.1 MB, less than 89.36% of Java online submissions for Reorder List. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"LinkList","slug":"LinkList","permalink":"https://www.vazh.cn/tags/LinkList/"}]},{"title":"Leetcode27-Remove Element","slug":"Leetcode27-Remove-Element","date":"2019-03-13T02:18:56.000Z","updated":"2019-09-04T02:57:47.228Z","comments":true,"path":"2019/03/13/Leetcode27-Remove-Element/","link":"","permalink":"https://www.vazh.cn/2019/03/13/Leetcode27-Remove-Element/","excerpt":"","text":"Description Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-placewith O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: 123456&gt; Given nums = [3,2,2,3], val = 3,&gt; &gt; Your function should return length = 2, with the first two elements of nums being 2.&gt; &gt; It doesn&apos;t matter what you leave beyond the returned length.&gt; Example 2: 12345678&gt; Given nums = [0,1,2,2,3,0,4,2], val = 2,&gt; &gt; Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.&gt; &gt; Note that the order of those five elements can be arbitrary.&gt; &gt; It doesn&apos;t matter what values are set beyond the returned length.&gt; Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 123456789&gt; // nums is passed in by reference. (i.e., without making a copy)&gt; int len = removeElement(nums, val);&gt; &gt; // any modification to nums in your function would be known by the caller.&gt; // using the length returned by your function, it prints the first len elements.&gt; for (int i = 0; i &lt; len; i++) &#123;&gt; print(nums[i]);&gt; &#125;&gt; Accepted 377,642 Submissions 864,048 AlgorithmMethod Count the number of values equal to val using count The for loop evaluates each number, nums[i - count] = nums[i] , overwriting the previous data Return result Code1234567891011public int removeElement(int[] nums, int val) &#123; int count = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] == val)&#123; count++; &#125;else&#123; nums[i - count] = nums[i]; &#125; &#125; return nums.length - count; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 100.00% of Java online submissions for Remove Element. Memory Usage: 37.8MB, less than 45.50% of Java online submissions for Remove Element. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode33-Search in Rotated Sorted Array","slug":"Leetcode33-Search-in-Rotated-Sorted-Array","date":"2019-03-12T05:53:26.000Z","updated":"2019-09-04T04:23:43.221Z","comments":true,"path":"2019/03/12/Leetcode33-Search-in-Rotated-Sorted-Array/","link":"","permalink":"https://www.vazh.cn/2019/03/12/Leetcode33-Search-in-Rotated-Sorted-Array/","excerpt":"","text":"Description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 123&gt; Input: nums = [4,5,6,7,0,1,2], target = 0&gt; Output: 4&gt; Example 2: 123&gt; Input: nums = [4,5,6,7,0,1,2], target = 3&gt; Output: -1&gt; Accepted 375,746 Submissions 1,150,061 AlgorithmMethod if array is null or empty, return -1. Discuss each situation, a total of four return result Code1234567891011121314151617181920212223242526public int search(int[] A, int target) &#123; if (A == null || A.length == 0)&#123; return -1; &#125; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1; &#125; Complexity Analysis Time complexity : O(log n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 5 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array. Memory Usage: 38.9 MB, less than 75.73% of Java online submissions for Search in Rotated Sorted Array. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"https://www.vazh.cn/tags/Binary-Search/"}]},{"title":"Leetcode13-Roman to Integer","slug":"Leetcode13-Roman-to-Integer","date":"2019-03-11T02:14:06.000Z","updated":"2019-09-04T02:53:57.603Z","comments":true,"path":"2019/03/11/Leetcode13-Roman-to-Integer/","link":"","permalink":"https://www.vazh.cn/2019/03/11/Leetcode13-Roman-to-Integer/","excerpt":"","text":"Description Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 123456789&gt; Symbol Value&gt; I 1&gt; V 5&gt; X 10&gt; L 50&gt; C 100&gt; D 500&gt; M 1000&gt; For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 123&gt; Input: &quot;III&quot;&gt; Output: 3&gt; Example 2: 123&gt; Input: &quot;IV&quot;&gt; Output: 4&gt; Example 3: 123&gt; Input: &quot;IX&quot;&gt; Output: 9&gt; Example 4: 1234&gt; Input: &quot;LVIII&quot;&gt; Output: 58&gt; Explanation: L = 50, V= 5, III = 3.&gt; Example 5: 1234&gt; Input: &quot;MCMXCIV&quot;&gt; Output: 1994&gt; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.&gt; Accepted 371,873 Submissions 719,864 AlgorithmMethod count every Symbol and add its value to the sum, and minus the extra part of special cases. Traverse each character, plus the corresponding value Return result Code12345678910111213141516171819202122public int romanToInt(String s) &#123; int sum=0; if(s.indexOf(\"IV\")!=-1)&#123;sum-=2;&#125; if(s.indexOf(\"IX\")!=-1)&#123;sum-=2;&#125; if(s.indexOf(\"XL\")!=-1)&#123;sum-=20;&#125; if(s.indexOf(\"XC\")!=-1)&#123;sum-=20;&#125; if(s.indexOf(\"CD\")!=-1)&#123;sum-=200;&#125; if(s.indexOf(\"CM\")!=-1)&#123;sum-=200;&#125; char c[]=s.toCharArray(); for( int count=0;count&lt;=s.length()-1;count++)&#123; if(c[count]=='M') sum+=1000; if(c[count]=='D') sum+=500; if(c[count]=='C') sum+=100; if(c[count]=='L') sum+=50; if(c[count]=='X') sum+=10; if(c[count]=='V') sum+=5; if(c[count]=='I') sum+=1; &#125; return sum; &#125; Complexity Analysis Time complexity : O(N). Space complexity : O(1). Constant space is used. AcceptedRuntime: 37 ms, faster than 82.95% of Java online submissions for Roman to Integer. Memory Usage: 38.9 MB, less than 26.08% of Java online submissions for Roman to Integer. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.vazh.cn/tags/String/"}]},{"title":"Leetcode12-Integer to Roman","slug":"Leetcode12-Integer-to-Roman","date":"2019-03-11T01:04:27.000Z","updated":"2019-09-04T02:53:40.994Z","comments":true,"path":"2019/03/11/Leetcode12-Integer-to-Roman/","link":"","permalink":"https://www.vazh.cn/2019/03/11/Leetcode12-Integer-to-Roman/","excerpt":"","text":"Description Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 123456789&gt; Symbol Value&gt; I 1&gt; V 5&gt; X 10&gt; L 50&gt; C 100&gt; D 500&gt; M 1000&gt; For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: 123&gt; Input: 3&gt; Output: &quot;III&quot;&gt; Example 2: 123&gt; Input: 4&gt; Output: &quot;IV&quot;&gt; Example 3: 123&gt; Input: 9&gt; Output: &quot;IX&quot;&gt; Example 4: 1234&gt; Input: 58&gt; Output: &quot;LVIII&quot;&gt; Explanation: L = 50, V = 5, III = 3.&gt; Example 5: 1234&gt; Input: 1994&gt; Output: &quot;MCMXCIV&quot;&gt; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.&gt; Accepted 206,922 Submissions 414,880 AlgorithmMethod Use arrays to store every possible Roman numeral Take out each digit of num by calculation Corresponding to array subscript Return result Code1234567public String intToRoman(int num) &#123; String M[] = &#123;\"\", \"M\", \"MM\", \"MMM\"&#125;; String C[] = &#123;\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"&#125;; String X[] = &#123;\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"&#125;; String I[] = &#123;\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125; Complexity Analysis Time complexity : O(1). Space complexity : O(1). Constant space is used. AcceptedRuntime: 40 ms, faster than 47.96% of Java online submissions for Integer to Roman. Memory Usage: 39.8 MB, less than 29.12% of Java online submissions for Integer to Roman. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.vazh.cn/tags/String/"}]},{"title":"Leetcode29-Divide Two Integers","slug":"Leetcode29-Divide-Two-Integers","date":"2019-03-10T02:26:24.000Z","updated":"2019-09-04T04:23:19.773Z","comments":true,"path":"2019/03/10/Leetcode29-Divide-Two-Integers/","link":"","permalink":"https://www.vazh.cn/2019/03/10/Leetcode29-Divide-Two-Integers/","excerpt":"","text":"Description Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows. Accepted 181,967 Submissions 1,130,117 AlgorithmMethod Use long to avoid integer overflow cases. check the edge cases. sum = divisor, sum += sum , which equals sum = sum * 2, use multiple count result. Look for additional value for the multiple from the reminder (dividend - sum) recursively. Code123456789101112131415161718192021222324252627282930313233343536373839public int divide(int dividend, int divisor) &#123; //Reduce the problem to positive long integer to make it easier. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE)&#123; //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; else &#123; ans = (int) (sign * lans); &#125; return ans; &#125; private long ldivide(long ldividend, long ldivisor) &#123; // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) &#123; sum += sum; multiple += multiple; &#125; //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor); &#125; Complexity Analysis Time complexity : O(n). Single pass. Space complexity : O(1). Constant space is used. AcceptedRuntime: 13 ms, faster than 100.00% of Java online submissions for Divide Two Integers. Memory Usage: 38.1 MB, less than 60.82% of Java online submissions for Divide Two Integers. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetc","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"https://www.vazh.cn/tags/Binary-Search/"}]},{"title":"Leetcode69-Sqrt(x)","slug":"Leetcode69-Sqrt-x","date":"2019-03-10T01:35:49.000Z","updated":"2019-09-04T04:29:05.455Z","comments":true,"path":"2019/03/10/Leetcode69-Sqrt-x/","link":"","permalink":"https://www.vazh.cn/2019/03/10/Leetcode69-Sqrt-x/","excerpt":"","text":"Description Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned. Accepted 334,122 Submissions 1,086,877 AlgorithmMethod when x equals 0 or 1, return x use method of binary search ,from 0(low) to x(high) divide into three situations , calculate separately return res Code12345678910111213141516171819public int mySqrt(int x) &#123; if (x == 0 || x == 1)&#123; return x; &#125; return serach_sqrt(x, 0, x); &#125; private int serach_sqrt(int x, long low, long high) &#123; int res; long mid = (low + high) / 2; if (mid * mid &gt; x)&#123; res = serach_sqrt(x, low, mid); &#125;else if ((mid + 1)*(mid + 1) &gt; x)&#123; res = (int) mid; &#125;else &#123; res = serach_sqrt(x, mid + 1, high); &#125; return res; &#125; Complexity Analysis Time complexity : O(log2 x). Space complexity : O(log2 x). AcceptedRuntime: 14 ms, faster than 94.61% of Java online submissions for Sqrt(x).Memory Usage: 37.7 MB, less than 99.33% of Java online submissions for Sqrt(x). ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"https://www.vazh.cn/tags/Binary-Search/"}]},{"title":"Leetcode15-3Sum","slug":"Leetcode15-3Sum","date":"2019-03-09T05:49:25.000Z","updated":"2019-09-04T02:54:45.252Z","comments":true,"path":"2019/03/09/Leetcode15-3Sum/","link":"","permalink":"https://www.vazh.cn/2019/03/09/Leetcode15-3Sum/","excerpt":"","text":"Description Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Accepted 491,308 Submissions 2,092,104 AlgorithmMethod One The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. Code12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; // skip repeat answer int l = i + 1, r = nums.length - 1, sum = 0 - nums[i]; while (l &lt; r) &#123; if (nums[l] + nums[r] == sum) &#123; ls.add(Arrays.asList(nums[i], nums[l], nums[r])); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; &#125; else if (nums[l] + nums[r] &lt; sum) &#123; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; //skip repeat answer l++; &#125; else &#123; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; r--; &#125; &#125; &#125; &#125; return ls; &#125; Complexity Analysis Time complexity : O(n ^ 2). Double loop o(n ^ 2). Space complexity : O(n). Linear space is used. AcceptedRuntime: 44 ms, faster than 77.23% of Java online submissions for 3Sum.Memory Usage: 45 MB, less than 99.04% of Java online submissions for 3Sum. Method Two Waiting for the follow-up ….. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 100% beats * @param nums * @return */ public List&lt;List&lt;Integer&gt;&gt; threeSum_PLUS(int[] nums) &#123; if (nums.length &lt; 3) return Collections.emptyList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int minValue = Integer.MAX_VALUE; int maxValue = Integer.MIN_VALUE; int negSize = 0; int posSize = 0; int zeroSize = 0; for (int v : nums) &#123; if (v &lt; minValue) minValue = v; if (v &gt; maxValue) maxValue = v; if (v &gt; 0) posSize++; else if (v &lt; 0) negSize++; else zeroSize++; &#125; if (zeroSize &gt;= 3) res.add(Arrays.asList(0, 0, 0)); if (negSize == 0 || posSize == 0) return res; if (minValue * 2 + maxValue &gt; 0) maxValue = -minValue * 2; else if (maxValue * 2 + minValue &lt; 0) minValue = -maxValue * 2; int[] map = new int[maxValue - minValue + 1]; int[] negs = new int[negSize]; int[] poses = new int[posSize]; negSize = 0; posSize = 0; for (int v : nums) &#123; if (v &gt;= minValue &amp;&amp; v &lt;= maxValue) &#123; if (map[v - minValue]++ == 0) &#123; if (v &gt; 0) poses[posSize++] = v; else if (v &lt; 0) negs[negSize++] = v; &#125; &#125; &#125; Arrays.sort(poses, 0, posSize); Arrays.sort(negs, 0, negSize); int basej = 0; for (int i = negSize - 1; i &gt;= 0; i--) &#123; int nv = negs[i]; int minp = (-nv) &gt;&gt;&gt; 1; while (basej &lt; posSize &amp;&amp; poses[basej] &lt; minp) basej++; for (int j = basej; j &lt; posSize; j++) &#123; int pv = poses[j]; int cv = 0 - nv - pv; if (cv &gt;= nv &amp;&amp; cv &lt;= pv) &#123; if (cv == nv) &#123; if (map[nv - minValue] &gt; 1) res.add(Arrays.asList(nv, nv, pv)); &#125; else if (cv == pv) &#123; if (map[pv - minValue] &gt; 1) res.add(Arrays.asList(nv, pv, pv)); &#125; else &#123; if (map[cv - minValue] &gt; 0) res.add(Arrays.asList(nv, cv, pv)); &#125; &#125; else if (cv &lt; nv) break; &#125; &#125; return res; &#125; Complexity Analysis Time complexity : Waiting for the follow-up ….. Space complexity : Waiting for the follow-up ….. AcceptedRuntime: 18 ms, faster than 100.00% of Java online submissions for 3Sum.Memory Usage: 50.2 MB, less than 30.36% of Java online submissions for 3Sum. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode11-Container with Most Water","slug":"Leetcode11-Container-with-Most-Water","date":"2019-03-09T04:34:15.000Z","updated":"2019-09-04T02:53:29.254Z","comments":true,"path":"2019/03/09/Leetcode11-Container-with-Most-Water/","link":"","permalink":"https://www.vazh.cn/2019/03/09/Leetcode11-Container-with-Most-Water/","excerpt":"","text":"Description Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 Accepted 324,381 Submissions 758,024 AlgorithmMethod ​ Initially we consider the area constituting the exterior most lines. Now, to maximize the area, we need to consider the area between the lines of larger lengths. If we try to move the pointer at the longer line inwards, we won’t gain any increase in area, since it is limited by the shorter line. ​ But moving the shorter line’s pointer could turn out to be beneficial, as per the same argument, despite the reduction in the width. This is done since a relatively longer line obtained by moving the shorter line’s pointer might overcome the reduction in area caused by the width reduction. Code12345678910111213141516171819202122/** * 利用双指针 分别进行左右遍历 * @param height * @return */ public int maxArea(int[] height) &#123; int len = height.length - 1; // calculate all length area int res = 0; int left = 0; int right = height.length - 1; while (left &lt; right)&#123; if (height[left] &lt; height[right])&#123; res = Math.max(res, height[left] * (right - left)); left++; &#125;else &#123; res = Math.max(res, height[right] * (right - left)); right--; &#125; &#125; return res; &#125; Complexity Analysis Time complexity : O(n). Single pass. Space complexity : O(1). Constant space is used. AcceptedRuntime: 3 ms, faster than 100.00% of Java online submissions for Container With Most Water.Memory Usage: 40.1 MB, less than 75.26% of Java online submissions for Container With Most Water. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode09-Palindrome Number","slug":"Leetcode09-Palindrome-Number","date":"2019-03-08T05:16:25.000Z","updated":"2019-09-04T02:53:13.934Z","comments":true,"path":"2019/03/08/Leetcode09-Palindrome-Number/","link":"","permalink":"https://www.vazh.cn/2019/03/08/Leetcode09-Palindrome-Number/","excerpt":"","text":"Description Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? Accepted 519,905 Submissions 1,234,941 AlgorithmMethod One Use a ArrayList store every number from (x % 10) Iterate through the list, returning false if not equal If no value is returned at the end of the traversal, flase is returned Code12345678910111213141516public boolean isPalindrome(int x) &#123; if (x &lt; 0)&#123; return false; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (x != 0)&#123; list.add(x % 10); x /= 10; &#125; for (int i = 0; i &lt; list.size() / 2; i++) &#123; if (list.get(i) != list.get(list.size() - 1 - i))&#123; return false; &#125; &#125; return true; &#125; Complexity Analysis Time complexity : O(lg10 n). We divided the input by 10 for every iteration, so the time complexity is O(lg10 n) Space complexity : O(1). Constant space is used. AcceptedRuntime: 74 ms, faster than 90.58% of Java online submissions for Palindrome Number.Memory Usage: 39.2 MB, less than 97.72% of Java online submissions for Palindrome Number. Method Two First of all we should take care of some edge cases. All negative numbers are not palindrome, for example: -123 is not a palindrome since the ‘-‘ does not equal to ‘3’. So we can return false for all negative numbers. Now let’s think about how to revert the last half of the number. For number 1221, if we do 1221 % 10, we get the last digit 1, to get the second to the last digit, we need to remove the last digit from 1221, we could do so by dividing it by 10, 1221 / 10 = 122. Then we can get the last digit again by doing a modulus by 10, 122 % 10 = 2, and if we multiply the last digit by 10 and add the second last digit, 1 * 10 + 2 = 12, it gives us the reverted number we want. Continuing this process would give us the reverted number with more digits. Now the question is, how do we know that we’ve reached the half of the number? Since we divided the number by 10, and multiplied the reversed number by 10, when the original number is less than the reversed number, it means we’ve processed half of the number digits. Code123456789101112public boolean isPalindrome(int x) &#123; if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; //reverse half digits int rev = 0; while (x &gt; rev) &#123; rev = rev * 10 + x % 10; x /= 10; &#125; return (x == rev) || (x == rev / 10); &#125; Complexity Analysis Time complexity : O(lg10 n). We divided the input by 10 for every iteration, so the time complexity is O(lg10 n) Space complexity : O(1). Constant space is used. AcceptedRuntime: 71 ms, faster than 99.08% of Java online submissions for Palindrome Number.Memory Usage: 39.1 MB, less than 98.69% of Java online submissions for Palindrome Number. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"}]},{"title":"Leetcode07-Reverse Integer","slug":"Leetcode07-Reverse-Integer","date":"2019-03-06T06:16:53.000Z","updated":"2019-09-04T02:52:45.321Z","comments":true,"path":"2019/03/06/Leetcode07-Reverse-Integer/","link":"","permalink":"https://www.vazh.cn/2019/03/06/Leetcode07-Reverse-Integer/","excerpt":"","text":"Description Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321 Example 2: Input: -123Output: -321 Example 3: Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Accepted 621,383 Submissions 2,469,308 AlgorithmMethod One Get each digit of x, res records the value of x inversion Overflow if res is greater than the first n-1 digit of x Overflow if res is equal to the first n-1 digit of x and the last digit is greater than the ones of the most significant digit Return result res Code12345678910111213141516171819public int reverse(int x) &#123; int max = Integer.MAX_VALUE / 10; int min = Integer.MIN_VALUE / 10; int maxPop = Integer.MAX_VALUE % 10; int minPop = Integer.MIN_VALUE % 10; int res = 0; while (x != 0)&#123; int pop = x % 10; x = x / 10; if (res &gt; max || (res == max &amp;&amp; pop &gt; maxPop))&#123; return 0; &#125; if (res &lt; min || (res == min &amp;&amp; pop &lt; minPop))&#123; return 0; &#125; res = res * 10 + pop; &#125; return res; &#125; Complexity Analysis Time complexity : O(log10 n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 13 ms, faster than 99.99% of Java online submissions for Reverse Integer.Memory Usage: 37.9 MB, less than 71.08% of Java online submissions for Reverse Integer. Method Two Get each digit of x, res records the value of x inversion Receive the reverse value of x with long type temp to prevent overflow Return result res Code12345678910111213public int reverse_2(int x) &#123; int res = 0; while (x != 0)&#123; int pop = x % 10; x = x / 10; long temp = pop + res * 10; if (temp &gt; Integer.MAX_VALUE || temp &lt; Integer.MIN_VALUE)&#123; return 0; &#125; res = (int)temp; &#125; return res; &#125; Complexity Analysis Time complexity : O(log10 n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 13 ms, faster than 99.99% of Java online submissions for Reverse Integer.Memory Usage: 37.7 MB, less than 99.67% of Java online submissions for Reverse Integer. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"math","slug":"math","permalink":"https://www.vazh.cn/tags/math/"}]},{"title":"Leetcode04-Median of Two Sorted Arrays","slug":"Leetcode04-Median-of-Two-Sorted-Arrays","date":"2019-03-05T06:43:24.000Z","updated":"2019-09-04T02:40:10.896Z","comments":true,"path":"2019/03/05/Leetcode04-Median-of-Two-Sorted-Arrays/","link":"","permalink":"https://www.vazh.cn/2019/03/05/Leetcode04-Median-of-Two-Sorted-Arrays/","excerpt":"","text":"Description Given a 32-bit signed integer, reverse digits of an integer. Example 1: There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Accepted 389,847 Submissions 1,521,885 AlgorithmMethod A new auxiliary array res is used to store the merged results Nums1 and nums2 are traversed, and the comparison sizes are stored in res respectively Assign the remainder of a longer array to res Return result res Code123456789101112131415161718192021222324252627282930/** * 分治法节选部分思想 * @param nums1 * @param nums2 * @return */ public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] res = new int[nums1.length + nums2.length]; double result; int i = 0, j = 0, k = 0; while (i &lt;= nums1.length - 1 &amp;&amp; j &lt;= nums2.length - 1)&#123; if (nums1[i] &lt; nums2[j])&#123; res[k++] = nums1[i++]; &#125;else &#123; res[k++] = nums2[j++]; &#125; &#125; while (i &lt;= nums1.length - 1)&#123; res[k++] = nums1[i++]; &#125; while (j &lt;= nums2.length - 1)&#123; res[k++] = nums2[j++]; &#125; if (res.length % 2 == 0)&#123; result = (res[res.length / 2] + res[res.length / 2 - 1]) / 2.0; &#125;else &#123; result = res[res.length / 2]; &#125; return result; &#125; Complexity Analysis Time complexity : O(m + n). Space complexity : O(1). Constant space is used. AcceptedRuntime: 24 ms, faster than 94.04% of Java online submissions for Median of Two Sorted Arrays.Memory Usage: 48.7 MB, less than 68.87% of Java online submissions for Median of Two Sorted Arrays. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://www.vazh.cn/tags/Divide-and-Conquer/"}]},{"title":"Leetcode95-不同的二叉搜索树2","slug":"Leetcode95-不同的二叉搜索树2","date":"2019-03-05T03:18:28.000Z","updated":"2019-03-05T03:18:28.000Z","comments":true,"path":"2019/03/05/Leetcode95-不同的二叉搜索树2/","link":"","permalink":"https://www.vazh.cn/2019/03/05/Leetcode95-不同的二叉搜索树2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Leetcode94-二叉树的中序遍历","slug":"Leetcode94-二叉树的中序遍历","date":"2019-03-04T09:06:21.000Z","updated":"2019-09-04T04:31:40.548Z","comments":true,"path":"2019/03/04/Leetcode94-二叉树的中序遍历/","link":"","permalink":"https://www.vazh.cn/2019/03/04/Leetcode94-二叉树的中序遍历/","excerpt":"","text":"问题描述 给定一个二叉树，返回它的中序 遍历。 示例: 123456789&gt; 输入: [1,null,2,3]&gt; 1&gt; \\&gt; 2&gt; /&gt; 3&gt; &gt; 输出: [1,3,2]&gt; 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 算法思想方法一:迭代法 定义一个Integer类型list集合，存放所有的遍历值. 定义一个TreeNode类型 栈stack 存放遍历的TreeNode节点 因为是中序遍历，所以若左子树不为空且set不包含左子树（检验是否已经出栈，防止重复出栈）, cur = stack.peek().left, 赋值为左子树，并且压栈然后添加到set, 否则左子树为null , 右子树部位空，则将根节点值添加到list, 再将cur.right压栈. 若左右子树都为空，则将节点弹栈，将根节点也就是叶子节点的值添加到list. 返回list. 代码实现方法一代码1234567891011121314151617181920212223242526272829303132/** * 迭代循环 栈遍历 效率相对较低 * @param root * @return */ public List&lt;Integer&gt; inorderTraversal2(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); TreeNode cur = null; HashSet&lt;TreeNode&gt; set = new HashSet&lt;&gt;(); while(!stack.isEmpty()) &#123; if(stack.peek().left != null &amp;&amp; !set.contains(stack.peek().left)) &#123; cur = stack.peek().left; stack.push(cur); set.add(cur); &#125;else if(stack.peek().right != null) &#123; cur = stack.pop(); list.add(cur.val); stack.push(cur.right); &#125;else &#123; cur = stack.pop(); list.add(cur.val); &#125; &#125; return list; &#125; 复杂度分析时间复杂度：该算法对含有L个节点的二叉树root 进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 24% Solutionjava执行用时: 2msjava内存消耗: 37.6MB 算法思想方法二:递归法 定义一个Integer类型list集合，存放所有的遍历值. 递归调用左子树，添加根节点，递归调用右子树 返回list集合 代码实现方法二代码12345678910111213141516171819/** * 递归调用 * @param root * @return */ public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return list; &#125; if (root.left != null) &#123; list.addAll(inorderTraversal(root.left)); &#125; list.add(root.val); if (root.right != null) &#123; list.addAll(inorderTraversal(root.right)); &#125; return list; &#125; 复杂度分析时间复杂度：假设左孩子有R个, 有孩子有L个 ,该算法对二叉树进行了递归调用,所以算法时间复杂度为O(R + L) 空间复杂度：该算法对二叉树进行了递归调用，故空间复杂度为O(R + L) leetcode 85% Solutionjava执行用时: 1msjava内存消耗: 34MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://www.vazh.cn/tags/tree/"}]},{"title":"Leetcode26-Remove Duplicates from Sorted Array","slug":"Leetcode26-Remove-Duplicates-from-Sorted-Array","date":"2019-03-04T07:05:56.000Z","updated":"2019-09-04T02:57:19.296Z","comments":true,"path":"2019/03/04/Leetcode26-Remove-Duplicates-from-Sorted-Array/","link":"","permalink":"https://www.vazh.cn/2019/03/04/Leetcode26-Remove-Duplicates-from-Sorted-Array/","excerpt":"","text":"Description Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in- place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i &lt; len; i++) { print(nums[i]); } Accepted 532,869 Submissions 1,341,074 AlgorithmMethod One Define times to count the number of occurrences of repeating elements For each new number that is encountered, result adds 1. TMP records the new number and overwrites the current new number to the previous one If it’s a duplicate number, times plus one Returns the result Code12345678910111213141516171819202122232425/** * 覆盖 times统计重复元素数 5ms * @param nums * @return */ public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0)&#123; return 0; &#125; int times = 0; int result = 1; // save the last number int tmp = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == tmp)&#123; times++; &#125;else &#123; result++; tmp = nums[i]; nums[i - times] = nums[i]; &#125; &#125; return result; &#125; Complexity Analysis Time complexity : O(n). Simple class. Space complexity : O(1). AcceptedRuntime: 5 ms, faster than 99.90% of Java online submissions for Remove Duplicates from Sorted Array.Memory Usage: 42 MB, less than 40.27% of Java online submissions for Remove Duplicates from Sorted Array. Method Two Since the array is already sorted, we can keep two pointers i and j, where i is the slow-runner while j is the fast-runner. As long as nums[i] = nums[j], we increment j to skip the duplicate. When we encounter nums[j] !=nums[i], the duplicate run has ended so we must copy its value to nums[i + 1], then incremented and we repeat the same process again until j reaches the end of array. Code1234567891011 public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; Complexity Analysis Time complexity : O(n). Assume that n is the length of array. Each of ii and j traverses at most n steps. Space complexity : O(1). AcceptedRuntime: 5 ms, faster than 99.90% of Java online submissions for Remove Duplicates from Sorted Array.Memory Usage: 41.5 MB, less than 56.02% of Java online submissions for Remove Duplicates from Sorted Array. ConclusionI am a new comer here. Please give me more advice. If you have a better solution, please feel free to discuss in the comment section. I also hope that you can learn it together with leetcode friends plus V: ZKLOVE9527. (WeChat add friends, please note leetcode).","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.vazh.cn/tags/Array/"},{"name":"Two Points","slug":"Two-Points","permalink":"https://www.vazh.cn/tags/Two-Points/"}]},{"title":"Leetcode92-反转链表2","slug":"Leetcode92-反转链表2","date":"2019-02-26T11:40:02.000Z","updated":"2019-09-04T04:31:23.268Z","comments":true,"path":"2019/02/26/Leetcode92-反转链表2/","link":"","permalink":"https://www.vazh.cn/2019/02/26/Leetcode92-反转链表2/","excerpt":"","text":"问题描述 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 算法思想 先对head进行判断，如果head或head.next为null,或者m等于n,直接返回null. 通过递归将节点指针移动到第m个节点，然后将m~n的节点逆置，通过头插法将节点逆置，然后将逆置后的最后一个节点即head,与第m个节点后的链表连接起来，再将head指向prev,即逆置后的头结点. 返回得到最终结果头结点head。 代码实现123456789101112131415161718192021222324252627282930313233/** * 由反转链表得到灵感，将固定的一段链表，m到n的节点进行反转 * @param head * @param m * @param n * @return */ public ListNode reverseBetween(ListNode head, int m, int n) &#123; if (head == null || head.next == null || m == n)&#123; return head; &#125; ListNode curr = head; ListNode prev = null; ListNode next = null; int k = n - m + 1; if (m == 1) &#123; while (k-- != 0 &amp;&amp; curr != null)&#123; if (curr.next == null)&#123; next = null; &#125;else &#123; next = curr.next; &#125; curr.next = prev; prev = curr; curr = next; &#125; head.next = curr; head = prev; &#125; else &#123; head.next = reverseBetween(head.next, m - 1, n - 1); &#125; return head; &#125; 复杂度分析时间复杂度：该算法对前 n 个结点进行了一次遍历。因此时间复杂度为 O(m) 空间复杂度：因为递归调用了m次，故空间复杂度为O(m) leetcode 100% Solutionjava执行用时: 2msjava内存消耗: 36.7MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode86-分割链表","slug":"Leetcode86-分割链表","date":"2019-02-26T11:39:17.000Z","updated":"2019-09-04T04:31:12.008Z","comments":true,"path":"2019/02/26/Leetcode86-分割链表/","link":"","permalink":"https://www.vazh.cn/2019/02/26/Leetcode86-分割链表/","excerpt":"","text":"问题描述 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 算法思想 先声明两个链表dummyHead1，dummyHead2，分别保存小于和大于x的节点。 再声明两个链表node1,node2,用来保存每一次遍历的节点。 最后连接两个链表，node1.next = dummyHead2.next . 返回dummyHead1.next 。 代码实现123456789101112131415161718192021public ListNode partition(ListNode head, int x) &#123; ListNode dummyHead1 = new ListNode(0); ListNode dummyHead2 = new ListNode(0); ListNode node1 = dummyHead1; ListNode node2 = dummyHead2; while (head != null) &#123; if (head.val &lt; x) &#123; node1.next = head; head = head.next; node1 = node1.next; node1.next = null; &#125; else &#123; node2.next = head; head = head.next; node2 = node2.next; node2.next = null; &#125; &#125; node1.next = dummyHead2.next; return dummyHead1.next; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 84% Solutionjava执行用时: 1msjava内存消耗: 20.5MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode23-合并k个排序链表","slug":"Leetcode23-合并k个排序链表","date":"2019-02-24T02:47:30.000Z","updated":"2019-09-04T02:56:46.207Z","comments":true,"path":"2019/02/24/Leetcode23-合并k个排序链表/","link":"","permalink":"https://www.vazh.cn/2019/02/24/Leetcode23-合并k个排序链表/","excerpt":"","text":"问题描述 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] 输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 算法思想方法一 定义一个头结点head, 还有一个point节点用来保存每一次遍历的头结点. 通过mergeKList函数将每两个链表合并排序 point.next = mergeKList(point.next, node), for循环遍历每一条lists里面的链表 返回head.next,去除第一个声明的 “0” 节点 代码实现方法一代码1234567891011121314151617181920212223242526/** * 效率低 260ms 55MB * 解题思想： * 从题目合并两个排序链表中得到灵感 两两合并最终得到结果 * @param lists * @return */public ListNode mergeKLists(ListNode[] lists) &#123; ListNode head = new ListNode(0); ListNode point = head; for (ListNode node : lists)&#123; point.next = mergeKList(point.next, node); &#125; return head.next; &#125;public ListNode mergeKList(ListNode l1, ListNode l2)&#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val)&#123; l1.next = mergeKList(l1.next , l2); return l1; &#125;else &#123; l2.next = mergeKList(l1, l2.next); return l2; &#125; &#125; 复杂度分析时间复杂度：该算法对含有k条链表一共 L 个结点的lists进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 31% Solutionjava执行用时: 234msjava内存消耗: 56MB 算法思想方法二 定义一个Integer类型list集合，存放所有的链表值. 利用自带的工具类Collections的sort方法，对list集合数据排序。 再构建一个新的链表result,将数据依次付给链表节点。 返回point.next,去除第一个声明的 “0” 节点 代码实现方法二代码12345678910111213141516171819202122/** * 解题思路： 将所有点的值放入一个数组中，然后对数组进行排序，再构建一个新的链表，将其返回 * @param lists * @return */ public ListNode mergeKLists(ListNode[] lists) &#123; ListNode result = new ListNode(0); ListNode point = result; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (ListNode node : lists)&#123; while (node != null)&#123; list.add(node.val); node = node.next; &#125; &#125; Collections.sort(list); for (int x : list)&#123; point.next = new ListNode(x); point = point.next; &#125; return result.next; &#125; 复杂度分析时间复杂度：假设链表数组的长度为n,该算法对含有 n 个结点的lists进行了一次遍历,时间复杂度为 O(n),Collections.sort采用TimSort算法，时间复杂度O(nlogn),所以算法时间复杂度为O(nlogn) 空间复杂度：TimSort算法空间复杂度O(n)，故空间复杂度为O(n) leetcode 72% Solutionjava执行用时: 17msjava内存消耗: 38.9MB 算法思想方法三 定义一个MSort函数对链表排序. 通过mergeTwoLists函数将每两个链表合并排序 返回结果 代码实现方法三代码123456789101112131415161718192021222324252627282930313233343536/** * 类似于快排算法，以链表以中心位置为分界，将链表数组分成两个链表数组，快速进行两两排序 * 利用两两排序函数进行排序 * @param lists * @return */ public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0)&#123; return null; &#125; return MSort(lists, 0, lists.length - 1); &#125; private ListNode MSort(ListNode[] lists, int low, int high) &#123; if (low &lt; high)&#123; int mid = (low + high) / 2; ListNode leftlist = MSort(lists, low, mid); ListNode rightlist = MSort(lists, mid + 1, high); return mergeTwoLists(leftlist, rightlist); &#125; return lists[low]; &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode res = null; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val)&#123; res = l1; l1.next = mergeTwoLists(l1.next , l2); &#125;else &#123; res = l2; l2.next = mergeTwoLists(l1, l2.next); &#125; return res; &#125; 复杂度分析时间复杂度：假设链表数组的长度为n,该算法对含有 n 个结点的lists快排比较,时间复杂度为 O(logn), mergeTwoLists时间复杂度O(L),所以算法时间复杂度为O(Llogn) 空间复杂度：mid申请了logn次，res申请了L次，故空间复杂度为O(max(L, logn)) leetcode 99.75% Solutionjava执行用时: 8msjava内存消耗: 38.6MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode82-删除排序链表中的重读元素2","slug":"Leetcode82-删除排序链表中的重读元素2","date":"2019-02-20T03:47:30.000Z","updated":"2019-09-04T04:29:51.211Z","comments":true,"path":"2019/02/20/Leetcode82-删除排序链表中的重读元素2/","link":"","permalink":"https://www.vazh.cn/2019/02/20/Leetcode82-删除排序链表中的重读元素2/","excerpt":"","text":"问题描述 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 123&gt; 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5&gt; 输出: 1-&gt;2-&gt;5&gt; 示例 2: 123&gt; 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3&gt; 输出: 2-&gt;3&gt; 算法思想 先对head进行判断，如果head为null,直接返回null. if判断如果head.next 不为空且head.next节点值与head值相等，在while循环里进行if判断条件，head = head.next，去除重复元素，循环结束，说明head与head.next值不相等或者head.next为空，直接返回deleteDuplicates(head.next), 因为与Leetcode83不同的是不保留重复元素，即以最后一个重复元素的下一节点作为头结点继续递归循环。else 否则直接以head.next赋值当前节点下一节点继续递归调用deleteDuplicates(head.next). 返回得到最终结果头结点head。 代码实现1234567891011121314public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return null; &#125; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 98.6% Solutionjava执行用时: 1msjava内存消耗: 21.7MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode83-删除排序链表中的重读元素","slug":"Leetcode83-删除排序链表中的重读元素","date":"2019-02-20T02:47:30.000Z","updated":"2019-09-04T04:30:21.840Z","comments":true,"path":"2019/02/20/Leetcode83-删除排序链表中的重读元素/","link":"","permalink":"https://www.vazh.cn/2019/02/20/Leetcode83-删除排序链表中的重读元素/","excerpt":"","text":"问题描述 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 算法思想 先对head进行判断，如果head为null,直接返回null. if判断如果head.next 不为空且head.next节点值与head值相等，在while循环里进行if判断条件，head = head.next，去除重复元素，循环结束，说明head与head.next值不相等或者head.next为空，直接返回deleteDuplicates(head), 即以最后一个重复元素作为头结点继续递归循环。否则直接以head.next赋值当前节点下一节点继续递归调用deleteDuplicates(head.next). 返回得到最终结果头结点head。 代码实现1234567891011121314public ListNode deleteDuplicates(ListNode head) &#123; if (head == null)&#123; return null; &#125; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 100% Solutionjava执行用时: 0ms 1msjava内存消耗: 26.7MB 22.2MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode61-旋转链表","slug":"Leetcode61-旋转链表","date":"2019-02-19T02:46:41.000Z","updated":"2019-09-04T04:28:21.491Z","comments":true,"path":"2019/02/19/Leetcode61-旋转链表/","link":"","permalink":"https://www.vazh.cn/2019/02/19/Leetcode61-旋转链表/","excerpt":"","text":"问题描述 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456&gt; 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2&gt; 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; 解释:&gt; 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL&gt; 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL&gt; 示例 2: 12345678&gt; 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4&gt; 输出: 2-&gt;0-&gt;1-&gt;NULL&gt; 解释:&gt; 向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL&gt; 向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL&gt; 向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL&gt; 向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL&gt; 算法一算法思想 定义节点headPoint指向head,用while循环获得链表head的长度，用len保存。定义n赋值k % len, 如果n等于0,说明移动位置长度k是链表长度整数倍，链表不需要变动，直接返回head. n不等于0，只需要将倒数k个节点移至前面即可，定义节点flag指向head, n为需要移动的次数，而flag移动 len - n - 1即为断开处的前置节点。 定义节点tmp, 用来保存需要移动的倒数k个节点 ，tmp指向flag.next,保存倒数k个节点，断开左右两部分，flag.next = null, headPoint为右链的最后一个节点，使headPoint指向左链第一个节点head, head指向新链头结点tmp。 返回得到最终结果头结点head。 代码实现12345678910111213141516171819202122public static ListNode rotateRight(ListNode head, int k) &#123; if (head == null) return null; int len = 0; ListNode headPoint = head; while (headPoint != null &amp;&amp; headPoint.next != null)&#123; headPoint = headPoint.next; len++; &#125; len++; int n = k % len; if (n == 0) return head; ListNode flag = head; for (int i = 0; i &lt; (len - n - 1); i++) &#123; flag = flag.next; &#125; ListNode tmp; tmp = flag.next; flag.next = null; headPoint.next = head; head = tmp; return head; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历，获取其长度。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 90% Solutionjava执行用时: 5msjava内存消耗: 27.1MB 优化算法算法思想 定义节点headPoint指向head,用while循环获得链表head的长度，用len保存。定义n赋值k % len, 如果n等于0,说明移动位置长度k是链表长度整数倍，链表不需要变动，直接返回head. n不等于0，headPoint重新指向头结点head, 如果count不等于 len - n - 1, count加一，headPoint向后移动一位，headPoint = headPoint.next, 直到headPoint移动到分割点前置节点，满足count等于 len - n - 1, 节点next = headPoint.next保存右链的地址，headPoint.next = null ,断开左右链。定义节点res保存右链的头结点，通过while循环获得右链的最后一个节点，next.next = head, 将右链移动到左链前面，获得结果res. 返回得到最终结果头结点res。 代码实现1234567891011121314151617181920212223242526272829public static ListNode rotateRightPlus(ListNode head, int k) &#123; if (head == null) return null; int len = 0; ListNode headPoint = head; while (headPoint != null)&#123; headPoint = headPoint.next; len++; &#125; int n = k % len; if (n == 0) return head; int count = 0; headPoint = head; ListNode next = null; while (headPoint != null)&#123; if (count == (len - n -1))&#123; next = headPoint.next; headPoint.next = null; break; &#125; count++; headPoint = headPoint.next; &#125; ListNode res = next; while (next.next != null)&#123; next = next.next; &#125; next.next = head; return res; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 97% Solutionjava执行用时: 9msjava内存消耗: 21.9MB 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode25-k个一组翻转链表","slug":"Leetcode25-k个一组翻转链表","date":"2019-02-18T01:38:49.000Z","updated":"2019-09-04T02:56:56.803Z","comments":true,"path":"2019/02/18/Leetcode25-k个一组翻转链表/","link":"","permalink":"https://www.vazh.cn/2019/02/18/Leetcode25-k个一组翻转链表/","excerpt":"","text":"问题描述 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 算法思想 定义四个ListNode节点,prev为前置节点，cur为当前节点，next为下一节点，check节点为了遍历长度为k的节点， canProceed统计每一次的节点长度是否有长度k . 如果canProceed等于k, 则满足有一段长度为k的链表，需要对这段链表进行逆置，否则直接返回链表即可，因为最后一段的长度小于k,不需要进行逆置。 逆置方法：当count &lt; k 且cur != null时(控制循环次数)每一次先保存当前节点的下一节点next,然后将当前节点cur指向前置节点prev,然后将前置节点指向cur,cur指向next，为下一次的循环做准备。while循环结束，如果next不为空，利用递归进行下一次的循环。 返回得到最终结果头结点head。 代码实现12345678910111213141516171819202122232425262728public ListNode reverseKGroupPlus(ListNode head, int k) &#123; ListNode prev = null; ListNode cur = head; ListNode next = null; ListNode check = head; int canProceed = 0; int count = 0; while(canProceed &lt; k &amp;&amp; check != null)&#123; check = check.next; canProceed++; &#125; if(canProceed == k)&#123; while(count &lt; k &amp;&amp; cur != null)&#123; next = cur.next; cur.next = prev; prev = cur; cur = next; count++; &#125; if(next != null)&#123; head.next = reverseKGroupPlus(next, k); &#125; return prev; &#125; else &#123; return head; &#125; &#125; 复杂度分析时间复杂度：该算法对含有 L 个结点的head进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 92% Solutionjava执行用时: 5ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Java内存区域与内存溢出异常","slug":"Java内存区域与内存溢出异常","date":"2019-01-23T07:51:58.000Z","updated":"2019-09-04T02:50:19.777Z","comments":true,"path":"2019/01/23/Java内存区域与内存溢出异常/","link":"","permalink":"https://www.vazh.cn/2019/01/23/Java内存区域与内存溢出异常/","excerpt":"","text":"Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 自动内存管理机制概述对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”又是从事最基础工作的“劳动人民”——既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。 对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。 Java虚拟机原理所谓虚拟机，就是一台虚拟的机器。他是一款软件，用来执行一系列虚拟计算指令，大体上虚拟机可以分为系统虚拟机和程序虚拟机， 大名鼎鼎的Visual Box、Vmare就属于系统虚拟机，他们完全是对物理计算的仿真，提供了一个可以运行完整操作系统的软件平台。 程序虚拟机典型代码就是Java虚拟机，它专门为执行单个计算程序而计算，在Java虚拟机中执行的指令我们成为Java自己码指令。无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。Java发展至今，出现过很多虚拟机，做初Sun使用的一款叫ClassIc的Java虚拟机，到现在引用最广泛的是HotSpot虚拟机，除了Sun以外，还有BEA的Jrockit，目前Jrockit和HostSopt都被oralce收入旗下，大有整合的趋势。 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。字节码文件加载与数据区域如下图所示。 1、 类加载子系统:负责从文件系统或者网络加载Class信息，加载的信息存放在一块称之方法区的内存空间。 2、 方法区:就是存放类的信息、常量信息、常量池信息、包括字符串字面量和数字常量等。 3、 Java堆：在Java虚拟机启动的时候建立Java堆，它是Java程序最主要的内存工作区域，几乎所有的对象实例都存放到Java堆中，堆空间是所有线程共享。 4、 直接内存：JavaNio库允许Java程序直接内存，从而提高性能，通常直接内存速度会优于Java堆。读写频繁的场合可能会考虑使用。 5、 每个虚拟机线程都有一个私有栈，一个线程的Java栈在线程创建的时候被创建，Java栈保存着局部变量、方法参数、同事Java的方法调用、返回值等。 6、 本地方法栈，最大不同为本地方法栈用于本地方法调用。Java虚拟机允许Java直接调用本地方法（通过使用C语言写） 7、 垃圾收集系统是Java的核心，也是不可少的，Java有一套自己进行垃圾清理的机制，开发人员无需手工清理，后面会详细讲。 8、 PC（Program Couneter）寄存器也是每个线程私有的空间， Java虚拟机会为每个线程创建PC寄存器，它可以看作是当前线程执行的字节码的行号指示器。在任意时刻，一个Java线程总是在执行一个方法，这个方法称为当前方法，如果当前方法不是本地方法，PC寄存器总会执行当前正在被执行的指令，如果是本地方法，则PC寄存器值为Underfined，寄存器存放如果当前执行环境指针、程序技术器、操作栈指针、计算的变量指针等信息。 9、 虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般户先进行编译成机器码后执行。 堆、栈、方法区概念区别Java虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 Java堆 根据垃圾回收机制的不同，Java堆有可能拥有不同的结构，最为常见的就是将整个Java堆分为新生代和老年代。其中新声带存放新生的对象或者年龄不大的对象，老年代则存放老年对象。新生代分为den区、s0区、s1区，s0和s1也被称为from和to区域，他们是两块大小相等并且可以互相角色的空间。绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，之后每经过一次新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄后，则进入老年代。 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”，jdk8废弃永久代。在HotSpot JVM中，这次讨论的永久代，就是上图的方法区（JVM规范中称为方法区）。《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在其他JVM上不存在永久代。下图是永久代的位置。 ​ jdk8永久代变化如下图： ​ 新生代：Eden+From Survivor+To Survivor 老年代：OldGen 永久代（方法区的实现） : PermGen—–&gt;替换为Metaspace(本地内存中) 废弃永久代官方说明：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。 永久代现实易出问题：由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen。 深入理解元空间：元空间是方法区的在HotSpot jvm 中的实现，方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。，理论上取决于32位/64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数。 虚拟机参数配置在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排查会有一定的帮助，为此，在虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行Java虚拟机，就可以在系统运行时打印相关日志，用于分析实际问题。我们进行虚拟机参数配置，其实就是围绕着堆、栈、方法区、进行配置。 堆的参数配置-XX:+PrintGC 每次触发GC的时候打印相关日志 -XX:+UseSerialGC 串行回收 -XX:+PrintGCDetails 更详细的GC日志 -Xms 堆初始值 -Xmx 堆最大可用值 -Xmn 新生代堆最大可用值 -XX:SurvivorRatio 用来设置新生代中eden空间和from/to空间的比例. -XX:SurvivorRatio=eden/from=den/to== ==总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。 设置最大堆内存 参数: -Xms5m -Xmx20m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:+PrintCommandLineFlags 12345678910111213141516171819202122232425262728293031323334353637383940414243/**- jvm参数设置- @author elvis * */ public class JvmDemo01 &#123; public static void main(String[] args) throws InterruptedException &#123; byte[] b1 = new byte[1 * 1024 * 1024]; System.out.println(\"分配了1m\"); jvmInfo(); Thread.sleep(3000); byte[] b2 = new byte[4 * 1024 * 1024]; System.out.println(\"分配了4m\"); Thread.sleep(3000); jvmInfo(); &#125; /** - 转换为m - @param maxMemory - @return */ static private String toM(long maxMemory) &#123; float num = (float) maxMemory / (1024 * 1024); DecimalFormat df = new DecimalFormat(\"0.00\");// 格式化小数 String s = df.format(num);// 返回的是String类型 return s; &#125; static private void jvmInfo() &#123; // 最大内存 long maxMemory = Runtime.getRuntime().maxMemory(); System.out.println(\"maxMemory:\" + maxMemory + \",转换为M:\" + toM(maxMemory)); // 当前空闲内存 long freeMemory = Runtime.getRuntime().freeMemory(); System.out.println(\"freeMemory:\" +freeMemory+\",转换为M:\"+toM(freeMemory)); // 已经使用内存 long totalMemory = Runtime.getRuntime().totalMemory(); System.out.println(\"totalMemory:\" +totalMemory+\",转换为M\"+toM(totalMemory)); &#125;&#125; 设置新生代与老年代优化参数 -Xmn 新生代大小，一般设为整个堆的1/3到1/4左右 -XX:SurvivorRatio 设置新生代中eden区和from/to空间的比例关系n/1 设置新生代比例参数 参数: -Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC 123456789public class JvmDemo02 &#123; public static void main(String[] args) &#123; //-Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC byte [] b = null; for (int i = 0; i &lt; 10; i++) &#123; b =new byte[1*1024*1024]; &#125; &#125;&#125; 设置新生与老年代代参数 -Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:NewRatio=2 总结:不同的堆分布情况，对系统执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。 除了可以设置新生代的绝对大小(-Xmn),可以使用(-XX:NewRatio)设置新生代和老年代的比例:-XX:NewRatio=老年代/新生代 内存溢出解决办法 设置堆内存大小 错误原因: java.lang.OutOfMemoryError: Java heap space 解决办法:设置堆内存大小 -Xms1m -Xmx70m -XX:+HeapDumpOnOutOfMemoryError 123456789101112public static void main(String[] args) throws InterruptedException &#123; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); Thread.sleep(3000); jvmInfo(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"i:\"+i); Byte [] bytes= new Byte[1*1024*1024]; list.add(bytes); jvmInfo(); &#125; System.out.println(\"添加成功...\"); &#125; 设置栈内存大小 错误原因: java.lang.StackOverflowError 栈溢出 产生于递归调用，循环遍历是不会的，但是循环方法里面产生递归调用， 也会发生栈溢出。 解决办法:设置线程最大调用深度 -Xss5m 设置最大调用深度 123456789101112131415public class JvmDemo04 &#123; private static int count; public static void count()&#123; try &#123; count++; count(); &#125; catch (Throwable e) &#123; System.out.println(\"最大深度:\"+count); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; count(); &#125;&#125; Tomcat内存溢出在catalina.sh 修改JVM堆内存大小 JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m” JVM参数调优总结在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置，默认情况不做任何设置JVM会工作的很好，但对一些配置很好的Server和具体的应用必须仔细调优才能获得最佳性能。通过设置我们希望达到一些目标： · GC的时间足够的小 · GC的次数足够的少 · 发生Full GC的周期足够的长 前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其衡。 针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值 年轻代和年老代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小 年轻代和年老代设置多大才算合理？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响？ · 更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC · 更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率 · 如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://www.vazh.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.vazh.cn/tags/JVM/"},{"name":"内存溢出","slug":"内存溢出","permalink":"https://www.vazh.cn/tags/内存溢出/"},{"name":"内存管理","slug":"内存管理","permalink":"https://www.vazh.cn/tags/内存管理/"}]},{"title":"Leetcode21-合并两个有序链表","slug":"Leetcode21-合并两个有序链表","date":"2019-01-23T03:22:20.000Z","updated":"2019-09-04T02:56:08.090Z","comments":true,"path":"2019/01/23/Leetcode21-合并两个有序链表/","link":"","permalink":"https://www.vazh.cn/2019/01/23/Leetcode21-合并两个有序链表/","excerpt":"","text":"问题描述 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 算法思想 定义两个链表 ，链表 flag 是保存结果的新表，带头结点； firstflag 是保存 flag 头节点地址的链表，while循环判断 L1 L2都不为空，分别判断当前节点的值大小 ，如果L1.val &lt; L2.val ,则用flag指向 L1 ,然后L1移到下一位 ，保存下一次遍历的地址，相反同理。然后 flag = flag.next 为下一次循环做准备。 循环结束，剩余一个链表还有数据，这时候，将first与两个链表中不为空的链表连接起来,得到就是最后的结果。 最后返回first.next,去除 flag头结点(初始化值为0)。 代码实现12345678910111213141516public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode flag = new ListNode(0); ListNode firstflag = flag; while (l1 != null &amp;&amp; l2 != null)&#123; if (l1.val &lt; l2.val)&#123; flag.next = l1; l1 = l1.next; &#125;else &#123; flag.next = l2; l2 = l2.next; &#125; flag = flag.next; &#125; flag.next = l1 != null ? l1 : l2; return firstflag.next; &#125; 复杂度分析时间复杂度：该算法对 L1 L2进行了一次遍历,假设链表L1 L2 成都分别为 r1 r2,则时间复杂度为 O(r1+r2) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 92% Solutionjava执行用时: 9ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode19-删除链表的倒数第N个节点","slug":"Leetcode19-删除链表的倒数第N个节点","date":"2019-01-23T01:58:10.000Z","updated":"2019-09-04T02:55:46.733Z","comments":true,"path":"2019/01/23/Leetcode19-删除链表的倒数第N个节点/","link":"","permalink":"https://www.vazh.cn/2019/01/23/Leetcode19-删除链表的倒数第N个节点/","excerpt":"","text":"问题描述 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 算法思想 上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 最后返回头结点 dummy.next 值。 官方图解​ 代码实现1234567891011121314151617public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // Move first to the end, maintaining the gap while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next; &#125; 复杂度分析时间复杂度：该算法对含有 LL 个结点的列表进行了一次遍历。因此时间复杂度为 O(L) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 98% Solutionjava执行用时: 8ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"},{"name":"双指针","slug":"双指针","permalink":"https://www.vazh.cn/tags/双指针/"}]},{"title":"Leetcode02-两数相加","slug":"Leetcode02-两数相加","date":"2019-01-22T03:23:56.000Z","updated":"2019-09-04T02:39:45.543Z","comments":true,"path":"2019/01/22/Leetcode02-两数相加/","link":"","permalink":"https://www.vazh.cn/2019/01/22/Leetcode02-两数相加/","excerpt":"","text":"问题描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 算法思想 定义链表 rs 用以返回结果，定义链表 last 记录 上一次的链表求和值，并且记录 rs 中 next的指针地址，否则 rs 的 next 地址会被新的值覆盖 ；定义链表 cur 记录当前链表 L1 , L2 两位求和的值 。定义val 表示每一次对应位数上的求和值。 分别判断 L1 L2是否为空，分别 L1 L2 的 val值 求和计算 。第一次循环时，先将 rs 指向 cur ,这样就有了初始地址 ，然后依次 先用 last.next = cur,等价于 rs.next = cur ，再 last = cur 使 last记录下 下一次循环时的 上一次的引用地址 || 就是last指向 rs 的尾节点。 最后得到计算结果链表 rs , 返回 rs 值。 代码实现1234567891011121314151617181920212223242526272829public ListNode addTwoNumbers(ListNode l1, ListNode l2)&#123; ListNode rs = null; ListNode last = null; ListNode cur = null; int val = 0; while (null != l1 || null != l2)&#123; if (null != l1)&#123; val += l1.val; l1 = l1.next; &#125; if (null != l2)&#123; val += l2.val; l2 = l2.next; &#125; cur = new ListNode(val % 10); val = val / 10; if (null == last)&#123; rs = cur; &#125;else &#123; last.next = cur; &#125; last = cur; &#125; if (val &gt; 0)&#123; cur = new ListNode(val); last.next = cur; &#125; return rs; &#125; 复杂度分析时间复杂度：因为while循环遍历的次数是线性的，假设L1与L2的最大长度为 r , 则时间复杂度为O(r) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 92% Solutionjava执行用时: 31ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.vazh.cn/tags/链表/"}]},{"title":"Leetcode84-柱状图最大矩形问题","slug":"Leetcode84-柱状图最大矩形问题","date":"2019-01-20T08:01:47.000Z","updated":"2019-09-04T04:31:02.032Z","comments":true,"path":"2019/01/20/Leetcode84-柱状图最大矩形问题/","link":"","permalink":"https://www.vazh.cn/2019/01/20/Leetcode84-柱状图最大矩形问题/","excerpt":"","text":"问题描述​ 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 单调栈首先引入单调栈的概念，本文解法使用了递增栈的概念。 单调栈的定义：单调栈就是栈内元素单调递增或者单调递减的栈，单调栈只能在栈顶操作 单调栈的维护是 O(n) 级的时间复杂度，因为所有元素只会进入栈一次，并且出栈后再也不会进栈了。 单调栈的性质： 单调栈里的元素具有单调性 元素加入栈前，会在栈顶端把破坏栈单调性的元素都删除 使用单调栈可以找到元素向左遍历第一个比他小的元素，也可以找到元素向左遍历第一个比他大的元素。 由于单调栈中的元素只能是单调递增或者是单调递减的，所以我们可以分别讨论这两种情况（假设不存在两个相同的元素）： 当单调栈中的元素是单调递增的时候，根据上面我们从数组的角度阐述单调栈的性质的叙述，可以得出： 当a &gt; b 时，则将元素a插入栈顶，新的栈顶则为a 当a &lt; b 时，则将从当前栈顶位置向前查找（边查找，栈顶元素边出栈），直到找到第一个比a小的数，停止查找，将元素a 插入栈顶（在当前找到的数之后，即此时元素a找到了自己的“位置”） 当单调栈中的元素是单调递减的时候，则有： 当a &lt; b 时，则将元素a插入栈顶，新的栈顶则为a 当a &gt; b 时，则将从当前栈顶位置向前查找（边查找，栈顶元素边出栈），直到找到第一个比a大的数，停止查找，将元素a 插入栈顶（在当前找到的数之后，即此时元素a找到了自己的“位置”）来源：CSDN原文：https://blog.csdn.net/liujian20150808/article/details/50752861 算法思想 首先定义一个Integer类型的栈，用以装载矩形高度数组的下标。对每一个矩形高度进行遍历，while循环首先判断确保栈不为空且当前遍历元素小于等于栈顶元素（即元素高度违反递增栈的排放高度）, 若满足条件，则首先弹栈并用 j 记录弹栈元素的值 ，用k 记录当前栈顶元素的值（栈空赋值-1），用curArea记录当前元素(矩形高度，矩形块)到栈顶元素（每一次出栈前的最大值高度，如第一次最大值2，第二次最大值6），用栈顶元素下标的下一位 i 来定位到栈顶元素的下标，这样就能计算出当前元素到栈顶元素最大矩形面积，若栈为空或元素高度符合递增栈，则依次将数组高度压栈。 然后循环遍历栈，在进行第一步后，因为最后一次进栈形成的递增栈没有遍历记录最大面积，并且没有对整体的面积(就是选取最低的元素 * 数组长度) ，事实上，在第一步完成之后，栈底元素就是整个heights数组中最小的高度值，因为比它先出栈的元素大于它，栈内其他元素因为是递增栈故也大于它。然后如同第一步，这时候栈顶元素的位置为heights.length - 1 ，最后一次循环，栈底元素出栈，面积curArea为数组长度 * heights[i] ,最后得到最大值 res 。 最后得到接雨水总量 res , 返回 res 值。 代码实现1234567891011121314151617181920public int largestRectangleArea(int[] heights) &#123; if(heights.length == 0 || heights == null) return 0; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int res = 0; for(int i = 0; i &lt; heights.length; i++)&#123; while(!s.isEmpty() &amp;&amp; heights[i] &lt;= heights[s.peek()])&#123; int j = s.pop(); int k = s.isEmpty() ? -1 : s.peek(); int curArea = (i - k - 1) * heights[j]; res = Math.max(res, curArea); &#125; s.push(i); &#125; while(!s.isEmpty())&#123; int i = s.pop(); int k = s.isEmpty() ? - 1 : s.peek(); int curArea = (heights.length - k - 1) * heights[i]; res = Math.max(res, curArea); &#125; return res; 复杂度分析时间复杂度：单调栈的维护是 O(n) 级的时间复杂度，因为所有元素只会进入栈一次，并且出栈后再也不会进栈了。因此while循环遍历的次数是线性的，故时间复杂度为O(n) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 83% Solutionjava执行用时: 20ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.vazh.cn/tags/leetcode/"},{"name":"stack","slug":"stack","permalink":"https://www.vazh.cn/tags/stack/"},{"name":"递增栈","slug":"递增栈","permalink":"https://www.vazh.cn/tags/递增栈/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2019-01-18T07:34:46.000Z","updated":"2019-01-18T07:34:46.000Z","comments":true,"path":"2019/01/18/栈和队列/","link":"","permalink":"https://www.vazh.cn/2019/01/18/栈和队列/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Leetcode42-接雨水问题","slug":"Leetcode42-接雨水问题","date":"2019-01-18T05:08:32.000Z","updated":"2019-09-04T04:26:06.718Z","comments":true,"path":"2019/01/18/Leetcode42-接雨水问题/","link":"","permalink":"https://www.vazh.cn/2019/01/18/Leetcode42-接雨水问题/","excerpt":"","text":"问题描述​ 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，记数组名为 height.在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 算法思想 先排除首尾不可能接雨水的部分，对于左端，从下标0处开始遍历，找到第一个下标 L 使得 height[ L ] &gt; height[ L + 1 ] , 因为只有从这个下标开始，它的右边才会积水， 否则因为左侧没有“墙”，故无法积水 。对于右端 ， 从下标height.length - 1 处开始遍历，找到第一个下标 R 使得 height[ R ] &gt; height[ R - 1 ] , 因为只有从这个下标开始，它的左边才会积水， 否则因为右侧没有“墙”而无法积水 。 第一步找到了左端坐标 L , 右端坐标 R , while循环遍历，每一次用left与right记录左右端下标对应的高度，即height[ L ] , height[ R ] , 当left &lt; right时（左端点高度小于右端点高度），移动坐标L , 若 height[ ++L ] &lt;= left ,则将雨水面积 left - height[ L ] 加到 ans (接雨水总量) 上；同理，当 left &gt; right 时（左端点高度大于右端点高度），移动坐标R , 若 height[ –R ] &lt;= right ,则将雨水面积right - height[ R ]加到ans (接雨水总量) 上。 最后得到接雨水总量 ans , 返回 ans 值。 代码实现12345678910111213141516171819202122232425public int trap(int [] height)&#123; if (height.length &lt; 3) return 0; int ans = 0; int l = 0, r = height.length - 1; //find the left and right edge which can hold water while (l &lt; r &amp;&amp; height[l] &lt;= height[l + 1]) l++; while (l &lt; r &amp;&amp; height[r] &lt;= height[r - 1]) r--; while (l &lt; r)&#123; int left = height[l]; int right = height[r]; if (left &lt;= right)&#123; // add volum until an edge larger than the left edge while (l &lt; r &amp;&amp; left &gt;= height[++l])&#123; ans += left - height[l]; &#125; &#125;else &#123; // add volum until an edge larger than the right edge while (l &lt; r &amp;&amp; height[--r] &lt;= right)&#123; ans += right - height[r]; &#125; &#125; &#125; return ans; &#125; 复杂度分析时间复杂度：因为while循环遍历的次数是线性的，故时间复杂度为O(n) 空间复杂度：因为变量空间申请是常数级，故空间复杂度为O(1) leetcode 98% Solutionjava执行用时: 12ms 小结初来乍到，请多多指教。如有更好的解法，欢迎在评论区讨论 ，也希望有leetcode好友加V: ZKLOVE9527 一起学习 。(微信加好友请备注 leetcode)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.vazh.cn/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.vazh.cn/tags/leetcode/"}]},{"title":"阿里巴巴与四十大盗-背包问题","slug":"阿里巴巴与四十大盗-背包问题","date":"2019-01-17T13:14:44.000Z","updated":"2019-09-04T02:47:36.093Z","comments":true,"path":"2019/01/17/阿里巴巴与四十大盗-背包问题/","link":"","permalink":"https://www.vazh.cn/2019/01/17/阿里巴巴与四十大盗-背包问题/","excerpt":"","text":"阿里巴巴与四十大盗-背包问题 有一天，阿里巴巴赶着一头毛驴上山砍柴。砍好柴准备下山时，远处突然出现一股烟尘，弥漫着直向上空飞扬，朝他这儿卷过来，而且越来越近。靠近以后，他才看清原来是一支马队，他们共有四十人，一个个年轻力壮、行动敏捷。一个首领模样的人背负沉重的鞍袋，从丛林中一直来到那个大石头跟前，喃喃地说道：“芝麻，开门吧！”随着那个头目的喊声，大石头前突然出现一道宽阔的门路，于是强盗们鱼贯而入。阿里巴巴待在树上观察他们，直到他们走得无影无踪之后，才从树上下来。他大声喊道：“芝麻，开门吧！”他的喊声刚落，洞门立刻打开了。他小心翼翼地走了进去，一下子惊呆了，洞中堆满了财物，还有多得无法计数的金银珠宝，有的散堆在地上，有的盛在皮袋中。突然看见这么多的金银财富，阿里巴巴深信这肯定是一个强盗们数代经营、掠夺所积累起来的宝窟。为了让乡亲们开开眼界，见识一下这些宝物，他想一种宝物只拿一个，如果太重就用锤子凿开，但毛驴的运载能力是有限的，怎么才能用驴子运走最大价值的财宝分给穷人呢？ 阿里巴巴陷入沉思中…… 问题分析假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v，毛驴运载能力有限，只能运走m重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？ 我们可以尝试贪心策略： （1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？ （2）每次挑选重量最小的宝物装入，能否得到最优解？ （3）每次选取单位重量价值最大的宝物，能否使价值最高？ 思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限的，所以第1种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在总重限制的情况下保证价值最大，第2种策略舍弃；而第3种是每次选取单位重量价值最大的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量m，那么一定能得到价值最大。 因此采用第3种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。 算法设计（1）数据结构及初始化。将n种宝物的重量和价值存储在结构体three（包含重量、价值、性价比3个成员）中，同时求出每种宝物的性价比也存储在对应的结构体three中，将其按照性价比从高到低排序。采用sum来存储毛驴能够运走的最大价值，初始化为0。 （2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于m（毛驴运载能力），如果小于m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m减去放入宝物的重量；如果不小于m，则取该宝物的一部分m p[i]，m=0，程序结束。m减少到0，则sum*得到最大值。 完美图解性价比排序因为贪心策略是每次选择性价比（价值/重量）高的宝物，可以按照性价比降序排序，排序后如下表所示。 宝物 i 重量 w[i] 价值v[i] 性价比p[i] 2 2 8 4 10 5 15 3 6 8 20 2.5 3 9 18 2 5 5 8 1.6 8 4 6 1.5 9 5 7 1.4 4 5 6 1.2 7 5 5 1 1 4 3 0.75 依据贪心策略，选择宝物按照贪心策略，每次选择性价比高的宝物放入： 第1次选择宝物2，剩余容量30−2=28，目前装入最大价值为8。 第2次选择宝物10，剩余容量28−5=23，目前装入最大价值为8+15=23。 第3次选择宝物6，剩余容量23−8=15，目前装入最大价值为23+20=43。 第4次选择宝物3，剩余容量15−9=6，目前装入最大价值为43+18=61。 第5次选择宝物5，剩余容量6−5=1，目前装入最大价值为61+8=69。 第6次选择宝物8，发现上次处理完时剩余容量为1，而8号宝物重量为4，无法全部放入，那么可以采用部分装入的形式，装入1个重量单位，因为8号宝物的单位重量价值为1.5，因此放入价值1×1.5=1.5，你也可以认为装入了8号宝物的1/4，目前装入最大价值为69+1.5=70.5，剩余容量为0。 构造最优解把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了8号财宝的1/4），能够装入宝物的最大价值为70.5。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Knapsack_problem implements Comparable&lt;Knapsack_problem&gt; &#123; public static final int n = 10; //宝物个数 public static double m = 30; //毛驴承载能力 double w;//每个宝物的重量 double v;//每个宝物的价值 double p;//性价比 public Knapsack_problem()&#123;&#125; public double getW() &#123; return w; &#125; public double getV() &#123; return v; &#125; public double getP() &#123; return p; &#125; @Override public int compareTo(Knapsack_problem kp) &#123; return kp.getP() &gt; this.getP() ? 1 : -1; &#125; public static void input(List&lt;Knapsack_problem&gt; list)&#123; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; Knapsack_problem.n; i++) &#123; Knapsack_problem kp = new Knapsack_problem(); System.out.print(\"请输入第\"+(i + 1)+\"个宝物的重量: \"); kp.w = sc.nextDouble(); System.out.print(\"请输入第\"+(i + 1)+\"个宝物的价值: \"); kp.v = sc.nextDouble(); kp.p = kp.v / kp.w; list.add(i, kp); &#125; &#125; public static double maxSum(List&lt;Knapsack_problem&gt; list)&#123; double sum = 0.0; //记录贪心算法运走宝物价值之和 for (int j = 0; j &lt; Knapsack_problem.n; j++) &#123; double w = list.get(j).getW(); double v = list.get(j).getV(); double p = list.get(j).getP(); if (m &gt; w)&#123; m -= w; sum += v; &#125;else &#123; sum += m * p; break; &#125; &#125; return sum; &#125; public static void main(String[] args) &#123; List&lt;Knapsack_problem&gt; list = new ArrayList&lt;&gt;(); input(list); Collections.sort(list); //已经按照性价比排序 double sum = maxSum(list); System.out.println(\"能够装入宝物的最大价值为:\" + sum); &#125;&#125; 运行结果 运行结果图如上所示 算法解析算法复杂度分析 时间复杂度：该算法的时间主要耗费在将宝物按照性价比排序上，采用的是TimSort排序，算法平均时间复杂度为O(nlogn) ，最好情况是O(n) , 最差情况是 O(nlogn). 空间复杂度：空间主要耗费在存储宝物的性价比，空间复杂度为O(n) 为了使 m 重量里的所有物品的价值最大，利用贪心思想，每次取剩下物品里面性价比最高的物品，这样可以使得在相同重量条件下比选其他物品所得到的价值更大，因此采用贪心策略能得到最优解。","categories":[{"name":"趣学算法","slug":"趣学算法","permalink":"https://www.vazh.cn/categories/趣学算法/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://www.vazh.cn/tags/贪心算法/"}]},{"title":"人之初,性本贪","slug":"人之初-性本贪","date":"2019-01-17T12:18:47.000Z","updated":"2019-09-04T02:49:11.812Z","comments":true,"path":"2019/01/17/人之初-性本贪/","link":"","permalink":"https://www.vazh.cn/2019/01/17/人之初-性本贪/","excerpt":"","text":"人之初，性本贪 我们小时候背诵《三字经》，“人之初，性本善，性相近，习相远。“ 其实我们很多时候”人之初，性本贪“。小孩子吃糖果，总是想要多多的；吃水果，想要最大的；买玩具，总是想要最好的，这些东西不是大人教的，而是与生俱来的。对美好事物的趋优性，就像植物的趋光性，”良禽择木而栖，贤臣择主而事“ “窈窕淑女，君子好逑”，我们似乎永远在追求美而优的东西。现实中的很多事情，正是因为趋优性使我们的生活一步一步走向美好。例如，我们竭尽所能买了一套房子，然后就想要添置一套家具，再就想着可能还需要一辆车子…… ​ 凡事都有两面性，一把刀可以做出美味佳肴，也可以变成杀人凶器。在这里，我们只谈好的“贪心”。 贪心本质 一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。 ———— 《算法导论》 ​ 贪心算法在解决问题的策略上“目光短浅”，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心算法并不是从整体最优考虑，它做出的选择只是在某种意义上的局部最优。贪心算法能得到许多问题的整体最优解或整体最优解的近似解。因此，贪心算法在实际中得到了大量的应用。 ​ 在贪心算法中，我们需要注意以下几个问题。 ​ (1) 没有后悔药。一旦做出选择，不可以反悔。 ​ (2) 有可能得到的不是最优解，而是最优解的近似解。 ​ (3) 选择什么样的贪心策略，直接决定算法的好坏。 贪亦有道​ “君子爱财，取之有道”，我们在贪心算法中“贪亦有道”。通常我们在遇到具体问题时，往往分不清哪些问题该用贪心策略求解，哪些问题不能使用贪心策略。经过实践我们发现，利用贪心算法求解的问题往往具有两个重要的特性：贪心选择性质和最优子结构性质。如果满足这两个性质就可以使用贪心算法了。 (1)贪心选择 ​ 所谓贪心选择性质是指原问题的整体最优解可以通过一系列局部最优的选择得到。应用同一规则，将原问题变为一个相似的但规模更小的子问题，而后的每一步都是当前最佳的选择。这种选择依赖于已做出的选择，但不依赖于未做出的选择。运用贪心策略解决的问题在程序的运行过程中无回溯过程。关于贪心选择性质，读者可在后续的贪心策略状态空间图中得到深刻的体会。 (2)最优子结构 ​ 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。例如原问题S={a1，a2，…，ai，…，an}，通过贪心选择选出一个当前最优解{ai}之后，转化为求解子问题S−{ai}，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质，如下图所示。 ​ 贪心算法秘籍武林中有武功秘籍，算法中也有贪心秘籍。上面我们已经知道了具有贪心选择和最优子结构性质就可以使用贪心算法，那么如何使用呢？下面介绍贪心算法秘籍。 (1)贪心策略 ​ 首先要确定贪心策略，选择当前看上去最好的一个方案。例如，挑选苹果，如果你认为个大的是最好的，那你每次都从苹果堆中拿一个最大的，作为局部最优解，贪心策略就是选择当前最大的苹果；如果你认为最红的苹果是最好的，那你每次都从苹果堆中拿一个最红的，贪心策略就是选择当前最红的苹果。因此根据求解目标不同，贪心策略也会不同。 (2)局部最优解 ​ 根据贪心策略，一步一步地得到局部最优解。例如，第一次选一个最大的苹果放起来，记为a1，第二次再从剩下的苹果堆中选择一个最大的苹果放起来，记为a2，以此类推。 (3) 全局最优解 ​ 把所有的局部最优解合成为原来问题的一个最优解（a1，a2，…）。","categories":[{"name":"趣学算法","slug":"趣学算法","permalink":"https://www.vazh.cn/categories/趣学算法/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://www.vazh.cn/tags/贪心算法/"}]},{"title":"初始mybatis","slug":"初始mybatis","date":"2019-01-15T14:37:51.000Z","updated":"2019-01-15T14:40:49.000Z","comments":true,"path":"2019/01/15/初始mybatis/","link":"","permalink":"https://www.vazh.cn/2019/01/15/初始mybatis/","excerpt":"","text":"１.Mybatis介绍MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 ２.jdbc问题总结如下：1、数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。2、Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。3、使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。4、对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 ３ mybatis解析 1、mybatis配置SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。2、通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂3、由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。4、mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。5、Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。6、Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。7、Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 ４ 初识sqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132~~~&lt;configuration&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; 数据库资源文件引入 &lt;!-- 别名 包以其子包下所有类 头字母大小都行--&gt; &lt;typeAliases&gt;&lt;!-- &lt;typeAlias type=&quot;User&quot; alias=&quot;User&quot;/&gt; --&gt; &lt;package name=&quot;com.elvis.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis01?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;test&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- Mapper的位置 Mapper.xml 写Sql语句的文件的位置 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;&lt;!-- &lt;mapper resource=&quot;sqlmap/User.xml&quot; class=&quot;&quot; url=&quot;&quot;/&gt; --&gt; &lt;!--&lt;mapper class=&quot;UserMapper&quot; /&gt; --&gt;&lt;!-- &lt;mapper url=&quot;&quot; /&gt; --&gt; &lt;package name=&quot;com.elvis.mybatis.mapper&quot;/&gt;推荐 &lt;/mappers&gt;&lt;/configuration&gt;","categories":[{"name":"framework","slug":"framework","permalink":"https://www.vazh.cn/categories/framework/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://www.vazh.cn/tags/mybatis/"}]},{"title":"不念过去,不畏将来","slug":"不念过去-不畏将来","date":"2019-01-15T12:25:59.000Z","updated":"2019-01-15T13:54:13.000Z","comments":true,"path":"2019/01/15/不念过去-不畏将来/","link":"","permalink":"https://www.vazh.cn/2019/01/15/不念过去-不畏将来/","excerpt":"","text":"​ 岁月如歌，转眼已过了多年;时光荏苒，恍惚却不知所措;初来学校，满怀一生梦想;物是人非，已不再是曾经。￼有人说人们随着年龄的增长会越来越念旧，会去忍不住回想青春时期的往事。我认为处于任何年龄阶段的人们都可能会有这种情感，或许在某个时间段里这种情感会愈发地强烈。 听闻，我们我们用初中三年去盼望高中三年，高中三年去憧憬大学四年，而用大学四年去怀念中学六年年，最终用一生去惦记我们的青春。 愿我们经历着、成长着。虽然也说也笑也哭过，但愿从未畏惧过，世界很美好，偶尔怀念过去，也别停止前行，因为未来更精彩。","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://www.vazh.cn/categories/生活随笔/"}],"tags":[{"name":"青春","slug":"青春","permalink":"https://www.vazh.cn/tags/青春/"}]}]}